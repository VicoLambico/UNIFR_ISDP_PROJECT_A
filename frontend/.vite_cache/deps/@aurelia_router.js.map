{
  "version": 3,
  "sources": ["../../node_modules/@aurelia/route-recognizer/src/index.ts", "../../node_modules/@aurelia/router/src/endpoints/endpoint.ts", "../../node_modules/@aurelia/router/src/endpoints/endpoint-content.ts", "../../node_modules/@aurelia/router/src/found-route.ts", "../../node_modules/@aurelia/router/src/instructions/instruction-parser.ts", "../../node_modules/@aurelia/router/src/router-options.ts", "../../node_modules/@aurelia/router/src/instructions/instruction-parameters.ts", "../../node_modules/@aurelia/router/src/instructions/instruction-component.ts", "../../node_modules/@aurelia/router/src/utilities/utils.ts", "../../node_modules/@aurelia/router/src/utilities/open-promise.ts", "../../node_modules/@aurelia/router/src/utilities/runner.ts", "../../node_modules/@aurelia/router/src/errors.ts", "../../node_modules/@aurelia/router/src/route.ts", "../../node_modules/@aurelia/router/src/decorators/routes.ts", "../../node_modules/@aurelia/router/src/endpoints/viewport-scope-content.ts", "../../node_modules/@aurelia/router/src/endpoints/viewport-scope.ts", "../../node_modules/@aurelia/router/src/navigation.ts", "../../node_modules/@aurelia/router/src/utilities/awaitable-map.ts", "../../node_modules/@aurelia/router/src/endpoints/viewport-content.ts", "../../node_modules/@aurelia/router/src/endpoints/viewport-options.ts", "../../node_modules/@aurelia/router/src/endpoints/viewport.ts", "../../node_modules/@aurelia/router/src/instructions/instruction-endpoint.ts", "../../node_modules/@aurelia/router/src/instructions/routing-instruction.ts", "../../node_modules/@aurelia/router/src/navigator.ts", "../../node_modules/@aurelia/router/src/route-recognizer.ts", "../../node_modules/@aurelia/router/src/utilities/collection.ts", "../../node_modules/@aurelia/router/src/endpoint-matcher.ts", "../../node_modules/@aurelia/router/src/routing-scope.ts", "../../node_modules/@aurelia/router/src/utilities/task-queue.ts", "../../node_modules/@aurelia/router/src/browser-viewer-store.ts", "../../node_modules/@aurelia/router/src/navigation-coordinator.ts", "../../node_modules/@aurelia/router/src/routing-hook.ts", "../../node_modules/@aurelia/router/src/title.ts", "../../node_modules/@aurelia/router/src/router.ts", "../../node_modules/@aurelia/router/src/resources/link-handler.ts", "../../node_modules/@aurelia/router/src/decorators/route.ts", "../../node_modules/@aurelia/router/src/resources/utils.ts", "../../node_modules/@aurelia/router/src/resources/viewport.ts", "../../node_modules/@aurelia/router/src/resources/viewport-scope.ts", "../../node_modules/@aurelia/router/src/resources/load.ts", "../../node_modules/@aurelia/router/src/resources/href.ts", "../../node_modules/@aurelia/router/src/resources/considered-active.ts", "../../node_modules/@aurelia/router/src/configuration.ts"],
  "sourcesContent": ["export interface IConfigurableRoute<T> {\n  readonly path: string;\n  readonly caseSensitive?: boolean;\n  readonly handler: T;\n}\n\nexport class Parameter {\n  public constructor(\n    public readonly name: string,\n    public readonly isOptional: boolean,\n    public readonly isStar: boolean,\n    public readonly pattern: RegExp | null,\n  ){}\n\n  public satisfiesPattern(value: string): boolean {\n    if (this.pattern === null) return true;\n    this.pattern.lastIndex = 0;\n    return this.pattern.test(value);\n  }\n}\n\nexport class ConfigurableRoute<T> implements IConfigurableRoute<T> {\n  public constructor(\n    public readonly path: string,\n    public readonly caseSensitive: boolean,\n    public handler: T,\n  ) {}\n}\n\nexport class Endpoint<T> {\n  private _residualEndpoint: Endpoint<T> | null = null;\n  public get residualEndpoint(): Endpoint<T> | null { return this._residualEndpoint; }\n  /** @internal */\n  public set residualEndpoint(endpoint: Endpoint<T> | null) {\n    if (this._residualEndpoint !== null) throw new Error('Residual endpoint is already set');\n    this._residualEndpoint = endpoint;\n  }\n\n  public constructor(\n    public readonly route: ConfigurableRoute<T>,\n    public readonly params: readonly Parameter[],\n  ) {}\n\n  public equalsOrResidual(other: Endpoint<T> | null | undefined): boolean {\n    return other != null && this === other || this._residualEndpoint === other;\n  }\n}\n\nexport class RecognizedRoute<T> {\n  public readonly params: Readonly<Record<string, string | undefined>>;\n  public constructor(\n    public readonly endpoint: Endpoint<T>,\n    params: Readonly<Record<string, string | undefined>>,\n  ) {\n    const $params: Record<string, string | undefined> = Object.create(null);\n    for (const key in params) {\n      const value = params[key];\n      $params[key] = value != null ? decodeURIComponent(value) : value;\n    }\n    this.params = Object.freeze($params);\n  }\n}\n\nclass Candidate<T> {\n  public head: AnyState<T>;\n  public endpoint: Endpoint<T>;\n  private params: Record<string, string | undefined> | null = null;\n  private isConstrained: boolean = false;\n  private satisfiesConstraints: boolean | null = null;\n\n  public constructor(\n    private readonly chars: string[],\n    private readonly states: AnyState<T>[],\n    private readonly skippedStates: DynamicState<T>[],\n    private readonly result: RecognizeResult<T>,\n  ) {\n    this.head = states[states.length - 1];\n    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n    this.endpoint = this.head?.endpoint!;\n  }\n\n  public advance(ch: string): void {\n    const { chars, states, skippedStates, result } = this;\n    let stateToAdd: AnyState<T> | null = null;\n\n    let matchCount = 0;\n    const state = states[states.length - 1];\n\n    function $process(\n      nextState: AnyState<T>,\n      skippedState: DynamicState<T> | null,\n    ): void {\n      if (nextState.isMatch(ch)) {\n        if (++matchCount === 1) {\n          stateToAdd = nextState;\n        } else {\n          result.add(\n            new Candidate(\n              chars.concat(ch),\n              states.concat(nextState),\n              skippedState === null ? skippedStates : skippedStates.concat(skippedState),\n              result,\n            ),\n          );\n        }\n      }\n\n      if (state.segment === null && nextState.isOptional && nextState.nextStates !== null) {\n        if (nextState.nextStates.length > 1) {\n          throw createError(`${nextState.nextStates.length} nextStates`);\n        }\n        const separator = nextState.nextStates[0];\n        if (!separator.isSeparator) {\n          throw createError(`Not a separator`);\n        }\n        if (separator.nextStates !== null) {\n          for (const $nextState of separator.nextStates) {\n            $process($nextState, nextState);\n          }\n        }\n      }\n    }\n\n    if (state.isDynamic) {\n      $process(state, null);\n    }\n    if (state.nextStates !== null) {\n      for (const nextState of state.nextStates) {\n        $process(nextState, null);\n      }\n    }\n\n    if (stateToAdd !== null) {\n      states.push(this.head = stateToAdd);\n      chars.push(ch);\n      this.isConstrained = this.isConstrained\n        || (stateToAdd as AnyState<T>).isDynamic\n        && ((stateToAdd as AnyState<T>).segment as DynamicSegment<T>)!.isConstrained;\n      if ((stateToAdd as AnyState<T>).endpoint !== null) {\n        this.endpoint = (stateToAdd as AnyState<T>).endpoint!;\n      }\n    }\n\n    if (matchCount === 0) {\n      result.remove(this);\n    }\n  }\n\n  /** @internal */\n  public _finalize(): boolean {\n    function collectSkippedStates(\n      skippedStates: DynamicState<T>[],\n      state: AnyState<T>,\n    ): void {\n      const nextStates = state.nextStates;\n      if (nextStates !== null) {\n        if (nextStates.length === 1 && nextStates[0].segment === null) {\n          collectSkippedStates(skippedStates, nextStates[0]);\n        } else {\n          for (const nextState of nextStates) {\n            if (nextState.isOptional && nextState.endpoint !== null) {\n              skippedStates.push(nextState);\n              if (nextState.nextStates !== null) {\n                for (const $nextState of nextState.nextStates) {\n                  collectSkippedStates(skippedStates, $nextState);\n                }\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    collectSkippedStates(this.skippedStates, this.head);\n    if (!this.isConstrained) return true;\n    this._getParams();\n    return this.satisfiesConstraints!;\n  }\n\n  /** @internal */\n  public _getParams(): Record<string, string | undefined> {\n    let params = this.params;\n    if (params != null) return params;\n    const { states, chars, endpoint } = this;\n\n    params = {};\n    this.satisfiesConstraints = true;\n    // First initialize all properties with undefined so they all exist (even if they're not filled, e.g. non-matched optional params)\n    for (const param of endpoint.params) {\n      params[param.name] = void 0;\n    }\n\n    for (let i = 0, ii = states.length; i < ii; ++i) {\n      const state = states[i];\n      if (state.isDynamic) {\n        const segment = state.segment;\n        const name = segment.name;\n        if (params[name] === void 0) {\n          params[name] = chars[i];\n        } else {\n          params[name] += chars[i];\n        }\n\n        // check for constraint if this state's segment is constrained\n        // and the state is the last dynamic state in a series of dynamic states.\n        // null fallback is used, as a star segment can also be a dynamic segment, but without a pattern.\n        const checkConstraint = state.isConstrained\n          && !Object.is(states[i + 1]?.segment, segment);\n\n        if (!checkConstraint) continue;\n\n        this.satisfiesConstraints = this.satisfiesConstraints && state.satisfiesConstraint(params[name]!);\n      }\n    }\n\n    if(this.satisfiesConstraints) {\n      this.params = params;\n    }\n    return params;\n  }\n\n  /**\n   * Compares this candidate to another candidate to determine the correct sorting order.\n   *\n   * This algorithm is different from `sortSolutions` in v1's route-recognizer in that it compares\n   * the candidates segment-by-segment, rather than merely comparing the cumulative of segment types\n   *\n   * This resolves v1's ambiguity in situations like `/foo/:id/bar` vs. `/foo/bar/:id`, which had the\n   * same sorting value because they both consist of two static segments and one dynamic segment.\n   *\n   * With this algorithm, `/foo/bar/:id` would always be sorted first because the second segment is different,\n   * and static wins over dynamic.\n   *\n   * ### NOTE\n   * This algorithm violates some of the invariants of v1's algorithm,\n   * but those invariants were arguably not very sound to begin with. Example:\n   *\n   * `/foo/*path/bar/baz` vs. `/foo/bar/*path1/*path2`\n   * - in v1, the first would win because that match has fewer stars\n   * - in v2, the second will win because there is a bigger static match at the start of the pattern\n   *\n   * The algorithm should be more logical and easier to reason about in v2, but it's important to be aware of\n   * subtle difference like this which might surprise some users who happened to rely on this behavior from v1,\n   * intentionally or unintentionally.\n   *\n   * @param b - The candidate to compare this to.\n   * Parameter name is `b` because the method should be used like so: `states.sort((a, b) => a.compareTo(b))`.\n   * This will bring the candidate with the highest score to the first position of the array.\n   */\n  public compareTo(b: Candidate<T>): -1 | 1 | 0 {\n    const statesA = this.states;\n    const statesB = b.states;\n\n    for (let iA = 0, iB = 0, ii = Math.max(statesA.length, statesB.length); iA < ii; ++iA) {\n      let stateA = statesA[iA];\n      if (stateA === void 0) {\n        return 1;\n      }\n\n      let stateB = statesB[iB];\n      if (stateB === void 0) {\n        return -1;\n      }\n\n      let segmentA = stateA.segment;\n      let segmentB = stateB.segment;\n      if (segmentA === null) {\n        if (segmentB === null) {\n          ++iB;\n          continue;\n        }\n\n        if ((stateA = statesA[++iA]) === void 0) {\n          return 1;\n        }\n\n        segmentA = stateA.segment!;\n      } else if (segmentB === null) {\n        if ((stateB = statesB[++iB]) === void 0) {\n          return -1;\n        }\n\n        segmentB = stateB.segment!;\n      }\n\n      if (segmentA!.kind < segmentB!.kind) {\n        return 1;\n      }\n\n      if (segmentA!.kind > segmentB!.kind) {\n        return -1;\n      }\n\n      ++iB;\n    }\n\n    const skippedStatesA = this.skippedStates;\n    const skippedStatesB = b.skippedStates;\n\n    const skippedStatesALen = skippedStatesA.length;\n    const skippedStatesBLen = skippedStatesB.length;\n\n    if (skippedStatesALen < skippedStatesBLen) {\n      return 1;\n    }\n\n    if (skippedStatesALen > skippedStatesBLen) {\n      return -1;\n    }\n\n    for (let i = 0; i < skippedStatesALen; ++i) {\n      const skippedStateA = skippedStatesA[i];\n      const skippedStateB = skippedStatesB[i];\n\n      if (skippedStateA.length < skippedStateB.length) {\n        return 1;\n      }\n\n      if (skippedStateA.length > skippedStateB.length) {\n        return -1;\n      }\n    }\n\n    // This should only be possible with a single pattern with multiple consecutive star segments.\n    // TODO: probably want to warn or even throw here, but leave it be for now.\n    return 0;\n  }\n}\n\nfunction hasEndpoint<T>(candidate: Candidate<T>): boolean {\n  return candidate.head.endpoint !== null;\n}\n\nfunction compareChains<T>(a: Candidate<T>, b: Candidate<T>): -1 | 1 | 0 {\n  return a.compareTo(b);\n}\n\nclass RecognizeResult<T> {\n  private readonly candidates: Candidate<T>[] = [];\n\n  public get isEmpty(): boolean {\n    return this.candidates.length === 0;\n  }\n\n  public constructor(rootState: SeparatorState<T>) {\n    this.candidates = [new Candidate([''], [rootState], [], this)];\n  }\n\n  public getSolution(): Candidate<T> | null {\n    const candidates = this.candidates.filter(x => hasEndpoint(x) && x._finalize());\n    if (candidates.length === 0) {\n      return null;\n    }\n\n    candidates.sort(compareChains);\n\n    return candidates[0];\n  }\n\n  public add(candidate: Candidate<T>): void {\n    this.candidates.push(candidate);\n  }\n\n  public remove(candidate: Candidate<T>): void {\n    this.candidates.splice(this.candidates.indexOf(candidate), 1);\n  }\n\n  public advance(ch: string): void {\n    const candidates = this.candidates.slice();\n\n    for (const candidate of candidates) {\n      candidate.advance(ch);\n    }\n  }\n}\n\n/**\n * Reserved parameter name that's used when registering a route with residual star segment (catch-all).\n */\nexport const RESIDUE = '$$residue' as const;\n\nconst routeParameterPattern = /^:(?<name>[^?\\s{}]+)(?:\\{\\{(?<constraint>.+)\\}\\})?(?<optional>\\?)?$/g;\n\nexport class RouteRecognizer<T> {\n  private readonly rootState: SeparatorState<T> = new State(null, null, '') as SeparatorState<T>;\n  private readonly cache: Map<string, RecognizedRoute<T> | null> = new Map<string, RecognizedRoute<T> | null>();\n  private readonly endpointLookup: Map<string, Endpoint<T>> = new Map<string, Endpoint<T>>();\n\n  public add(routeOrRoutes: IConfigurableRoute<T> | readonly IConfigurableRoute<T>[], addResidue: boolean = false): void {\n    let params: readonly Parameter[];\n    let endpoint: Endpoint<T>;\n    if (routeOrRoutes instanceof Array) {\n      for (const route of routeOrRoutes) {\n        endpoint = this.$add(route, false);\n        params = endpoint.params;\n        // add residue iff the last parameter is not a star segment.\n        if (!addResidue || (params[params.length - 1]?.isStar ?? false)) continue;\n        endpoint.residualEndpoint = this.$add({ ...route, path: `${route.path}/*${RESIDUE}` }, true);\n      }\n    } else {\n      endpoint = this.$add(routeOrRoutes, false);\n      params = endpoint.params;\n      // add residue iff the last parameter is not a star segment.\n      if (addResidue && !(params[params.length - 1]?.isStar ?? false)) {\n        endpoint.residualEndpoint = this.$add({ ...routeOrRoutes, path: `${routeOrRoutes.path}/*${RESIDUE}` }, true);\n      }\n    }\n\n    // Clear the cache whenever there are state changes, because the recognizeResults could be arbitrarily different as a result\n    this.cache.clear();\n  }\n\n  private $add(route: IConfigurableRoute<T>, addResidue: boolean): Endpoint<T> {\n    const path = route.path;\n    const lookup = this.endpointLookup;\n    if(lookup.has(path)) throw createError(`Cannot add duplicate path '${path}'.`);\n    const $route = new ConfigurableRoute(path, route.caseSensitive === true, route.handler);\n\n    // Normalize leading, trailing and double slashes by ignoring empty segments\n    const parts = path === '' ? [''] : path.split('/').filter(isNotEmpty);\n    const params: Parameter[] = [];\n\n    let state = this.rootState as AnyState<T>;\n\n    for (const part of parts) {\n      // Each segment always begins with a slash, so we represent this with a non-segment state\n      state = state.append(null, '/');\n\n      switch (part.charAt(0)) {\n        case ':': { // route parameter\n          routeParameterPattern.lastIndex = 0;\n          const match = routeParameterPattern.exec(part);\n          const { name, optional } = match?.groups ?? {};\n          const isOptional = optional === '?';\n          if (name === RESIDUE) throw new Error(`Invalid parameter name; usage of the reserved parameter name '${RESIDUE}' is used.`);\n          const constraint = match?.groups?.constraint;\n          const pattern: RegExp | null = constraint != null ? new RegExp(constraint) : null;\n          params.push(new Parameter(name, isOptional, false, pattern));\n          state = new DynamicSegment<T>(name, isOptional, pattern).appendTo(state);\n          break;\n        }\n        case '*': { // dynamic route\n          const name = part.slice(1);\n          let kind: SegmentKind.residue | SegmentKind.star;\n          if (name === RESIDUE) {\n            if (!addResidue) throw new Error(`Invalid parameter name; usage of the reserved parameter name '${RESIDUE}' is used.`);\n            kind = SegmentKind.residue;\n          } else {\n            kind = SegmentKind.star;\n          }\n          params.push(new Parameter(name, true, true, null));\n          state = new StarSegment<T>(name, kind).appendTo(state);\n          break;\n        }\n        default: { // standard path route\n          state = new StaticSegment<T>(part, $route.caseSensitive).appendTo(state);\n          break;\n        }\n      }\n    }\n\n    const endpoint = new Endpoint<T>($route, params);\n\n    state.setEndpoint(endpoint);\n    lookup.set(path, endpoint);\n    return endpoint;\n  }\n\n  public recognize(path: string): RecognizedRoute<T> | null {\n    let result = this.cache.get(path);\n    if (result === void 0) {\n      this.cache.set(path, result = this.$recognize(path));\n    }\n    return result;\n  }\n\n  private $recognize(path: string): RecognizedRoute<T> | null {\n    path = decodeURI(path);\n\n    if (!path.startsWith('/')) {\n      path = `/${path}`;\n    }\n\n    if (path.length > 1 && path.endsWith('/')) {\n      path = path.slice(0, -1);\n    }\n\n    const result = new RecognizeResult(this.rootState);\n    for (let i = 0, ii = path.length; i < ii; ++i) {\n      const ch = path.charAt(i);\n      result.advance(ch);\n\n      if (result.isEmpty) {\n        return null;\n      }\n    }\n\n    const candidate = result.getSolution();\n    if (candidate === null) {\n      return null;\n    }\n\n    const { endpoint } = candidate;\n    const params = candidate._getParams();\n\n    return new RecognizedRoute<T>(endpoint, params);\n  }\n\n  public getEndpoint(path: string): Endpoint<T> | null {\n    return this.endpointLookup.get(path) ??  null;\n  }\n}\n\ntype StaticState<T> = State<T> & {\n  readonly isSeparator: false;\n  readonly isDynamic: false;\n  readonly isOptional: false;\n\n  readonly prevState: StaticState<T> | SeparatorState<T>;\n  readonly segment: StaticSegment<T>;\n};\n\ntype DynamicState<T> = State<T> & {\n  readonly isSeparator: false;\n  readonly isDynamic: true;\n  readonly isOptional: true | false;\n\n  readonly prevState: SeparatorState<T>;\n  readonly segment: DynamicSegment<T>;\n};\n\ntype StarState<T> = State<T> & {\n  readonly isSeparator: false;\n  readonly isDynamic: true;\n  readonly isOptional: false;\n\n  readonly prevState: SeparatorState<T>;\n  readonly segment: StarSegment<T>;\n};\n\ntype SeparatorState<T> = State<T> & {\n  readonly isSeparator: true;\n  readonly isDynamic: false;\n  readonly isOptional: false;\n\n  readonly path: null;\n  readonly segment: null;\n};\n\ntype AnyState<T> = (\n  StaticState<T> |\n  DynamicState<T> |\n  StarState<T> |\n  SeparatorState<T>\n);\n\ntype SegmentToState<S, T> = (\n  S extends StaticSegment<T> ? StaticState<T> :\n  S extends DynamicSegment<T> ? DynamicState<T> :\n  S extends StarSegment<T> ? StarState<T> :\n  S extends null ? SeparatorState<T> :\n  never\n);\n\nclass State<T> {\n  public nextStates: AnyState<T>[] | null = null;\n  public readonly isSeparator: boolean;\n  public readonly isDynamic: boolean;\n  public readonly isOptional: boolean;\n\n  public endpoint: Endpoint<T> | null = null;\n  public readonly length: number;\n  public readonly isConstrained: boolean = false;\n\n  public constructor(\n    public readonly prevState: AnyState<T> | null,\n    public readonly segment: AnySegment<T> | null,\n    public readonly value: string,\n  ) {\n    switch (segment?.kind) {\n      case SegmentKind.dynamic:\n        this.length = prevState!.length + 1;\n        this.isSeparator = false;\n        this.isDynamic = true;\n        this.isOptional = segment.optional;\n        this.isConstrained = segment.isConstrained;\n        break;\n      case SegmentKind.star:\n      case SegmentKind.residue:\n        this.length = prevState!.length + 1;\n        this.isSeparator = false;\n        this.isDynamic = true;\n        this.isOptional = false;\n        break;\n      case SegmentKind.static:\n        this.length = prevState!.length + 1;\n        this.isSeparator = false;\n        this.isDynamic = false;\n        this.isOptional = false;\n        break;\n      case undefined:\n        this.length = prevState === null ? 0 : prevState.length;\n        this.isSeparator = true;\n        this.isDynamic = false;\n        this.isOptional = false;\n        break;\n    }\n  }\n\n  public append<S extends AnySegment<T> | null>(segment: S, value: string): SegmentToState<S, T> {\n    let state: AnyState<T> | undefined;\n    let nextStates = this.nextStates;\n    if (nextStates === null) {\n      state = void 0;\n      nextStates = this.nextStates = [];\n    } else if (segment === null) {\n      state = nextStates.find(s => s.value === value);\n    } else {\n      state = nextStates.find(s => s.segment?.equals(segment));\n    }\n\n    if (state === void 0) {\n      nextStates.push(state = new State(this as AnyState<T>, segment, value) as AnyState<T>);\n    }\n\n    return state as SegmentToState<S, T>;\n  }\n\n  public setEndpoint(this: AnyState<T>, endpoint: Endpoint<T>): void {\n    if (this.endpoint !== null) {\n      throw createError(`Cannot add ambiguous route. The pattern '${endpoint.route.path}' clashes with '${this.endpoint.route.path}'`);\n    }\n    this.endpoint = endpoint;\n    if (this.isOptional) {\n      this.prevState.setEndpoint(endpoint);\n      if (this.prevState.isSeparator && this.prevState.prevState !== null) {\n        this.prevState.prevState.setEndpoint(endpoint);\n      }\n    }\n  }\n\n  public isMatch(ch: string): boolean {\n    const segment = this.segment;\n    switch (segment?.kind) {\n      case SegmentKind.dynamic:\n        return !this.value.includes(ch);\n      case SegmentKind.star:\n      case SegmentKind.residue:\n        return true;\n      case SegmentKind.static:\n      case undefined:\n        // segment separators (slashes) are non-segments. We could say return ch === '/' as well, technically.\n        return this.value.includes(ch);\n    }\n  }\n\n  public satisfiesConstraint(value: string): boolean {\n    return this.isConstrained\n      ? (this.segment as DynamicSegment<T>).satisfiesPattern(value)\n      : true;\n  }\n}\n\nfunction isNotEmpty(segment: string): boolean {\n  return segment.length > 0;\n}\n\ntype AnySegment<T> = (\n  StaticSegment<T> |\n  DynamicSegment<T> |\n  StarSegment<T>\n);\n\n_START_CONST_ENUM();\nconst enum SegmentKind {\n  residue = 1, // used when default residue segment is registered.\n  star = 2,\n  dynamic = 3,\n  static = 4,\n}\n_END_CONST_ENUM();\n\nclass StaticSegment<T> {\n  public get kind(): SegmentKind.static { return SegmentKind.static; }\n\n  public constructor(\n    public readonly value: string,\n    public readonly caseSensitive: boolean,\n  ) {}\n\n  public appendTo(state: AnyState<T>): StaticState<T> {\n    const { value, value: { length } } = this;\n\n    if (this.caseSensitive) {\n      for (let i = 0; i < length; ++i) {\n        state = state.append(\n          /* segment */this,\n          /* value   */value.charAt(i),\n        );\n      }\n    } else {\n      for (let i = 0; i < length; ++i) {\n        const ch = value.charAt(i);\n        state = state.append(\n          /* segment */this,\n          /* value   */ch.toUpperCase() + ch.toLowerCase(),\n        );\n      }\n    }\n\n    return state as StaticState<T>;\n  }\n\n  public equals(b: AnySegment<T>): boolean {\n    return (\n      b.kind === SegmentKind.static &&\n      b.caseSensitive === this.caseSensitive &&\n      b.value === this.value\n    );\n  }\n}\n\nclass DynamicSegment<T> {\n  public get kind(): SegmentKind.dynamic { return SegmentKind.dynamic; }\n  public readonly isConstrained: boolean;\n\n  public constructor(\n    public readonly name: string,\n    public readonly optional: boolean,\n    public readonly pattern: RegExp | null,\n  ) {\n    if (pattern === void 0) throw new Error(`Pattern is undefined`);\n    this.isConstrained = pattern !== null;\n  }\n\n  public appendTo(state: AnyState<T>): DynamicState<T> {\n    state = state.append(\n      /* segment */this,\n      /* value   */'/',\n    );\n\n    return state;\n  }\n\n  public equals(b: AnySegment<T>): boolean {\n    return (\n      b.kind === SegmentKind.dynamic &&\n      b.optional === this.optional &&\n      b.name === this.name\n    );\n  }\n\n  public satisfiesPattern(value: string): boolean {\n    if (this.pattern === null) return true;\n    this.pattern.lastIndex = 0;\n    return this.pattern.test(value);\n  }\n}\n\nclass StarSegment<T> {\n  public constructor(\n    public readonly name: string,\n    public readonly kind: SegmentKind.star | SegmentKind.residue,\n  ) {}\n\n  public appendTo(state: AnyState<T>): StarState<T> {\n    state = state.append(\n      /* segment */this,\n      /* value   */'',\n    );\n\n    return state;\n  }\n\n  public equals(b: AnySegment<T>): boolean {\n    return (\n      (b.kind === SegmentKind.star || b.kind === SegmentKind.residue) &&\n      b.name === this.name\n    );\n  }\n}\n\nconst createError = (msg: string) => new Error(msg);\n", "import { IContainer } from '@aurelia/kernel';\nimport { ICustomElementController, ICustomElementViewModel } from '@aurelia/runtime-html';\nimport {\n  LoadInstruction,\n  IRouter,\n  TransitionAction,\n  RoutingScope,\n  Step,\n  Route,\n  RoutingInstruction,\n  Navigation,\n  NavigationCoordinator,\n  IViewportOptions,\n  IViewportScopeOptions,\n  EndpointContent,\n  Viewport,\n  ViewportScope,\n  NavigationFlags,\n} from '../index';\n\n/**\n * An endpoint is anything that can receive and process a routing instruction.\n */\n\n/**\n * Additional properties for endpoint custom elements.\n */\nexport interface IConnectedCustomElement extends ICustomElementViewModel {\n  element: HTMLElement;\n  container: IContainer;\n  controller: ICustomElementController;\n\n  setActivity?: (state: string | NavigationFlags, active: boolean) => void;\n}\n\nexport interface IEndpointOptions {\n  /**\n   * The transitions in the endpoint shouldn't be added to the navigation history\n   */\n  noHistory?: boolean;\n}\n\nexport type EndpointType = Viewport | ViewportScope;\nexport type EndpointTypeName = 'Viewport' | 'ViewportScope';\n\nexport interface IEndpoint extends Endpoint { }\n\nexport class Endpoint {\n  /**\n   * The contents of the endpoint. New contents are pushed to this, making\n   * the last one the active one.\n   */\n  public contents: EndpointContent[] = [];\n\n  /**\n   * The action (to be) performed by the transition\n   */\n  public transitionAction: TransitionAction = '';\n\n  /**\n   * The configured route path to this endpoint\n   */\n  public path: string | null = null;\n\n  public constructor(\n    public readonly router: IRouter,\n    /**\n     * The endpoint name\n     */\n    public name: string,\n    /**\n     * The custom element connected to this endpoint\n     */\n    public connectedCE: IConnectedCustomElement | null,\n    public options: IEndpointOptions = {}\n  ) { }\n\n  /**\n   * The current content of the endpoint\n   */\n  public getContent(): EndpointContent {\n    return this.contents[0];\n  }\n\n  /**\n   * The next, to be transitioned in, content of the endpoint\n   */\n  public getNextContent(): EndpointContent | null {\n    return this.contents.length > 1 ? this.contents[this.contents.length - 1] : null;\n  }\n\n  /**\n   * The content of the endpoint from a specific time (index)\n   */\n  public getTimeContent(_timestamp: number = Infinity): EndpointContent | null {\n    return this.getContent();\n  }\n\n  /**\n   * The content for a specific navigation (or coordinator)\n   */\n   public getNavigationContent(navigation: NavigationCoordinator | Navigation): EndpointContent | null {\n    if (navigation instanceof NavigationCoordinator) {\n      navigation = navigation.navigation;\n    }\n    if (navigation instanceof Navigation) {\n      return this.contents.find(content => content.navigation === navigation) ?? null;\n    }\n    return null;\n  }\n\n  /**\n   * The active content, next or current.\n   */\n  public get activeContent(): EndpointContent {\n    return this.getNextContent() ?? this.getContent();\n  }\n\n  /**\n   * The routing scope that's currently, based on content, connected\n   * to the endpoint. This is always the actually connected scope.\n   */\n  public get connectedScope(): RoutingScope {\n    return this.activeContent?.connectedScope;\n  }\n\n  /**\n   * The current, based on content, routing scope for the endpoint.\n   * The scope used when finding next scope endpoints and configured routes.\n   */\n  public get scope(): RoutingScope {\n    return this.connectedScope.scope;\n  }\n\n  /**\n   * The routing scope that currently, based on content, owns the viewport.\n   */\n  public get owningScope(): RoutingScope {\n    return this.connectedScope.owningScope!;\n  }\n\n  /**\n   * The connected custom element's controller.\n   */\n  public get connectedController(): ICustomElementController | null {\n    return this.connectedCE?.$controller ?? null;\n  }\n\n  /**\n   * Whether the endpoint is a Viewport.\n   */\n  public get isViewport(): boolean {\n    return this instanceof Viewport;\n  }\n  /**\n   * Whether the endpoint is a ViewportScope.\n   */\n  public get isViewportScope(): boolean {\n    return this instanceof ViewportScope;\n  }\n\n  /**\n   * Whether the endpoint is empty. Overloaded with proper check\n   * by Viewport and ViewportScope.\n   */\n  public get isEmpty(): boolean {\n    return false;\n  }\n\n  /**\n   * For debug purposes.\n   */\n  public get pathname(): string {\n    return this.connectedScope.pathname;\n  }\n\n  /**\n   * For debug purposes.\n   */\n  public toString(): string {\n    throw new Error(`Method 'toString' needs to be implemented in all endpoints!`);\n  }\n\n  /**\n   * Set the next content for the endpoint. Returns the action that the endpoint\n   * will take when the navigation coordinator starts the transition.\n   *\n   * @param _instruction - The routing instruction describing the next content\n   * @param _navigation - The navigation that requests the content change\n   */\n  public setNextContent(_instruction: RoutingInstruction, _navigation: Navigation): TransitionAction {\n    throw new Error(`Method 'setNextContent' needs to be implemented in all endpoints!`);\n  }\n\n  /**\n   * Connect an endpoint CustomElement to this endpoint, applying options\n   * while doing so.\n   *\n   * @param _connectedCE - The custom element to connect\n   * @param _options - The options to apply\n   */\n  public setConnectedCE(_connectedCE: IConnectedCustomElement, _options: IViewportOptions | IViewportScopeOptions): void {\n    throw new Error(`Method 'setConnectedCE' needs to be implemented in all endpoints!`);\n  }\n\n  /**\n   * Transition from current content to the next.\n   *\n   * @param _coordinator - The coordinator of the navigation\n   */\n  public transition(_coordinator: NavigationCoordinator): void {\n    throw new Error(`Method 'transition' needs to be implemented in all endpoints!`);\n  }\n\n  /**\n   * Finalize the change of content by making the next content the current\n   * content. The previously current content is deleted.\n   */\n  public finalizeContentChange(_coordinator: NavigationCoordinator, _step: Step<void> | null): void {\n    throw new Error(`Method 'finalizeContentChange' needs to be implemented in all endpoints!`);\n  }\n\n  /**\n   * Abort the change of content. The next content is freed/discarded.\n   *\n   * @param _step - The previous step in this transition Run\n   */\n  public cancelContentChange(_coordinator: NavigationCoordinator, _noExitStep: Step<void> | null = null): void | Step<void> {\n    throw new Error(`Method 'cancelContentChange' needs to be implemented in all endpoints!`);\n  }\n\n  /**\n   * Get any configured routes in the relevant content's component type.\n   */\n  public getRoutes(): Route[] {\n    throw new Error(`Method 'getRoutes' needs to be implemented in all endpoints!`);\n  }\n\n  /**\n   * Get the title for the content.\n   *\n   * @param navigation - The navigation that requests the content change\n   */\n  public getTitle(_navigation: Navigation): string {\n    throw new Error(`Method 'getTitle' needs to be implemented in all endpoints!`);\n  }\n\n  /**\n   * Remove the endpoint, deleting its contents.\n   *\n   * @param _step - The previous step in this transition Run\n   * @param _connectedCE - The custom element that's being removed\n   */\n  public removeEndpoint(_step: Step | null, _connectedCE: IConnectedCustomElement | null): boolean | Promise<boolean> {\n    this.contents.forEach(content => content.delete());\n    return true;\n  }\n\n  /**\n   * Check if the next content can be unloaded.\n   *\n   * @param step - The previous step in this transition Run\n   */\n  public canUnload(_coordinator: NavigationCoordinator, _step: Step<boolean> | null): boolean | Promise<boolean> {\n    return true;\n  }\n  /**\n   * Check if the next content can be loaded.\n   *\n   * @param step - The previous step in this transition Run\n   */\n  public canLoad(_coordinator: NavigationCoordinator, _step: Step<boolean>): boolean | LoadInstruction | LoadInstruction[] | Promise<boolean | LoadInstruction | LoadInstruction[]> {\n    return true;\n  }\n\n  /**\n   * Unload the next content.\n   *\n   * @param step - The previous step in this transition Run\n   */\n  public unload(_coordinator: NavigationCoordinator, _step: Step<void> | null): void | Step<void> {\n    return;\n  }\n  /**\n   * Load the next content.\n   *\n   * @param step - The previous step in this transition Run\n   */\n  public load(_coordinator: NavigationCoordinator, _step: Step<void>): Step<void> | void {\n    return;\n  }\n}\n", "import { Endpoint } from './endpoint';\nimport { IRouter } from '../router';\nimport { Navigation, RoutingInstruction, RoutingScope } from '../index';\n\n/**\n * The endpoint content encapsulates the content of an endpoint.\n *\n * Endpoint contents are used to represent the full endpoint state\n * and can be used for caching.\n */\n\nexport class EndpointContent {\n  /**\n   * The routing scope that's connected to the endpoint content\n   */\n  public connectedScope: RoutingScope;\n\n  /**\n   * Whether the content has completed its navigation\n   */\n  public completed: boolean = false;\n\n  public constructor(\n    public readonly router: IRouter,\n    /**\n     * The endpoint the endpoint content belongs to\n     */\n    public endpoint: Endpoint,\n    /**\n     * The routing scope the endpoint content belongs to/is owned by\n     */\n    owningScope: RoutingScope | null,\n    /**\n     * Whether the endpoint has its own routing scope, containing\n     * endpoints it owns\n     */\n    hasScope: boolean,\n    /**\n     * The routing instruction that has created the content\n     */\n    public instruction: RoutingInstruction = RoutingInstruction.create('') as RoutingInstruction,\n\n    /**\n     * The navigation that created the endpoint content\n     */\n    public navigation = Navigation.create({\n      instruction: '',\n      fullStateInstruction: '',\n    }),\n  ) {\n    this.connectedScope = new RoutingScope(router, hasScope, owningScope, this);\n    // Skip if no root scope (meaning we ARE the root scope!)\n    if (this.router.rootScope !== null) {\n      (this.endpoint.connectedScope?.parent ?? this.router.rootScope.scope).addChild(this.connectedScope);\n    }\n  }\n\n  /**\n   * Whether the endpoint content is the active one within its endpoint\n   */\n  public get isActive(): boolean {\n    return this.endpoint.activeContent === this;\n  }\n\n  /**\n   * Delete the endpoint content and its routing scope\n   */\n  public delete(): void {\n    this.connectedScope.parent?.removeChild(this.connectedScope);\n  }\n}\n", "/**\n *\n * NOTE: This file is still WIP and will go through at least one more iteration of refactoring, commenting and clean up!\n * In its current state, it is NOT a good source for learning about the inner workings and design of the router.\n *\n */\nimport { Route } from './route';\nimport { RoutingInstruction } from './instructions/routing-instruction';\n\n/**\n * Used when founding route/instructions\n *\n * @internal\n */\nexport class FoundRoute {\n  public constructor(\n    public match: Route | null = null,\n    public matching: string = '',\n    public instructions: RoutingInstruction[] = [],\n    public remaining: string = '',\n    // public remaining: string | null = null,\n    public params: Record<string, unknown> = {},\n  ) { }\n\n  public get foundConfiguration(): boolean {\n    return this.match !== null;\n  }\n  public get foundInstructions(): boolean {\n    return this.instructions.some(instruction => !instruction.component.none);\n  }\n  public get hasRemaining(): boolean {\n    return this.instructions.some(instruction => instruction.hasNextScopeInstructions);\n  }\n}\n", "import { RoutingInstruction } from './routing-instruction';\nimport { Separators } from '../router-options';\n\nexport class InstructionParser {\n  public static parse(seps: Separators, instructions: string, grouped: boolean, topScope: boolean): { instructions: RoutingInstruction[]; remaining: string } {\n    if (!instructions) {\n      return { instructions: [], remaining: '' };\n    }\n    if (instructions.startsWith(seps.sibling) && !InstructionParser.isAdd(seps, instructions)) {\n      throw new Error(`Instruction parser error: Unnecessary siblings separator ${seps.sibling} in beginning of instruction part \"${instructions}\".`);\n    }\n    const routingInstructions: RoutingInstruction[] = [];\n    let guard = 1000;\n    while (instructions.length && guard) {\n      guard--;\n      if (instructions.startsWith(seps.scope)) {\n        if (routingInstructions.length === 0) {\n          throw new Error(`Instruction parser error: Children without parent in instruction part \"(${instructions}\" is not allowed.`);\n        }\n        topScope = false;\n        instructions = instructions.slice(seps.scope.length);\n        const groupStart = instructions.startsWith(seps.groupStart);\n        if (groupStart) {\n          instructions = instructions.slice(seps.groupStart.length);\n          grouped = true;\n        }\n        const { instructions: found, remaining } = InstructionParser.parse(seps, instructions, groupStart, false);\n        routingInstructions[routingInstructions.length - 1].nextScopeInstructions = found;\n        instructions = remaining;\n      } else if (instructions.startsWith(seps.groupStart)) {\n        instructions = instructions.slice(seps.groupStart.length);\n        const { instructions: found, remaining } = InstructionParser.parse(seps, instructions, true, topScope);\n        routingInstructions.push(...found);\n        instructions = remaining;\n      } else if (instructions.startsWith(seps.groupEnd)) {\n        if (grouped) {\n          instructions = instructions.slice(seps.groupEnd.length);\n        }\n        let i = 0;\n        const ii = instructions.length;\n        for (; i < ii; i++) {\n          if (instructions.slice(i, i + seps.sibling.length) === seps.sibling) {\n            return { instructions: routingInstructions, remaining: instructions };\n          }\n          if (instructions.slice(i, i + seps.groupEnd.length) !== seps.groupEnd) {\n            if (routingInstructions.length > 1) {\n              throw new Error(`Instruction parser error: Children below scope ${seps.groupStart}${seps.groupEnd} in instruction part \"(${instructions}\" is not allowed.`);\n            } else {\n              instructions = instructions.slice(i);\n              break;\n            }\n          }\n        }\n        if (i >= ii) {\n          return { instructions: routingInstructions, remaining: instructions };\n        }\n      } else if (instructions.startsWith(seps.sibling) && !InstructionParser.isAdd(seps, instructions)) {\n        if (!grouped) {\n          return { instructions: routingInstructions, remaining: instructions };\n        }\n        instructions = instructions.slice(seps.sibling.length);\n\n      } else {\n        const { instruction: routingInstruction, remaining } = InstructionParser.parseOne(seps, instructions);\n        routingInstructions.push(routingInstruction);\n        instructions = remaining;\n      }\n    }\n\n    return { instructions: routingInstructions, remaining: instructions };\n  }\n\n  private static isAdd(seps: Separators, instruction: string): boolean {\n    return (instruction === seps.add || instruction.startsWith(`${seps.add}${seps.viewport}`));\n  }\n\n  private static parseOne(seps: Separators, instruction: string): {\n    instruction: RoutingInstruction;\n    remaining: string;\n  } {\n    const tokens = [seps.parameters, seps.viewport, seps.noScope, seps.groupEnd, seps.scope, seps.sibling];\n    let component: string | undefined = void 0;\n    let parametersString: string | undefined = void 0;\n    let viewport: string | undefined = void 0;\n    let scope = true;\n    let token!: string;\n    let pos: number;\n    const unparsed = instruction;\n\n    const specials = [seps.add, seps.clear];\n    for (const special of specials) {\n      if (instruction === special) {\n        component = instruction;\n        instruction = '';\n        tokens.shift(); // parameters\n        tokens.shift(); // viewport\n        token = seps.viewport;\n        break;\n      }\n    }\n    if (component === void 0) {\n      for (const special of specials) {\n        if (instruction.startsWith(`${special}${seps.viewport}`)) {\n          component = special;\n          instruction = instruction.slice(`${special}${seps.viewport}`.length);\n          tokens.shift(); // parameters\n          tokens.shift(); // viewport\n          token = seps.viewport;\n          break;\n        }\n      }\n    }\n\n    if (component === void 0) {\n      ({ token, pos } = InstructionParser.findNextToken(instruction, tokens));\n\n      component = pos !== -1 ? instruction.slice(0, pos) : instruction;\n      instruction = pos !== -1 ? instruction.slice(pos + token.length) : '';\n\n      tokens.shift(); // parameters\n      if (token === seps.parameters) {\n        ({ token, pos } = InstructionParser.findNextToken(instruction, [seps.parametersEnd]));\n        parametersString = instruction.slice(0, pos);\n        instruction = instruction.slice(pos + token.length);\n\n        ({ token } = InstructionParser.findNextToken(instruction, tokens));\n        instruction = instruction.slice(token.length);\n      }\n\n      tokens.shift(); // viewport\n    }\n    if (token === seps.viewport) {\n      ({ token, pos } = InstructionParser.findNextToken(instruction, tokens));\n      viewport = pos !== -1 ? instruction.slice(0, pos) : instruction;\n      instruction = pos !== -1 ? instruction.slice(pos + token.length) : '';\n    }\n\n    tokens.shift(); // noScope\n    if (token === seps.noScope) {\n      scope = false;\n    }\n\n    // Restore token that belongs to next instruction\n    if (token === seps.groupEnd || token === seps.scope || token === seps.sibling) {\n      instruction = `${token}${instruction}`;\n    }\n\n    if ((component ?? '') === '') {\n      throw new Error(`Instruction parser error: No component specified in instruction part \"${instruction}\".`);\n    }\n\n    const routingInstruction: RoutingInstruction = RoutingInstruction.create(component, viewport, parametersString, scope) as RoutingInstruction;\n    routingInstruction.unparsed = unparsed;\n\n    return { instruction: routingInstruction, remaining: instruction };\n  }\n\n  private static findNextToken(instruction: string, tokens: string[]): { token: string; pos: number } {\n    const matches: Record<string, number> = {};\n    // Tokens can have length > 1\n    for (const token of tokens) {\n      const tokenPos = instruction.indexOf(token);\n      if (tokenPos > -1) {\n        matches[token] = instruction.indexOf(token);\n      }\n    }\n    const pos = Math.min(...Object.values(matches));\n    for (const token in matches) {\n      if (matches[token] === pos) {\n        return { token, pos };\n      }\n    }\n    return { token: '', pos: -1 };\n  }\n}\n", "/* eslint-disable no-template-curly-in-string */\nimport { IContainer } from '@aurelia/kernel';\nimport { INavigatorOptions } from './navigator';\nimport { NavigationState } from './navigation-coordinator';\nimport { RoutingInstruction } from './instructions/routing-instruction';\nimport { IRoutingHookDefinition } from './routing-hook';\nimport { IRouter, Router, IRouterConfiguration, RouterConfiguration, ComponentAppellation } from './index';\nimport { Navigation } from './navigation';\n\n/**\n * How contents are swapped in a viewport when transitioning. Default: `attach-next-detach-current`\n */\nexport type SwapOrder = 'attach-next-detach-current' | 'attach-detach-simultaneously' | 'detach-current-attach-next' | 'detach-attach-simultaneously';\n\nexport interface ITitleOptions extends Partial<TitleOptions> { }\n\n/**\n * The router's title configuration\n */\nexport class TitleOptions {\n  protected constructor(\n    /**\n     * The full application title. Can use placeholders `${componentTitles}`\n     * and `${appTitleSeparator} for joined component titles and a separator\n     * between the component titles and the application name.\n     * Default: '${componentTitles}\\${appTitleSeparator}Aurelia'\n     */\n    // eslint-disable-next-line no-useless-escape\n    public appTitle: string = '${componentTitles}\\${appTitleSeparator}Aurelia',\n\n    /**\n     * The separator between the joined component titles and application name.\n     * Default: ' | '\n     */\n    public appTitleSeparator: string = ' | ',\n\n    /**\n     * In what order component titles are joined into `${componentTitles}`.\n     * Default: 'top-down'\n     */\n    public componentTitleOrder: 'top-down' | 'bottom-up' = 'top-down',\n\n    /**\n     * The separator between the component titles. Default: ' > '\n     */\n    public componentTitleSeparator: string = ' > ',\n\n    /**\n     * Whether components' names should be used sa titles for components\n     * that doesn't specify a title. Default: true\n     */\n    public useComponentNames: boolean = true,\n\n    /**\n     * Prefixes that are removed from components' names before they are\n     * used as titles. Default: 'app-'\n     */\n    public componentPrefix: string | string[] = 'app-',\n\n    /**\n     * Function that is called for each component/route title. The\n     * returned value is used instead as title. Default: undefined\n     */\n    public transformTitle?: (title: string, instruction: RoutingInstruction, navigation: Navigation) => string,\n  ) { }\n\n  public static create(input: string | ITitleOptions = {}): TitleOptions {\n    input = typeof input === 'string' ? { appTitle: input } : input;\n\n    return new TitleOptions(\n      input.appTitle,\n      input.appTitleSeparator,\n      input.componentTitleOrder,\n      input.componentTitleSeparator,\n      input.useComponentNames,\n      input.componentPrefix,\n      input.transformTitle,\n    );\n  }\n\n  public static for(context: IRouterConfiguration | IRouter | IContainer): TitleOptions {\n    return RouterOptions.for(context).title;\n  }\n\n  public apply(input: string | ITitleOptions = {}): void {\n    input = typeof input === 'string' ? { appTitle: input } : input;\n\n    this.appTitle = input.appTitle ?? this.appTitle;\n    this.appTitleSeparator = input.appTitleSeparator ?? this.appTitleSeparator;\n    this.componentTitleOrder = input.componentTitleOrder ?? this.componentTitleOrder;\n    this.componentTitleSeparator = input.componentTitleSeparator ?? this.componentTitleSeparator;\n    this.useComponentNames = input.useComponentNames ?? this.useComponentNames;\n    this.componentPrefix = input.componentPrefix ?? this.componentPrefix;\n    this.transformTitle = 'transformTitle' in input ? input.transformTitle : this.transformTitle;\n  }\n}\n\nexport interface ISeparators extends Partial<Separators> { }\n\n/**\n * The separators used in the direct routing syntax\n */\nexport class Separators {\n  protected constructor(\n    /**\n     * The character(s) that denotes the start of viewport name\n     */\n    public viewport: string = '@', // ':',\n\n    /**\n     * The character(s) that separates siblings\n     */\n    public sibling: string = '+', // '/',\n\n    /**\n     * The character(s) that denotes the start of a new scope\n     */\n    public scope: string = '/', // '+',\n\n    /**\n     * The character(s) to indicate the start of a grou\n     */\n    public groupStart: string = '(', // ''\n\n    /**\n     * The character(s) to indicate the end of a group\n     */\n    public groupEnd: string = ')', // ''\n\n    /**\n     * The character(s) to indicate that the viewport doesn't have\n     * a routing scope\n     */\n    public noScope: string = '!',\n\n    /**\n     * The character(s) that denotes the start of component parameters\n     */\n    public parameters: string = '(', // '='\n\n    /**\n     * The character(s) that denotes the end of component parameters\n     */\n    public parametersEnd: string = ')', // ''\n\n    /**\n     * The character(s) that separates component parameters\n     */\n    public parameterSeparator: string = ',', // '&'\n\n    /**\n     * The character(s) that separates a component parameter's key and value\n     */\n    public parameterKeySeparator: string = '=',\n\n    /**\n     * The character(s) that denotes that the instructions are additive/not\n     * full viewport state\n     */\n    public add: string = '+',\n\n    /**\n     * The character(s) that denotes that a viewport or routing scope should\n     * be cleared/emptied\n     */\n    public clear: string = '-',\n\n    /**\n     * The character(s) that denotes the start of a component method (not yet\n     * implemented)\n     */\n    public action: string = '.',\n  ) { }\n\n  public static create(input: ISeparators = {}): Separators {\n    return new Separators(\n      input.viewport,\n      input.sibling,\n      input.scope,\n      input.groupStart,\n      input.groupEnd,\n      input.noScope,\n      input.parameters,\n      input.parametersEnd,\n      input.parameterSeparator,\n      input.parameterKeySeparator,\n      input.add,\n      input.clear,\n      input.action,\n    );\n  }\n\n  public static for(context: IRouterConfiguration | IRouter | IContainer): Separators {\n    return RouterOptions.for(context).separators;\n  }\n\n  public apply(input: ISeparators = {}): void {\n    this.viewport = input.viewport ?? this.viewport;\n    this.sibling = input.sibling ?? this.sibling;\n    this.scope = input.scope ?? this.scope;\n    this.groupStart = input.groupStart ?? this.groupStart;\n    this.groupEnd = input.groupEnd ?? this.groupEnd;\n    this.noScope = input.noScope ?? this.noScope;\n    this.parameters = input.parameters ?? this.parameters;\n    this.parametersEnd = input.parametersEnd ?? this.parametersEnd;\n    this.parameterSeparator = input.parameterSeparator ?? this.parameterSeparator;\n    this.parameterKeySeparator = input.parameterKeySeparator ?? this.parameterKeySeparator;\n    this.add = input.add ?? this.add;\n    this.clear = input.clear ?? this.clear;\n    this.action = input.action ?? this.action;\n  }\n}\n\nexport interface IIndicators extends Partial<Indicators> { }\n\n/**\n * The indicators used to mark different states\n */\nexport class Indicators {\n  protected constructor(\n    /**\n     * The name of the class indicating that the load link is active\n     */\n    public loadActive: string = 'active',\n\n    /**\n     * The name of the class indicating that the viewport is navigating.\n     * The different types of navigation -- first, new, back, forward and\n     * refresh -- will be added as well with this class as prefix, for\n     * example 'navigating-back'.\n     */\n    public viewportNavigating: string = 'navigating',\n  ) { }\n\n  public static create(input: IIndicators = {}): Indicators {\n    return new Indicators(\n      input.loadActive,\n      input.viewportNavigating,\n    );\n  }\n\n  public static for(context: IRouterConfiguration | IRouter | IContainer): Indicators {\n    return RouterOptions.for(context).indicators;\n  }\n\n  public apply(input: IIndicators = {}): void {\n    this.loadActive = input.loadActive ?? this.loadActive;\n    this.viewportNavigating = input.viewportNavigating ?? this.viewportNavigating;\n  }\n}\n\nexport type FallbackAction = 'abort' | 'process-children';\n\nexport interface IRouterOptions extends Omit<Partial<RouterOptions>, 'separators' | 'indicators' | 'title'> {\n  /**\n   * The router's title configuration\n   */\n  title?: string | ITitleOptions;\n\n  /**\n   * The separators used in the direct routing syntax\n   */\n  separators?: ISeparators;\n\n  /**\n   * The indicators used to mark different states\n   */\n  indicators?: IIndicators;\n\n  /**\n   * Global routing hooks that should be added (primarily from start)\n   */\n  hooks?: IRoutingHookDefinition[];\n}\n\nexport class RouterOptions implements INavigatorOptions {\n  /**\n   * The router configuration these options belong to.\n   */\n  public routerConfiguration!: RouterConfiguration;\n\n  /**\n   * Any routing hooks that were set during registration with\n   * RouterConfiguration.customize are temporarily stored here\n   * so that they can be set once properly instantiated.\n   */\n  private registrationHooks: IRoutingHookDefinition[] = [];\n\n  protected constructor(\n    /**\n     * The separators used in the direct routing syntax\n     */\n    public separators: Separators = Separators.create(),\n\n    /**\n     * The indicators used to mark different states\n     */\n    public indicators: Indicators = Indicators.create(),\n\n    /**\n     * Whether the fragment should be used for the url/path\n     */\n    public useUrlFragmentHash: boolean = true,\n\n    /**\n     * The base path (base element href) for the app. If set to\n     * - a string that string is used as base path,\n     * - null the value is read from base element's href attribute (default).\n     * The base path is removed or added to the Location url as\n     * needed.\n     */\n    public basePath: string | null = null,\n\n    /**\n     * Whether the `href` html attribute can be used like the `load` custom attribute\n     */\n    public useHref: boolean = true,\n\n    /**\n     * The amount of navigation history entries that are stateful. Default: 0\n     */\n    public statefulHistoryLength: number = 0,\n\n    /**\n     * Whether direct routing should be used. Default: true\n     */\n    public useDirectRouting: boolean = true,\n\n    /**\n     * Whether configured routes should be used. Default: true\n     */\n    public useConfiguredRoutes: boolean = true,\n\n    /**\n     * Whether a load instruction by default is a complete state navigation,\n     * for all viewports, or a partial state navigation that is only specifying\n     * the change of the new state of specified viewports. Default: false\n     */\n    public completeStateNavigations: boolean = false,\n\n    /**\n     * The router's title configuration\n     */\n    public title: TitleOptions = TitleOptions.create(),\n\n    /**\n     * The navigation states that are synced meaning that sibling viewports\n     * will wait for all other siblings to reach the navigation state before\n     * continuing with the next steps in the transition. For example, the\n     * `guardedUnload` sync state means that no sibling will continue with\n     * the `canLoad` hook before all siblings have completed the `canUnload`\n     * hooks. To get v1 routing hook behavior, where all routing hooks are\n     * synced,`guardedLoad`, `unload` and `load` should be added to default.\n     * Default: `guardedUnload`, `swapped`, `completed`\n     */\n    public navigationSyncStates: NavigationState[] = ['guardedUnload', 'swapped', 'completed'],\n\n    /**\n     * How contents are swapped in a viewport when transitioning. Default: `attach-next-detach-current`\n     */\n    public swapOrder: SwapOrder = 'attach-next-detach-current',\n\n    /**\n     * The component to be loaded if a specified can't be loaded.\n     * The unloadable component is passed as a parameter to the fallback.\n     */\n    public fallback: ComponentAppellation = '',\n\n    /**\n     * Whether the fallback action is to load the fallback component in\n     * place of the unloadable component and continue with any child\n     * instructions or if the fallback is to be called and the processing\n     * of the children to be aborted.\n     */\n    public fallbackAction: FallbackAction = 'abort',\n  ) { }\n\n  public static create(input: IRouterOptions = {}): RouterOptions {\n    return new RouterOptions(\n      Separators.create(input.separators),\n      Indicators.create(input.indicators),\n      input.useUrlFragmentHash,\n      input.basePath,\n      input.useHref,\n      input.statefulHistoryLength,\n      input.useDirectRouting,\n      input.useConfiguredRoutes,\n      input.completeStateNavigations,\n      TitleOptions.create(input.title),\n      input.navigationSyncStates,\n      input.swapOrder,\n      input.fallback,\n      input.fallbackAction,\n    );\n  }\n\n  public static for(context: IRouterConfiguration | IRouter | IContainer): RouterOptions {\n    if (context instanceof RouterConfiguration) {\n      return context.options;\n    }\n    if (context instanceof Router) {\n      context = context.configuration;\n    } else {\n      context = context.get(IRouterConfiguration);\n    }\n    return context.options;\n  }\n\n  /**\n   * Apply router options.\n   *\n   * @param options - The options to apply\n   */\n  public apply(options: IRouterOptions): void {\n    options = options ?? {};\n    this.separators.apply(options.separators);\n    this.indicators.apply(options.indicators);\n    this.useUrlFragmentHash = options.useUrlFragmentHash ?? this.useUrlFragmentHash;\n    this.basePath = options.basePath ?? this.basePath;\n    this.useHref = options.useHref ?? this.useHref;\n    this.statefulHistoryLength = options.statefulHistoryLength ?? this.statefulHistoryLength;\n    this.useDirectRouting = options.useDirectRouting ?? this.useDirectRouting;\n    this.useConfiguredRoutes = options.useConfiguredRoutes ?? this.useConfiguredRoutes;\n    this.completeStateNavigations = options.completeStateNavigations ?? this.completeStateNavigations;\n    this.title.apply(options.title);\n    this.navigationSyncStates = options.navigationSyncStates ?? this.navigationSyncStates;\n    this.swapOrder = options.swapOrder ?? this.swapOrder;\n    this.fallback = options.fallback ?? this.fallback;\n    this.fallbackAction = options.fallbackAction ?? this.fallbackAction;\n\n    // TODO: Fix RoutingHooks!\n    if (Array.isArray(options.hooks)) {\n      if (this.routerConfiguration !== void 0) {\n        options.hooks.forEach(hook => this.routerConfiguration.addHook(hook.hook, hook.options));\n      } else {\n        this.registrationHooks = options.hooks;\n      }\n    }\n  }\n\n  public setRouterConfiguration(routerConfiguration: RouterConfiguration): void {\n    this.routerConfiguration = routerConfiguration;\n\n    // Set previously configured routing hooks\n    // TODO: Fix RoutingHooks!\n    this.registrationHooks.forEach(hook => this.routerConfiguration.addHook(hook.hook, hook.options));\n    this.registrationHooks.length = 0;\n  }\n}\n", "/**\n *\n * NOTE: This file is still WIP and will go through at least one more iteration of refactoring, commenting and clean up!\n * In its current state, it is NOT a good source for learning about the inner workings and design of the router.\n *\n */\nimport { IRouter, IRouterConfiguration } from '../index';\nimport { RouteableComponentType } from '../interfaces';\nimport { Separators } from '../router-options';\nimport { IContainer } from '@aurelia/kernel';\n\n/**\n * Shouldn't be used directly\n *\n * @internal\n */\ntype ParametersType = 'none' | 'string' | 'array' | 'object';\n\nexport type Parameters = {\n  [key: string]: unknown;\n};\n\nexport interface IComponentParameter {\n  key?: string | undefined;\n  value: unknown;\n}\n\n/**\n * Public API - The routing instructions are the core of the router's navigations\n */\n\nexport type ComponentParameters = string | Record<string, unknown> | unknown[];\n\nexport class InstructionParameters {\n  public parametersString: string | null = null;\n  public parametersRecord: Parameters | null = null;\n  public parametersList: unknown[] | null = null;\n  public parametersType: ParametersType = 'none';\n\n  public get none(): boolean {\n    return this.parametersType === 'none';\n  }\n\n  // Static methods\n  public static create(componentParameters?: ComponentParameters): InstructionParameters {\n    const parameters: InstructionParameters = new InstructionParameters();\n    parameters.set(componentParameters);\n    return parameters;\n  }\n\n  // TODO: Deal with separators in data and complex types\n  public static parse(context: IRouterConfiguration | IRouter | IContainer, parameters: ComponentParameters | null, uriComponent: boolean = false): IComponentParameter[] {\n    if (parameters == null || parameters.length === 0) {\n      return [];\n    }\n    const seps = Separators.for(context);\n    const parameterSeparator = seps.parameterSeparator;\n    const parameterKeySeparator = seps.parameterKeySeparator;\n\n    if (typeof parameters === 'string') {\n      const list: IComponentParameter[] = [];\n      const params = parameters.split(parameterSeparator);\n      for (const param of params) {\n        let key: string | undefined;\n        let value: string;\n        [key, value] = param.split(parameterKeySeparator);\n        if (value === void 0) {\n          value = uriComponent ? decodeURIComponent(key) : key;\n          key = void 0;\n        } else if (uriComponent) {\n          key = decodeURIComponent(key);\n          value = decodeURIComponent(value);\n        }\n        list.push({ key, value });\n      }\n      return list;\n    }\n    if (Array.isArray(parameters)) {\n      return parameters.map(param => ({ key: void 0, value: param }));\n    }\n    const keys = Object.keys(parameters);\n    keys.sort();\n    return keys.map(key => ({ key, value: parameters[key] }));\n  }\n\n  public get typedParameters(): ComponentParameters | null {\n    switch (this.parametersType) {\n      case 'string':\n        return this.parametersString;\n      case 'array':\n        return this.parametersList;\n      case 'object':\n        return this.parametersRecord;\n      default:\n        return null;\n    }\n  }\n  // TODO: Deal with separators in data and complex types\n  public static stringify(context: IRouterConfiguration | IRouter | IContainer, parameters: IComponentParameter[], uriComponent: boolean = false): string {\n    if (!Array.isArray(parameters) || parameters.length === 0) {\n      return '';\n    }\n    const seps = Separators.for(context);\n    return parameters\n      .map(param => {\n        const key = param.key !== void 0 && uriComponent ? encodeURIComponent(param.key) : param.key;\n        const value = uriComponent ? encodeURIComponent(param.value as string) : param.value as string;\n        return key !== void 0 && key !== value ? key + seps.parameterKeySeparator + value : value;\n      })\n      .join(seps.parameterSeparator);\n  }\n\n  /**\n   * Whether a record of instruction parameters contains another record of\n   * instruction parameters.\n   *\n   * @param parametersToSearch - Parameters that should contain (superset)\n   * @param parametersToFind - Parameters that should be contained (subset)\n   */\n  public static contains(parametersToSearch: Parameters, parametersToFind: Parameters): boolean {\n    // All parameters to find need to exist in parameters to search\n    return Object.keys(parametersToFind).every(key => parametersToFind[key] === parametersToSearch[key]);\n  }\n\n  // Instance methods\n\n  public parameters(context: IRouterConfiguration | IRouter | IContainer): IComponentParameter[] {\n    return InstructionParameters.parse(context, this.typedParameters);\n  }\n\n  public set(parameters?: ComponentParameters | null): void {\n    this.parametersString = null;\n    this.parametersList = null;\n    this.parametersRecord = null;\n    if (parameters == null || parameters === '') {\n      this.parametersType = 'none';\n      parameters = null;\n    } else if (typeof parameters === 'string') {\n      this.parametersType = 'string';\n      this.parametersString = parameters;\n    } else if (Array.isArray(parameters)) {\n      this.parametersType = 'array';\n      this.parametersList = parameters;\n    } else {\n      this.parametersType = 'object';\n      this.parametersRecord = parameters;\n    }\n  }\n\n  public get(context: IRouterConfiguration | IRouter | IContainer, name?: string): unknown {\n    if (name === void 0) {\n      // TODO: Turn this into a parameters object instead\n      return this.parameters(context);\n    }\n    const params = this.parameters(context).filter(p => p.key === name).map(p => p.value);\n    if (params.length === 0) {\n      return;\n    }\n    return params.length === 1 ? params[0] : params;\n  }\n\n  // This only works with objects added to objects!\n  public addParameters(parameters: Parameters): void {\n    if (this.parametersType === 'none') {\n      return this.set(parameters);\n    }\n    if (this.parametersType !== 'object') {\n      throw new Error('Can\\'t add object parameters to existing non-object parameters!');\n    }\n    this.set({ ...this.parametersRecord, ...parameters });\n  }\n\n  public toSpecifiedParameters(context: IRouterConfiguration | IRouter | IContainer, specifications: string[] | null | undefined): Record<string, unknown> {\n    specifications = specifications ?? [];\n    const parameters = this.parameters(context);\n\n    const specified: Record<string, unknown> = {};\n    for (const spec of specifications) {\n      // First get named if it exists\n      let index = parameters.findIndex(param => param.key === spec);\n      if (index >= 0) {\n        const [parameter] = parameters.splice(index, 1);\n        specified[spec] = parameter.value;\n      } else {\n        // Otherwise get first unnamed\n        index = parameters.findIndex(param => param.key === void 0);\n        if (index >= 0) {\n          const [parameter] = parameters.splice(index, 1);\n          specified[spec] = parameter.value;\n        }\n      }\n    }\n    // Add all remaining named\n    for (const parameter of parameters.filter(param => param.key !== void 0)) {\n      specified[parameter.key!] = parameter.value;\n    }\n    let index = specifications.length;\n    // Add all remaining unnamed...\n    for (const parameter of parameters.filter(param => param.key === void 0)) {\n      // ..with an index\n      specified[index++] = parameter.value;\n    }\n    return specified;\n  }\n\n  public toSortedParameters(context: IRouterConfiguration | IRouter | IContainer, specifications?: string[] | null | undefined): IComponentParameter[] {\n    specifications = specifications || [];\n    const parameters = this.parameters(context);\n\n    const sorted: IComponentParameter[] = [];\n    for (const spec of specifications) {\n      // First get named if it exists\n      let index = parameters.findIndex(param => param.key === spec);\n      if (index >= 0) {\n        const parameter = { ...parameters.splice(index, 1)[0] };\n        parameter.key = void 0;\n        sorted.push(parameter);\n      } else {\n        // Otherwise get first unnamed\n        index = parameters.findIndex(param => param.key === void 0);\n        if (index >= 0) {\n          const parameter = { ...parameters.splice(index, 1)[0] };\n          sorted.push(parameter);\n        } else {\n          // Or an empty\n          sorted.push({ value: void 0 });\n        }\n      }\n    }\n    // Add all remaining named\n    const params = parameters.filter(param => param.key !== void 0);\n    params.sort((a, b) => (a.key || '') < (b.key || '') ? 1 : (b.key || '') < (a.key || '') ? -1 : 0);\n    sorted.push(...params);\n    // Add all remaining unnamed...\n    sorted.push(...parameters.filter(param => param.key === void 0));\n\n    return sorted;\n  }\n\n  // TODO: Somewhere we need to check for format such as spaces etc\n  public same(context: IRouterConfiguration | IRouter | IContainer, other: InstructionParameters, componentType: RouteableComponentType | null): boolean {\n    const typeParameters = componentType !== null ? componentType.parameters : [];\n    const mine = this.toSpecifiedParameters(context, typeParameters);\n    const others = other.toSpecifiedParameters(context, typeParameters);\n\n    return Object.keys(mine).every(key => mine[key] === others[key])\n      && Object.keys(others).every(key => others[key] === mine[key]);\n  }\n}\n", "import { Constructable, IContainer, onResolve, Writable } from '@aurelia/kernel';\nimport { Controller, CustomElement, CustomElementDefinition, IHydratedController, isCustomElementViewModel } from '@aurelia/runtime-html';\nimport { IRouteableComponent, RouteableComponentType } from '../interfaces';\nimport { RoutingInstruction } from './routing-instruction';\n\nexport interface IInstructionComponent extends InstructionComponent { }\n\n/**\n * Public API - The routing instructions are the core of the router's navigations. The component\n * part of a routing instruction can be specified as\n * - a component name, or\n * - a custom element definition, or\n * - a custom element class, or\n * - a custom element instance.\n *\n * The instruction component isn't limited to routing instructions, but can be found in for example load instructions as well.\n * The instruction components are resolved \"non-early\" to support dynamic, local resolutions.\n */\n\n/** */\nexport type ComponentAppellation = string | RouteableComponentType | IRouteableComponent | CustomElementDefinition | Constructable;\nexport type ComponentAppellationFunction = (instruction?: RoutingInstruction) => ComponentAppellation | Promise<ComponentAppellation>;\n\nexport class InstructionComponent {\n  /**\n   * The name of the component.\n   */\n  public name: string | null = null;\n\n  /**\n   * The (custom element) type of the component.\n   */\n  public type: RouteableComponentType | null = null;\n\n  /**\n   * The (custom element) instance of the component.\n   */\n  public instance: IRouteableComponent | null = null;\n\n  /**\n   * A promise that will resolve into a component name, type,\n   * instance or definition.\n   */\n  public promise: Promise<ComponentAppellation> | null = null;\n\n  /**\n   * A function that should result in a component name, type,\n   * instance, definition or promise to any of these at the time\n   * of route invocation.\n   */\n  public func: ComponentAppellationFunction | null = null;\n\n  /**\n   * Create a new instruction component.\n   *\n   * @param component - The component\n   */\n  public static create(componentAppelation?: ComponentAppellation | Promise<ComponentAppellation>): InstructionComponent {\n    const component = new InstructionComponent();\n    component.set(componentAppelation);\n    return component;\n  }\n\n  public static isName(component: ComponentAppellation): component is string {\n    return typeof component === 'string';\n  }\n  public static isDefinition(component: ComponentAppellation): component is CustomElementDefinition {\n    return CustomElement.isType((component as CustomElementDefinition).Type);\n  }\n  public static isType(component: ComponentAppellation): component is RouteableComponentType {\n    return CustomElement.isType(component);\n  }\n  public static isInstance(component: ComponentAppellation): component is IRouteableComponent {\n    return isCustomElementViewModel(component);\n  }\n  public static isAppelation(component: ComponentAppellation): component is ComponentAppellation {\n    return InstructionComponent.isName(component)\n      || InstructionComponent.isType(component)\n      || InstructionComponent.isInstance(component);\n  }\n\n  public static getName(component: ComponentAppellation): string {\n    if (InstructionComponent.isName(component)) {\n      return component;\n    } else if (InstructionComponent.isType(component)) {\n      return CustomElement.getDefinition(component).name;\n    } else {\n      return InstructionComponent.getName(component.constructor as Constructable);\n    }\n  }\n  public static getType(component: ComponentAppellation): RouteableComponentType | null {\n    if (InstructionComponent.isName(component)) {\n      return null;\n    } else if (InstructionComponent.isType(component)) {\n      return component;\n    } else {\n      return ((component as IRouteableComponent).constructor as RouteableComponentType);\n    }\n  }\n  public static getInstance(component: ComponentAppellation): IRouteableComponent | null {\n    if (InstructionComponent.isName(component) || InstructionComponent.isType(component)) {\n      return null;\n    } else {\n      return component as IRouteableComponent;\n    }\n  }\n\n  // Instance methods\n  public set(component: ComponentAppellation | Promise<ComponentAppellation> | undefined | null): void {\n    let name: string | null = null;\n    let type: RouteableComponentType | null = null;\n    let instance: IRouteableComponent | null = null;\n    let promise: Promise<ComponentAppellation> | null = null;\n    let func: ComponentAppellationFunction | null = null;\n    if (component instanceof Promise) {\n      promise = component;\n    } else if (InstructionComponent.isName(component!)) {\n      name = InstructionComponent.getName(component);\n    } else if (InstructionComponent.isType(component!)) {\n      name = this.getNewName(component);\n      type = InstructionComponent.getType(component);\n    } else if (InstructionComponent.isInstance(component!)) {\n      name = this.getNewName(InstructionComponent.getType(component)!);\n      type = InstructionComponent.getType(component);\n      instance = InstructionComponent.getInstance(component);\n    } else if (typeof component === 'function') {\n      func = component as unknown as ComponentAppellationFunction;\n    }\n\n    this.name = name;\n    this.type = type;\n    this.instance = instance;\n    this.promise = promise;\n    this.func = func;\n  }\n\n  public resolve(instruction: RoutingInstruction): void | Promise<ComponentAppellation> {\n    if (this.func !== null) {\n      this.set(this.func(instruction));\n    }\n    if (!(this.promise instanceof Promise)) {\n      return;\n    }\n\n    return this.promise.then((component: ComponentAppellation): void => {\n      // TODO(alpha): Fix the issues with import/module here\n      if (InstructionComponent.isAppelation(component)) {\n        this.set(component);\n        return;\n      }\n      if ((component as unknown as { default: ComponentAppellation }).default != null) {\n        this.set((component as unknown as { default: ComponentAppellation }).default);\n        return;\n      }\n      const keys = Object.keys(component).filter(key => !key.startsWith('__'));\n      if (keys.length === 0) {\n        throw new Error(`Failed to load component Type from resolved Promise since no export was specified.`);\n      }\n      if (keys.length > 1) {\n        throw new Error(`Failed to load component Type from resolved Promise since no 'default' export was specified when having multiple exports.`);\n      }\n      const key = keys[0];\n      // TODO(alpha): Fix type here\n      // eslint-disable-next-line\n      this.set((component as any)[key] as ComponentAppellation);\n    }) as Promise<ComponentAppellation>;\n  }\n\n  public get none(): boolean {\n    return !this.isName() && !this.isType() && !this.isInstance() && !this.isFunction() && !this.isPromise();\n  }\n  public isName(): boolean {\n    return this.name != null && this.name !== '' && !this.isType() && !this.isInstance();\n  }\n  public isType(): boolean {\n    return this.type !== null && !this.isInstance();\n  }\n  public isInstance(): boolean {\n    return this.instance !== null;\n  }\n  public isPromise(): boolean {\n    return this.promise !== null;\n  }\n  public isFunction(): boolean {\n    return this.func !== null;\n  }\n\n  public toType(container: IContainer, instruction: RoutingInstruction): RouteableComponentType | null {\n    // TODO: Allow instantiation from a promise here, by awaiting resolve (?)\n    void this.resolve(instruction);\n\n    if (this.type !== null) {\n      return this.type;\n    }\n    if (this.name !== null\n      && typeof this.name === 'string') {\n      if (container === null) {\n        throw new Error(`No container available when trying to resolve component '${this.name}'!`);\n      }\n      if (container.has<RouteableComponentType>(CustomElement.keyFrom(this.name), true)) {\n        const resolver = container.getResolver<RouteableComponentType>(CustomElement.keyFrom(this.name));\n        if (resolver !== null && resolver.getFactory !== void 0) {\n          const factory = resolver.getFactory(container);\n          if (factory) {\n            return factory.Type;\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns the component instance of this instruction.\n   *\n   * Throws instantiation error if there was an error during instantiation.\n   */\n  public toInstance(parentContainer: IContainer, parentController: IHydratedController, parentElement: HTMLElement, instruction: RoutingInstruction): IRouteableComponent | null | Promise<IRouteableComponent | null> {\n    return onResolve(this.resolve(instruction) as IRouteableComponent, () => {\n      if (this.instance !== null) {\n        return this.instance;\n      }\n      if (parentContainer == null) {\n        return null;\n      }\n\n      return this._createInstance(parentContainer, parentController, parentElement, instruction);\n    });\n  }\n\n  public same(other: InstructionComponent, compareType: boolean = false): boolean {\n    return compareType ? this.type === other.type : this.name === other.name;\n  }\n\n  private getNewName(type: RouteableComponentType): string {\n    if (this.name === null) {\n      return InstructionComponent.getName(type);\n    }\n    return this.name;\n  }\n\n  /** @internal */\n  /**\n   * Creates the component instance for this instruction.\n   *\n   * Throws instantiation error if there was an error during instantiation.\n   */\n  private _createInstance(parentContainer: IContainer, parentController: IHydratedController, parentElement: HTMLElement, instruction: RoutingInstruction): IRouteableComponent | null {\n    const container = parentContainer.createChild();\n    const Type = this.isType()\n      ? this.type!\n      : container.getResolver<RouteableComponentType>(CustomElement.keyFrom(this.name!))!.getFactory!(container)!.Type;\n    const instance = container.invoke(Type);\n    // TODO: Investigate this!\n    // const instance: IRouteableComponent = this.isType()\n    //   ? container.invoke(this.type!)\n    //   : container.get(routerComponentResolver(this.name!));\n\n    // TODO: Implement non-traversing lookup (below) based on router configuration\n    // let instance;\n    // if (this.isType()) {\n    //   instance = ownContainer.invoke(this.type!);\n    // } else {\n    //   const def = CustomElement.find(ownContainer, this.name!);\n    //   if (def != null) {\n    //     instance = ownContainer.invoke(def.Type);\n    //   }\n    // }\n    if (instance == null) {\n      if (__DEV__) {\n        // eslint-disable-next-line no-console\n        console.warn('Failed to create instance when trying to resolve component', this.name, this.type, '=>', instance);\n      }\n      throw new Error(`Failed to create instance when trying to resolve component '${this.name}'!`);\n    }\n    const controller = Controller.$el(\n      container,\n      instance,\n      parentElement,\n      null,\n    );\n    // TODO: Investigate if this is really necessary\n    (controller as Writable<typeof controller>).parent = parentController;\n\n    return instance;\n  }\n}\n\n// TODO: Investigate this (should possibly be added back)\n// function routerComponentResolver(name: string): IResolver<IRouteableComponent> {\n//   const key = CustomElement.keyFrom(name);\n//   return {\n//     $isResolver: true,\n//     resolve(_, requestor) {\n//       // const container = requestor.get(IHydrationContext).parent!.controller.container;\n//       if (requestor.has(key, false)) {\n//         return requestor.get(key);\n//       }\n//       if (requestor.root.has(key, false)) {\n//         return requestor.root.get(key);\n//       }\n//       // it's not always correct to consider this resolution as a traversal\n//       // since sometimes it could be the work of trying a fallback configuration as component\n//       // todo: cleanup the paths so that it's clearer when a fallback is being tried vs when an actual component name configuration\n//       //\n//       // console.warn(`Detected resource traversal behavior. A custom element \"${name}\" is neither`\n//       //   + ` registered locally nor globally. This is not a supported behavior and will be removed in a future release`);\n//       return requestor.get(key);\n//     }\n//   };\n// }\n", "/**\n *\n * NOTE: This file is still WIP and will go through at least one more iteration of refactoring, commenting and clean up!\n * In its current state, it is NOT a good source for learning about the inner workings and design of the router.\n *\n */\n/**\n * Shouldn't be used directly\n *\n * @internal\n */\nexport function arrayRemove<T>(arr: T[], func: (value: T, index?: number, obj?: T[]) => boolean): T[] {\n  const removed: T[] = [];\n  let arrIndex = arr.findIndex(func);\n  while (arrIndex >= 0) {\n    removed.push(arr.splice(arrIndex, 1)[0]);\n    arrIndex = arr.findIndex(func);\n  }\n  return removed;\n}\n\n/**\n * @internal\n */\nexport function arrayAddUnique<T>(arr: T[], values: T | T[]): T[] {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n  for (const value of values) {\n    if (!arr.includes(value)) {\n      arr.push(value);\n    }\n  }\n  return arr;\n}\n\n/**\n * @internal\n */\nexport function arrayUnique<T>(arr: T[], includeNullish = false): T[] {\n  return arr.filter((item, i, arrAgain) => (includeNullish || item != null) && arrAgain.indexOf(item) === i);\n}\n\n/**\n * @internal\n */\nexport function resolvePossiblePromise<T = unknown>(value: T | Promise<T>, callback?: (value: T) => T): T | Promise<T> {\n  // If we've got a Promise, wait for it's resolve\n  if (value instanceof Promise) {\n    return value.then((resolvedValue) => {\n      // console.log('then', 'resolvePossiblePromise');\n      if (callback !== void 0) {\n        callback(resolvedValue);\n      }\n      return resolvedValue;\n    });\n  }\n  if (callback !== void 0) {\n    callback(value);\n  }\n  return value;\n}\n\n/** @internal */\nexport function deprecationWarning(oldFeature: string, newFeature: string) {\n  // eslint-disable-next-line no-console\n  console.warn(`[Deprecated] The ${oldFeature} has been deprecated. Please use the ${newFeature} instead.`);\n}\n\n/** @internal */\nexport function tryStringify(value: unknown): string {\n  try {\n    return JSON.stringify(value);\n  } catch {\n    return Object.prototype.toString.call(value);\n  }\n}\n", "/**\n * The OpenPromise provides an open API to a promise.\n */\nexport class OpenPromise<T = void> {\n  /**\n   * Whether the promise is still pending (not settled)\n   */\n  public isPending: boolean = true;\n\n  /**\n   * The actual promise\n   */\n  public promise: Promise<T>;\n\n  /**\n   * The resolve method of the promise\n   * @internal\n   */\n  private _resolve!: (value?: T | PromiseLike<T>) => void;\n\n  /**\n   * The reject method of the promise\n   * @internal\n   */\n  private _reject!: (reason?: unknown) => void;\n\n  public static promises: OpenPromise<any>[] = [];\n\n  public constructor(public readonly description: string = '') {\n    this.promise = new Promise((resolve, reject) => {\n      this._resolve = resolve as (value?: T | PromiseLike<T>) => void;\n      this._reject = reject;\n      OpenPromise.promises.push(this);\n    });\n  }\n\n  /**\n   * Resolve the (open) promise.\n   *\n   * @param value - The value to resolve with\n   */\n  public resolve(value?: T | PromiseLike<T>): void {\n    this._resolve(value);\n    this.isPending = false;\n    OpenPromise.promises = OpenPromise.promises.filter((promise) => promise !== this);\n  }\n\n  /**\n   * Reject the (open) promise.\n   *\n   * @param reason - The reason the promise is rejected\n   */\n  public reject(reason?: unknown): void {\n    this._reject(reason);\n    this.isPending = false;\n    OpenPromise.promises = OpenPromise.promises.filter((promise) => promise !== this);\n  }\n}\n", "import { OpenPromise } from './open-promise';\n\n/**\n * Class for running a sequence of steps with values,\n * functions and promises. Stays sync if possible.\n *\n * Usage:\n *\n * ```ts\n * const promise = Runner.run(null,\n *   'one',\n *   step => `${step.previousValue}, two`,\n *   step => createPromise(step.previousValue), // creates a promise that resolves to `${value}, three`\n * );\n *\n * // Run can be cancelled with Runner.cancel(promise);\n *\n * const stepsRunner = Runner.runner(promise);\n * const result = await promise;\n * if (stepsRunner?.isResolved) { // Make sure promise wasn't rejected\n *   // result === 'one, two, three'\n * }\n * ```\n */\nexport class Runner {\n  public value: unknown;\n  public isDone: boolean = false;\n  public isCancelled: boolean = false;\n  public isResolved: boolean = false;\n  public isRejected: boolean = false;\n  public isAsync: boolean = false;\n\n  private static readonly runners: WeakMap<Promise<unknown>, Step> = new WeakMap();\n\n  /**\n   * Runs a set of steps and retuns the last value\n   *\n   * Steps are processed in sequence and can be either a\n   *\n   * - value - which is then propagated as input into the next step\n   * - function - which is executed in time. The result is replacing the step which is then reprocessed\n   * - promise - which is awaited\n   *\n   * ```ts\n   * result = await Runner.run(null,\n   *   'one',\n   *   step => `${step.previousValue}, two`,\n   *   step => createPromise(step.previousValue), // creates a promise that resolves to `${value}, three`\n   * ); // result === 'one, two, three'\n   * ```\n   *\n   * Returns the result as a promise or a value.\n   *\n   * If first parameter is an existing Step, the additional steps will be added to run after it. In this\n   * case, the return value will be the first new step and not the result (since it doesn't exist yet).\n   */\n  public static run<T = unknown>(predecessor: Step<T> | null | string, ...steps: unknown[]): T | Promise<T> | Step<T> {\n    if (steps.length === 0) {\n      return void 0 as T;\n    }\n\n    let newRoot = false;\n    // No predecessor, so create a new root and add steps as children to it\n    if (predecessor === null || typeof predecessor === 'string') {\n      predecessor = new Step<T>(predecessor);\n      newRoot = true;\n    }\n\n    // First new step\n    const start = new Step<T>(steps.shift());\n    // If the predecessor is new root or parallel the start needs to be a child of the predecessor\n    Runner.connect(predecessor, start, (predecessor?.runParallel ?? false) || newRoot);\n\n    if (steps.length > 0) {\n      Runner.add(start, false, ...steps);\n    }\n\n    // If we've added a new root, run and return the result\n    if (newRoot) {\n      Runner.process(predecessor);\n\n      if (predecessor.result instanceof Promise) {\n        this.runners.set(predecessor.result, predecessor as Step);\n      }\n      return predecessor.result as T | Promise<T>;\n    }\n\n    return start;\n  }\n\n  /**\n   * Runs a set of steps and retuns a list with their results\n   *\n   * Steps are processed in parallel and can be either a\n   *\n   * - value - which is then propagated as input into the next step\n   * - function - which is executed in time. The result is replacing the step which is then reprocessed\n   * - promise - which is awaited\n   *\n   * ```ts\n   * result = await Runner.runParallel(null,\n   *   'one',\n   *   step => `${step.previousValue}, two`,\n   *   step => createPromise(step.previousValue), // creates a promise that resolves to `${value}, three`\n   * ); // result === ['one', 'one, two', 'one, two, three']\n   * ```\n   *\n   * Returns the result as a promise or a list of values.\n   *\n   * If first parameter is an existing Step, the additional steps will be added to run after it. In this\n   * case, the return value will be the first new step and not the result (since it doesn't exist yet).\n   */\n  public static runParallel<T = unknown>(parent: Step<T> | null, ...steps: unknown[]): T[] | Promise<T[]> | Step<T> {\n    if ((steps?.length ?? 0) === 0) {\n      return [];\n    }\n\n    let newRoot = false;\n    // No parent, so parallel from a new root\n    if (parent === null) {\n      parent = new Step<T>();\n      newRoot = true;\n    } else { // Need to inject a step under the parent to put the parallel steps under\n      parent = Runner.connect(parent, new Step<T>(), true);\n    }\n\n    Runner.add(parent, true, ...steps);\n\n    if (newRoot) {\n      Runner.process(parent);\n    }\n\n    if (parent.result instanceof Promise) {\n      this.runners.set(parent.result, parent as Step);\n    }\n\n    return newRoot ? (parent.result ?? []) as T[] | Promise<T[]> : parent;\n  }\n\n  /**\n   * Gets the starting step for a promise returned by Runner.run\n   *\n   * The step can be used to check status and outcome of\n   * the run as well as cancel it\n   *\n   */\n  public static step(value: unknown): Step | undefined {\n    if (value instanceof Promise) {\n      return Runner.runners.get(value);\n    }\n  }\n\n  /**\n   * Cancels the remaining steps for a step or promise returned by Runner.run\n   *\n   * Once a starting step has been cancelled, it's no longer possible\n   * to retrieve it from the promise\n   *\n   */\n  public static cancel(value: unknown): void {\n    const step = Runner.step(value);\n    if (step !== void 0) {\n      step.cancel();\n    }\n  }\n\n  private static add<T = unknown>(predecessorOrParent: Step<T> | null, parallel: boolean, ...steps: unknown[]): Step<T> {\n    let step = new Step<T>(steps.shift(), parallel);\n\n    // Connect to predecessor or parent if there is one\n    if (predecessorOrParent !== null) {\n      // Connect first step either after or below depending on parallel\n      step = Runner.connect(predecessorOrParent, step, parallel);\n    }\n    const start = step;\n\n    while (steps.length > 0) {\n      // Connect subsequent steps after\n      step = Runner.connect(step, new Step<T>(steps.shift(), parallel), false);\n    }\n    return start;\n  }\n\n  private static connect<T = unknown>(predecessorOrParent: Step<T>, step: Step<T>, asChild: boolean): Step<T> {\n    if (!asChild) {\n      // Can have a pre-existing next\n      const next = predecessorOrParent.next;\n      predecessorOrParent.next = step;\n      step.previous = predecessorOrParent;\n      step.next = next;\n\n      if (next !== null) {\n        next.previous = step;\n        next.parent = null;\n      }\n    } else {\n      // Shouldn't really have a pre-existing child, but just to be sure\n      const child = predecessorOrParent.child;\n      predecessorOrParent.child = step;\n      step.parent = predecessorOrParent;\n      step.next = child;\n\n      if (child !== null) {\n        child.parent = null;\n        child.previous = step;\n      }\n    }\n    return step;\n  }\n\n  public static roots: Record<string, Step> = {};\n  // Always set and resolve root OpenPromise as soon as there's a promise somewhere\n  // Subsequent calls work on the origin promise(s)\n  // root is the top root of the connected steps\n  // step.promise holds promise that resolves\n  // step.value holds value that's resolved\n  public static process<T = unknown>(step: Step<T> | null): void {\n    const root = step!.root;\n    while (step !== null && !step.isDoing && !step.isDone) {\n      root.current = step;\n      if (step.isParallelParent) {\n        step.isDone = true;\n\n        let child = step.child;\n        while (child !== null) {\n          Runner.process(child);\n          child = child.next;\n        }\n      } else {\n        step.isDoing = true;\n        step.value = step.step as T | Promise<T> | ((s?: Step) => T | Promise<T>);\n        // Iteratively resolve Functions (until value or Promise)\n        // Called method can stop iteration by setting isDone on the step\n        while (step.value instanceof Function && !step.isCancelled && !step.isExited && !step.isDone) {\n          step.value = (step.value)(step as Step);\n        }\n\n        if (!step.isCancelled) {\n          // If we've got a Promise, run the remaining\n          if (step.value instanceof Promise) {\n            // Store promise since propagateResult can change it for OpenPromise\n            const promise = step.value;\n\n            Runner.ensurePromise<T>(root);\n            // TODO: Possibly also ensure promise in origin\n\n            (($step: Step<T>, $promise) => {\n              $promise.then(result => {\n                $step.value = result;\n                // Only if there's a \"public\" promise to resolve\n                Runner.settlePromise($step);\n\n                $step.isDone = true;\n                $step.isDoing = false;\n\n                const next = $step.nextToDo();\n                if (next !== null && !$step.isExited) {\n                  Runner.process(next);\n                } else {\n                  if ($step.root.doneAll || $step.isExited) {\n                    Runner.settlePromise($step.root);\n                  }\n                }\n              }).catch(err => { throw err; });\n            })(step, promise);\n          } else {\n            step.isDone = true;\n            step.isDoing = false;\n\n            if (!step.isExited) {\n              step = step.nextToDo();\n            } else {\n              step = null;\n            }\n          }\n        }\n      }\n    }\n\n    // Keep this, good for debugging unresolved steps\n    // Runner.roots[root.id] = root.doneAll ? true : root.step;\n    // console.log(root.doneAll, root.report, Runner.roots);\n    // console.log(root.doneAll, root.report);\n\n    if (root.isCancelled) {\n      Runner.settlePromise(root, 'reject');\n    } else if (root.doneAll || root.isExited) {\n      Runner.settlePromise(root);\n    }\n  }\n\n  private static ensurePromise<T = unknown>(step: Step<T>): boolean {\n    if (step.finally === null) {\n      step.finally = new OpenPromise(`Runner: ${step.name}, ${step.previousValue}, ${step.value}, ${step.root.report}`);\n      step.promise = step.finally.promise;\n      return true;\n    }\n    return false;\n  }\n\n  private static settlePromise<T = unknown>(step: Step<T>, outcome: 'resolve' | 'reject' = 'resolve'): void {\n    if (step.finally?.isPending ?? false) {\n      step.promise = null;\n      // TODO: Should it also iteratively resolve functions and promises?\n      switch (outcome) {\n        case 'resolve':\n          step.finally?.resolve(step.result as T | T[] | Promise<T | T[]>);\n          break;\n        case 'reject':\n          step.finally?.reject(step.result as T | T[] | Promise<T | T[]>);\n          break;\n      }\n    }\n  }\n}\n\nexport class Step<T = unknown> {\n  public static id: number = 0;\n\n  public value?: T | Promise<T> | ((step?: Step) => T | Promise<T>);\n  public promise: Promise<T | T[]> | null = null;\n\n  public previous: Step<T> | null = null;\n  public next: Step<T> | null = null;\n  public parent: Step<T> | null = null;\n  public child: Step<T> | null = null;\n  public current: Step<T> | null = null;\n  public finally: OpenPromise<T | T[]> | null = null;\n\n  public isDoing: boolean = false;\n  public isDone: boolean = false;\n  public isCancelled: boolean = false;\n  public isExited: boolean = false;\n  public exited: Step<T> | null = null;\n\n  public id: string = '-1';\n  public constructor(\n    public step: unknown = void 0,\n    public runParallel: boolean = false,\n  ) {\n    this.id = `${Step.id++}`;\n    if (typeof step === 'string') {\n      this.id += ` ${step}`;\n    }\n  }\n\n  public get isParallelParent(): boolean {\n    return this.child?.runParallel ?? false;\n  }\n\n  public get result(): T | T[] | Promise<T | T[]> | void {\n    // TODO: Possibly check done and create a promise if necessary\n\n    // If we've got a promise, we're not done so return the promise\n    if (this.promise !== null) {\n      return this.promise;\n    }\n\n    // Parents (including root) return the results of their children\n    if (this.child !== null) {\n      // If it's a parallel parent, return all child results...\n      if (this.isParallelParent) {\n        const results: T[] = [];\n        let child: Step<T> | null = this.child;\n        while (child !== null) {\n          results.push(child.result as T);\n          child = child.next;\n        }\n        return results;\n      } else { // ...otherwise return the one that exited/the last one.\n        return this === this.root && this.exited !== null ? this.exited.result : this.child?.tail?.result;\n      }\n    }\n\n    // If none of the above, return the value\n    let value = this.value as T;\n    while (value instanceof Step) {\n      value = value.result as T;\n    }\n    return value;\n  }\n\n  public get asValue(): T | T[] | Promise<T | T[]> | void {\n    // TODO: This should check done and create a promise if necessary\n    return this.result;\n  }\n\n  public get previousValue(): unknown {\n    return this.runParallel\n      ? this.head.parent?.parent?.previous?.result\n      : this.previous?.result;\n  }\n\n  public get name(): string {\n    let name = `${this.id}`;\n    if (this.runParallel) {\n      name = `:${name}`;\n    }\n    if (this.value instanceof Promise || this.promise instanceof Promise) {\n      name = `${name}*`;\n    }\n    if (this.finally !== null) {\n      name = `${name}*`;\n    }\n    if (this.child !== null) {\n      name = `${name}>`;\n    }\n    if (this.isDone) {\n      name = `(${name})`;\n    }\n    return name;\n  }\n\n  public get root(): Step<T> {\n    let root = this.head;\n    while (root.parent !== null) {\n      root = root.parent.head;\n    }\n    return root;\n  }\n  public get head(): Step<T> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let step: Step<T> = this;\n    while (step.previous !== null) {\n      step = step.previous;\n    }\n    return step;\n  }\n  public get tail(): Step<T> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let step: Step<T> = this;\n    while (step.next !== null) {\n      step = step.next;\n    }\n    return step;\n  }\n\n  public get done(): boolean {\n    if (!this.isDone) {\n      return false;\n    }\n    let step: Step<T> | null = this.child;\n    while (step !== null) {\n      if (!step.done) {\n        return false;\n      }\n      step = step.next;\n    }\n    return true;\n  }\n\n  public get doneAll(): boolean {\n    if (!this.isDone\n      || ((this.child !== null) && !this.child.doneAll)\n      || ((this.next !== null) && !this.next.doneAll)\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  public cancel(all = true): boolean {\n    if (all) {\n      return this.root.cancel(false);\n    }\n    if (this.isCancelled) {\n      return false;\n    }\n    this.isCancelled = true;\n    this.child?.cancel(false);\n    this.next?.cancel(false);\n    return true;\n  }\n\n  public exit(all = true): boolean {\n    if (all) {\n      this.root.exited = this;\n      return this.root.exit(false);\n    }\n    if (this.isExited) {\n      return false;\n    }\n    this.isExited = true;\n    this.child?.exit(false);\n    this.next?.exit(false);\n    return true;\n  }\n\n  public nextToDo(): Step<T> | null {\n    // First step into if possible\n    if (this.child !== null && !this.child.isDoing && !this.child.isDone) {\n      return this.child;\n    }\n    // Parallels can only continue if they are the last one finished\n    if (this.runParallel && !this.head.parent!.done) {\n      return null;\n    }\n    return this.nextOrUp();\n  }\n  private nextOrUp(): Step<T> | null {\n    // Take next if possible\n    let next: Step<T> | null = this.next;\n    while (next !== null) {\n      if (!next.isDoing && !next.isDone) {\n        return next;\n      }\n      next = next.next;\n    }\n\n    // Need to back out/up\n    const parent = this.head.parent ?? null;\n    if (parent === null || !parent.done) {\n      return null;\n    }\n    // And try again from parent\n    return parent.nextOrUp();\n  }\n\n  // Method is purely for debugging\n  public get path(): string {\n    return `${this.head.parent?.path ?? ''}/${this.name}`;\n  }\n\n  // Method is purely for debugging\n  public get tree(): string {\n    let result = '';\n    let step: Step<T> | null = this.head;\n    let parent: Step<T> | null = step.parent;\n    let path = '';\n    while (parent !== null) {\n      path = `${parent.path}${path}`;\n      parent = parent.head.parent;\n    }\n    do {\n      result += `${path}/${step.name}\\n`;\n      if (step === this) {\n        break;\n      }\n      step = step.next;\n    } while (step !== null);\n    return result;\n  }\n\n  // Method is purely for debugging\n  public get report(): string {\n    let result = `${this.path}\\n`;\n    result += this.child?.report ?? '';\n    result += this.next?.report ?? '';\n    return result;\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable prefer-template */\n\n/** @internal */\nexport const createMappedError: CreateError = __DEV__\n  ? (code: ErrorNames, ...details: unknown[]) => new Error(`AUR${String(code).padStart(4, '0')}: ${getMessageByCode(code, ...details)}`)\n  : (code: ErrorNames, ...details: unknown[]) => new Error(`AUR${String(code).padStart(4, '0')}:${details.map(String)}`);\n\n_START_CONST_ENUM();\n/** @internal */\nexport const enum ErrorNames {\n  method_not_implemented = 99,\n\n  router_started = 2000,\n  router_not_started,\n  router_remove_endpoint_failure,\n  router_check_activate_string_error,\n  router_failed_appending_routing_instructions,\n  router_failed_finding_viewport_when_updating_viewer_path,\n  router_infinite_instruction,\n\n  browser_viewer_store_already_started,\n  browser_viewer_store_not_started,\n  browser_viewer_store_state_serialization_failed,\n\n  navigator_already_started,\n  navigator_not_started,\n\n  route_no_component_as_config,\n  route_no_both_component_and_instructions,\n  route_nullish_config,\n  route_instructions_existed,\n  route_invalid_config,\n\n  endpoint_instantiation_error,\n  element_name_not_found,\n  router_error_3,\n  router_error_4,\n  router_error_5,\n  router_error_6,\n  router_error_7,\n  router_error_8,\n  router_error_9,\n  router_error_10,\n}\n_END_CONST_ENUM();\n\nconst errorsMap: Record<ErrorNames, string>  = {\n  [ErrorNames.method_not_implemented]: 'Method {{0}} not implemented',\n\n  [ErrorNames.router_started]: `Router.start() called while the it has already been started.`,\n  [ErrorNames.router_not_started]: 'Router.stop() has been called while it has not been started',\n  [ErrorNames.router_remove_endpoint_failure]: \"Router failed to remove endpoint: {{0}}\",\n  [ErrorNames.router_check_activate_string_error]: `Parameter instructions to checkActivate can not be a string ('{{0}}')!`,\n  [ErrorNames.router_failed_appending_routing_instructions]: 'Router failed to append routing instructions to coordinator',\n  [ErrorNames.router_failed_finding_viewport_when_updating_viewer_path]: 'Router failed to find viewport when updating viewer paths.',\n  [ErrorNames.router_infinite_instruction]: `{{0}} remaining instructions after 100 iterations; there is likely an infinite loop.`,\n\n  [ErrorNames.browser_viewer_store_already_started]: 'Browser navigation has already been started',\n  [ErrorNames.browser_viewer_store_not_started]: 'Browser navigation has not been started',\n  [ErrorNames.browser_viewer_store_state_serialization_failed]: `Failed to \"{{0}}\" state, probably due to unserializable data and/or parameters:` +\n    `\\nSerialization error: {{1}}`+\n    `\\nOriginal error: {originalError}`,\n\n  [ErrorNames.navigator_already_started]: 'Navigator has already been started',\n  [ErrorNames.navigator_not_started]: 'Navigator has not been started',\n\n  [ErrorNames.route_no_component_as_config]: `Invalid route configuration: A component ` +\n    `can't be specified in a component route configuration.`,\n  [ErrorNames.route_no_both_component_and_instructions]: `Invalid route configuration: The 'component' and 'instructions' properties ` +\n    `can't be specified in a component route configuration.`,\n  [ErrorNames.route_nullish_config]: `Invalid route configuration: expected an object but got null/undefined.`,\n  [ErrorNames.route_instructions_existed]: `Invalid route configuration: the 'instructions' property can't be used together with ` +\n    `the 'component', 'viewport', 'parameters' or 'children' properties.`,\n  [ErrorNames.route_invalid_config]: `Invalid route configuration: either 'redirectTo' or 'instructions' need to be specified.`,\n\n  [ErrorNames.endpoint_instantiation_error]: `There was an error durating the instantiation of \"{{0}}\".`\n    + ` \"{{0}}\" did not match any configured route or registered component name`\n    + ` - did you forget to add the component \"{{0}}\" to the dependencies or to register it as a global dependency?\\n`\n    + `{{1:innerError}}`,\n  [ErrorNames.element_name_not_found]: `Cannot find an element with the name \"{{0}}\", did you register it via \"dependencies\" option or <import> with convention?.\\n`,\n  [ErrorNames.router_error_3]: `-- placeholder --`,\n  [ErrorNames.router_error_4]: `-- placeholder --`,\n  [ErrorNames.router_error_5]: `-- placeholder --`,\n  [ErrorNames.router_error_6]: `-- placeholder --`,\n  [ErrorNames.router_error_7]: `-- placeholder --`,\n  [ErrorNames.router_error_8]: `-- placeholder --`,\n  [ErrorNames.router_error_9]: `-- placeholder --`,\n  [ErrorNames.router_error_10]: `-- placeholder --`,\n};\n\nconst getMessageByCode = (name: ErrorNames, ...details: unknown[]) => {\n  let cooked: string = errorsMap[name];\n  for (let i = 0; i < details.length; ++i) {\n    const regex = new RegExp(`{{${i}(:.*)?}}`, 'g');\n    let matches = regex.exec(cooked);\n    while (matches != null) {\n      const method = matches[1]?.slice(1);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let value = details[i] as any;\n      if (value != null) {\n        switch (method) {\n          case 'nodeName': value = (value as Node).nodeName.toLowerCase(); break;\n          case 'name': value = (value as { name: string }).name; break;\n          case 'typeof': value = typeof value; break;\n          case 'ctor': value = (value as object).constructor.name; break;\n          case 'toString': value = Object.prototype.toString.call(value); break;\n          case 'join(!=)': value = (value as unknown[]).join('!='); break;\n          case 'element': value = value === '*' ? 'all elements' : `<${value} />`; break;\n          case 'innerError':\n            value = `\\nDetails:\\n${value}\\n${(value instanceof Error) && value.cause != null ? `${String(value.cause)}\\n` : ''}`;\n            break;\n          default: {\n            // property access\n            if (method?.startsWith('.')) {\n              const paths = method.slice(1).split('.');\n              for (let j = 0; j < paths.length && value != null; ++j) {\n                value = value[paths[j]];\n              }\n            }\n          }\n        }\n      }\n      cooked = cooked.slice(0, matches.index) + String(value) + cooked.slice(regex.lastIndex);\n      matches = regex.exec(cooked);\n    }\n  }\n  return cooked;\n};\n\ntype CreateError = (code: ErrorNames, ...details: unknown[]) => Error;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction pleaseHelpCreateAnIssue(title: string, body?: string) {\n  return `\\nThis is likely an issue with Aurelia.\\n Please help create an issue by clicking the following link\\n`\n    + `https://github.com/aurelia/aurelia/issues/new?title=${encodeURIComponent(title)}`\n    + (body != null ? `&body=${encodeURIComponent(body)}` : '&template=bug_report.md');\n}\n", "import { Metadata } from '@aurelia/metadata';\nimport { Constructable, ResourceType, Writable, getResourceKeyFor } from '@aurelia/kernel';\nimport { CustomElement } from '@aurelia/runtime-html';\nimport { LoadInstruction, ComponentAppellation, ViewportHandle, ComponentParameters, RouteableComponentType, type ReloadBehavior } from './interfaces';\nimport { ErrorNames, createMappedError } from './errors';\n\nexport interface IRoute extends Writable<Partial<Route>> {\n  /**\n   * The component to load when this route is matched. Transfered into the `instructions` property.\n   */\n  component?: ComponentAppellation;\n\n  /**\n   * The name of the viewport this component should be loaded into. Transfered into the `instructions` property.\n   *\n   * (TODO: Decide on, and provide more details about, whether this can be specified without specifying path, and what happens in different combinations of situations)\n   */\n  viewport?: ViewportHandle;\n\n  /**\n   * Parameters that should be accessible to components. Transfered into the `instructions` property.\n   */\n  parameters?: ComponentParameters;\n\n  /**\n   * Child instructions that should also be loaded when this route is matched. Transfered into the `instructions` property.\n   */\n  children?: LoadInstruction[];\n}\n\nexport class Route {\n  /**\n   * The metadata resource key for a configured route.\n   */\n  private static readonly resourceKey = getResourceKeyFor('route');\n\n  protected constructor(\n    /**\n     * The path to match against the url.\n     */\n    public readonly path: string | string[],\n\n    /**\n     * The id for this route, which can be used in the view for generating hrefs.\n     *\n     * (TODO: decide on, and provide more details about, whether this can be specified without specifying path, and what happens in different combinations of situations)\n     */\n    public readonly id: string | null,\n\n    /**\n     * The path to which to redirect when the url matches the path in this config.\n     *\n     * If the path begins with a slash (`/`), the redirect path is considered absolute, otherwise it is considered relative to the parent path.\n     */\n    public readonly redirectTo: string | null,\n\n    /**\n     * The instructions that should be loaded when this route is matched.\n     */\n    public instructions: LoadInstruction[] | null,\n\n    /**\n     * Whether the `path` should be case sensitive.\n     */\n    public readonly caseSensitive: boolean,\n\n    /**\n     * Title string or function to be used when setting title for the route.\n     */\n    // TODO(jurgen): Specify type!\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    public readonly title: any,\n\n    /**\n     * The reload behavior of the components in the route, as in how they behave\n     * when the route is loaded again.\n     *\n     * TODO(alpha): Add support for function in value\n     */\n    public reloadBehavior: ReloadBehavior | null,\n\n    /**\n     * Any custom data that should be accessible to matched components or hooks.\n     */\n    public readonly data: unknown,\n\n    // TODO: Look into adding these:\n    // public readonly canLoad: readonly CanLoad[],\n    // public readonly canUnload: readonly CanUnload[],\n    // public readonly loading: readonly Load[],\n    // public readonly unloading: readonly Unload[],\n  ) { }\n\n  /**\n   * Apply the specified configuration to the specified type, overwriting any existing configuration.\n   */\n  public static configure<T extends RouteType>(configOrPath: IRoute | string | undefined, Type: T): T {\n    const config = Route.create(configOrPath as IRoute, Type as RouteableComponentType);\n    Metadata.define(config, Type, Route.resourceKey);\n\n    return Type;\n  }\n\n  /**\n   * Get the `Route` configured with the specified type or null if there's nothing configured.\n   */\n  public static getConfiguration(Type: RouteableComponentType): Route | IRoute {\n    const config = Metadata.get<IRoute>(Route.resourceKey, Type) ?? {};\n\n    if (Array.isArray(Type.parameters)) {\n      config.parameters = Type.parameters;\n    }\n    if ('title' in Type) {\n      config.title = Type.title;\n    }\n\n    return config instanceof Route ? config : Route.create(config, Type);\n  }\n\n  /**\n   * Create a valid Route or throw if it can't.\n   *\n   * @param configOrType - Configuration or type the route is created from.\n   * @param Type - If specified, the Route is routing to Type, regardless of what config says, as with `@route` decorator.\n   */\n  public static create(configOrType: IRoute | RouteableComponentType | undefined, Type: RouteableComponentType | null = null): Route {\n    // If a fixed type is specified, component is fixed to that type and\n    // configOrType is set to a config with that.\n    // This also clones the route (not deep)\n    if (Type !== null) {\n      configOrType = Route.transferTypeToComponent(configOrType, Type);\n    }\n\n    // Another component queries our route configuration\n    if (CustomElement.isType(configOrType)) {\n      configOrType = Route.getConfiguration(configOrType);\n    } else if (Type === null) { // We need to clone the route (not deep)\n      configOrType = { ...configOrType };\n    }\n\n    const config = Route.transferIndividualIntoInstructions(configOrType!);\n\n    Route.validateRouteConfiguration(config);\n\n    let pathId = config.path;\n    if (Array.isArray(pathId)) {\n      pathId = pathId.join(',');\n    }\n    return new Route(\n      config.path ?? '',\n      config.id ?? pathId ?? null,\n      config.redirectTo ?? null,\n      config.instructions ?? null,\n      config.caseSensitive ?? false,\n      config.title ?? null,\n      config.reloadBehavior ?? null,\n      config.data ?? null,\n    );\n  }\n\n  /**\n   * Transfers the (only allowed) Type for the Route to the `component` property, creating\n   * a new configuration if necessary.\n   *\n   * It also validates that that the `component` and `instructions` are not used.\n   */\n  private static transferTypeToComponent(configOrType: IRoute | RouteableComponentType | undefined, Type: RouteableComponentType): IRoute {\n    if (CustomElement.isType(configOrType)) {\n      throw createMappedError(ErrorNames.route_no_component_as_config);\n    }\n\n    // Clone it so that original route isn't affected\n    // NOTE that it's not a deep clone (yet)\n    const config: IRoute = { ...configOrType };\n\n    if ('component' in config || 'instructions' in config) {\n      throw createMappedError(ErrorNames.route_no_both_component_and_instructions);\n    }\n    if (!('redirectTo' in config)) {\n      config.component = Type;\n    }\n    if (!('path' in config) && !('redirectTo' in config)) {\n      config.path = CustomElement.getDefinition(Type).name;\n    }\n\n    return config;\n  }\n\n  /**\n   * Transfers individual load instruction properties into the `instructions` property.\n   *\n   * It also validates that not both individual load instruction parts and the `instructions`\n   * is used.\n   */\n  private static transferIndividualIntoInstructions(config: IRoute): IRoute {\n    if (config == null) {\n      throw createMappedError(ErrorNames.route_nullish_config);\n    }\n\n    if (config.component != null\n      || config.viewport != null\n      || config.parameters != null\n      || config.children != null\n    ) {\n      if (config.instructions != null) {\n        throw createMappedError(ErrorNames.route_instructions_existed);\n      }\n      config.instructions = [{\n        component: config.component,\n        viewport: config.viewport,\n        parameters: config.parameters,\n        children: config.children,\n      }];\n    }\n\n    return config;\n  }\n\n  /**\n   * Validate a `Route`.\n   */\n  private static validateRouteConfiguration(config: Partial<Route>): void {\n    if (config.redirectTo === null && config.instructions === null) {\n      throw createMappedError(ErrorNames.route_invalid_config);\n    }\n\n    // TODO: Add validations for remaining properties and each index of 'instructions'\n  }\n}\n\nexport type RouteType<T extends Constructable = Constructable> = ResourceType<T, InstanceType<T>, IRoute>;\n", "import { Metadata } from '@aurelia/metadata';\nimport { Constructable, getResourceKeyFor } from '@aurelia/kernel';\nimport { CustomElementType } from '@aurelia/runtime-html';\nimport { IRoute, Route } from '../route';\nimport { RouteableComponentType } from '../interfaces';\n\nexport const Routes: {\n  name: string;\n  isConfigured<T extends CustomElementType>(Type: T): boolean;\n  configure<T extends CustomElementType>(configurationsOrTypes: (IRoute | RouteableComponentType)[], Type: T): T;\n  getConfiguration<T extends CustomElementType>(Type: T): Route[];\n} = {\n  name: /*@__PURE__*/getResourceKeyFor('routes'),\n  /**\n   * Returns `true` if the specified type has any static routes configuration (either via static properties or a &#64;route decorator)\n   */\n  isConfigured<T extends CustomElementType>(Type: T): boolean {\n    return Metadata.has(Routes.name, Type) || 'routes' in Type;\n  },\n\n  /**\n   * Apply the specified configuration to the specified type, overwriting any existing configuration.\n   */\n  configure<T extends CustomElementType>(configurationsOrTypes: (IRoute | RouteableComponentType)[], Type: T): T {\n    const configurations = configurationsOrTypes.map(configOrType => Route.create(configOrType));\n    Metadata.define(configurations, Type, Routes.name);\n\n    return Type;\n  },\n\n  /**\n   * Get the `RouteConfiguration`s associated with the specified type.\n   */\n  getConfiguration<T extends CustomElementType>(Type: T): Route[] {\n    const type: RouteableComponentType = Type;\n    const routes: (IRoute | Route)[] = [];\n    const metadata = Metadata.get(Routes.name, Type);\n\n    // TODO: Check if they are indeed to be concatenated (and what that means\n    // for match order) or if one should replace the other\n    if (Array.isArray(metadata)) {\n      routes.push(...metadata);\n    }\n    if (Array.isArray(type.routes)) {\n      routes.push(...type.routes);\n    }\n    return routes.map(route => route instanceof Route ? route : Route.create(route));\n  },\n};\n\nexport type RoutesDecorator = <T extends Constructable>(Type: T, context: ClassDecoratorContext<T>) => T;\n\n/**\n * Associate a static routes configuration with this type.\n *\n * @param configurations - The route configurations\n */\nexport function routes(configurations: IRoute[]): RoutesDecorator;\n/**\n * Create static route configurations for these types.\n *\n * @param Types - The types to create routes for.\n *\n * (TODO: improve the formatting, better examples, etc)\n *\n * ```\n * &#64;routes([{ path: 'home', component: 'my-home' }])\n * export class Home {}\n * ```\n */\nexport function routes(Types: RouteableComponentType[]): RoutesDecorator;\nexport function routes(configurationsOrTypes: (IRoute | RouteableComponentType)[]): RoutesDecorator {\n  return function (target, context) {\n    context.addInitializer(function (this) {\n      Routes.configure(configurationsOrTypes, this);\n    });\n    return target;\n  };\n}\n", "import { EndpointContent } from '../index';\n\n/**\n * The viewport scope content represents the content of a viewport scope\n * and whether it's active or not.\n *\n * During a transition, a viewport scope has two viewport scope contents,\n * the current and the next, which is turned back into one when the\n * transition is either finalized or aborted.\n *\n * Viewport scope contents are used to represent the full state and can\n * be used for caching\n */\n\nexport class ViewportScopeContent extends EndpointContent {\n}\n", "/**\n *\n * NOTE: This file is still WIP and will go through at least one more iteration of refactoring, commenting and clean up!\n * In its current state, it is NOT a good source for learning about the inner workings and design of the router.\n *\n */\nimport { CustomElementType } from '@aurelia/runtime-html';\nimport { RouteableComponentType } from '../interfaces';\nimport { IRouter } from '../router';\nimport { RoutingInstruction } from '../instructions/routing-instruction';\nimport { TransitionAction, RoutingScope } from '../routing-scope';\nimport { arrayRemove } from '../utilities/utils';\nimport { Navigation } from '../navigation';\nimport { NavigationCoordinator } from '../navigation-coordinator';\nimport { Runner, Step } from '../utilities/runner';\nimport { Routes } from '../decorators/routes';\nimport { Route } from '../route';\nimport { Endpoint, IConnectedCustomElement, IEndpointOptions } from './endpoint';\nimport { ViewportScopeContent } from './viewport-scope-content';\n\n/**\n * The viewport scope is an endpoint that encapsulates an au-viewport-scope custom\n * element instance. Its content isn't managed by, or even relevant for, the viewport\n * scope since it's only a container custom element. Instead of managing content,\n * the viewport scope provides a way to\n * a) add a routing scope without having to add an actual viewport,\n * b) have segments in routes/paths/instructions without requiring a viewport, and\n * c) make viewports repeatable (something they can't be by themselves) by\n * enclosing them.\n *\n * Since it is an endpoint, the viewport scope is participating in navigations and\n * instructed by the router and navigation coordinator (but with a very simple\n * transition and other navigation actions).\n */\nexport interface IViewportScopeOptions extends IEndpointOptions {\n  catches?: string | string[];\n  collection?: boolean;\n  source?: unknown[] | null;\n}\n\nexport class ViewportScope extends Endpoint {\n  public instruction: RoutingInstruction | null = null;\n\n  public available: boolean = true;\n  public sourceItem: unknown = null;\n  public sourceItemIndex: number = -1;\n\n  private remove: boolean = false;\n  private add: boolean = false;\n\n  public constructor(\n    router: IRouter,\n    name: string,\n    connectedCE: IConnectedCustomElement | null,\n    owningScope: RoutingScope | null,\n    scope: boolean,\n    public rootComponentType: CustomElementType | null = null, // temporary. Metadata will probably eliminate it\n    public options: IViewportScopeOptions = {\n      catches: [],\n      source: null,\n    },\n  ) {\n    super(router, name, connectedCE);\n    this.contents.push(new ViewportScopeContent(router, this, owningScope, scope));\n    if (this.catches.length > 0) {\n      this.instruction = RoutingInstruction.create(this.catches[0], this.name) as RoutingInstruction;\n    }\n  }\n\n  public get isEmpty(): boolean {\n    return this.instruction === null;\n  }\n\n  public get passThroughScope(): boolean {\n    return this.rootComponentType === null && this.catches.length === 0;\n  }\n\n  public get siblings(): ViewportScope[] {\n    const parent: RoutingScope | null = this.connectedScope.parent;\n    if (parent === null) {\n      return [this];\n    }\n    return parent.enabledChildren\n      .filter(child => child.isViewportScope && (child.endpoint as ViewportScope).name === this.name)\n      .map(child => child.endpoint as ViewportScope);\n  }\n\n  public get source(): unknown[] | null {\n    return this.options.source ?? null;\n  }\n\n  public get catches(): string[] {\n    let catches: string | string[] = this.options.catches ?? [];\n    if (typeof catches === 'string') {\n      catches = catches.split(',');\n    }\n    return catches;\n  }\n\n  public get default(): string | undefined {\n    if (this.catches.length > 0) {\n      return this.catches[0];\n    }\n  }\n\n  public toString(): string {\n    const contentName = this.instruction?.component.name ?? '';\n    const nextContentName = this.getNextContent()?.instruction.component.name ?? '';\n    return `vs:${this.name}[${contentName}->${nextContentName}]`;\n  }\n\n  public setNextContent(instruction: RoutingInstruction, navigation: Navigation): TransitionAction {\n    instruction.endpoint.set(this);\n\n    this.remove = instruction.isClear(this.router) || instruction.isClearAll(this.router);\n    this.add = instruction.isAdd(this.router) && Array.isArray(this.source);\n\n    if (this.add) {\n      instruction.component.name = null;\n    }\n\n    if (this.default !== void 0 && instruction.component.name === null) {\n      instruction.component.name = this.default;\n    }\n\n    this.contents.push(new ViewportScopeContent(this.router, this, this.owningScope, this.scope.hasScope, instruction, navigation));\n\n    return 'swap';\n  }\n\n  public transition(coordinator: NavigationCoordinator): void {\n    Runner.run('viewport-scope.transition',\n      (step: Step<void>) => coordinator.setEndpointStep(this, step.root),\n      () => coordinator.addEndpointState(this, 'guardedUnload'),\n      () => coordinator.addEndpointState(this, 'guardedLoad'),\n      () => coordinator.addEndpointState(this, 'guarded'),\n      () => coordinator.addEndpointState(this, 'loaded'),\n      () => coordinator.addEndpointState(this, 'unloaded'),\n      () => coordinator.addEndpointState(this, 'routed'),\n      () => coordinator.addEndpointState(this, 'swapped'),\n      () => coordinator.addEndpointState(this, 'completed'),\n    );\n  }\n\n  public finalizeContentChange(coordinator: NavigationCoordinator, _step: Step<void> | null): void {\n    const nextContentIndex = this.contents.findIndex(content => content.navigation === coordinator.navigation);\n    let nextContent = this.contents[nextContentIndex];\n\n    if (this.remove) {\n      const emptyContent = new ViewportScopeContent(this.router, this, this.owningScope, this.scope.hasScope);\n      this.contents.splice(nextContentIndex, 1, emptyContent);\n      nextContent.delete();\n      nextContent = emptyContent;\n    }\n    nextContent.completed = true;\n\n    let removeable = 0;\n    for (let i = 0, ii = nextContentIndex; i < ii; i++) {\n      if (!(this.contents[0].navigation.completed ?? false)) {\n        break;\n      }\n      removeable++;\n    }\n    this.contents.splice(0, removeable);\n\n    if (this.remove && Array.isArray(this.source)) {\n      this.removeSourceItem();\n    }\n  }\n  public cancelContentChange(coordinator: NavigationCoordinator, noExitStep: Step<void> | null = null): void | Step<void> {\n    // First cancel content change in all children\n    [...new Set(this.scope.children.map(scope => scope.endpoint))].forEach(child => child.cancelContentChange(coordinator, noExitStep));\n\n    const nextContentIndex = this.contents.findIndex(content => content.navigation === coordinator.navigation);\n    if (nextContentIndex < 0) {\n      return;\n    }\n\n    this.contents.splice(nextContentIndex, 1);\n    if (this.add) {\n      const index = this.source!.indexOf(this.sourceItem);\n      this.source!.splice(index, 1);\n      this.sourceItem = null;\n    }\n  }\n\n  public acceptSegment(segment: string): boolean {\n    if (segment === null && segment === void 0 || segment.length === 0) {\n      return true;\n    }\n    if (segment === RoutingInstruction.clear(this.router)\n      || segment === RoutingInstruction.add(this.router)\n      || segment === this.name) {\n      return true;\n    }\n\n    if (this.catches.length === 0) {\n      return true;\n    }\n\n    if (this.catches.includes(segment)) {\n      return true;\n    }\n    if (this.catches.filter((value) => value.includes('*')).length) {\n      return true;\n    }\n    return false;\n  }\n\n  public binding(): void {\n    const source: unknown[] = this.source || [];\n    if (source.length > 0 && this.sourceItem === null) {\n      this.sourceItem = this.getAvailableSourceItem();\n    }\n  }\n  public unbinding(): void {\n    if (this.sourceItem !== null && this.source !== null) {\n      arrayRemove(this.source, (item: unknown) => item === this.sourceItem);\n    }\n    this.sourceItem = null;\n  }\n\n  public getAvailableSourceItem(): unknown {\n    if (this.source === null) {\n      return null;\n    }\n    const siblings = this.siblings;\n    for (const item of this.source) {\n      if (siblings.every(sibling => sibling.sourceItem !== item)) {\n        return item;\n      }\n    }\n    return null;\n  }\n  public addSourceItem(): unknown {\n    const item: unknown = {};\n    this.source!.push(item);\n    return item;\n  }\n  public removeSourceItem(): void {\n    this.sourceItemIndex = this.source!.indexOf(this.sourceItem);\n    if (this.sourceItemIndex >= 0) {\n      this.source!.splice(this.sourceItemIndex, 1);\n    }\n  }\n\n  public getRoutes(): Route[] {\n    const routes = [];\n    if (this.rootComponentType !== null) {\n      // TODO: Fix it so that this isn't necessary!\n      const Type = this.rootComponentType.constructor === this.rootComponentType.constructor.constructor\n        ? this.rootComponentType\n        : this.rootComponentType.constructor as RouteableComponentType;\n\n      routes.push(...(Routes.getConfiguration(Type) ?? []));\n    }\n    return routes;\n  }\n}\n", "import { ICustomElementViewModel } from '@aurelia/runtime-html';\nimport { RoutingInstruction } from './instructions/routing-instruction';\nimport { RoutingScope } from './routing-scope';\nimport { OpenPromise } from './utilities/open-promise';\n\nexport interface IStoredNavigation extends Omit<StoredNavigation, 'toStoredNavigation'> { }\n\n/**\n * The stored navigation holds the part of a navigation that's stored\n * in history. Note that the data might not be json serializable and\n * therefore might not be able to be stored as-is.\n */\nexport class StoredNavigation {\n  /**\n   * The routing instruction for the navigation\n   */\n  public instruction: string | RoutingInstruction[];\n  /**\n   * A routing instruction describing the full navigational state once\n   * this navigation has been performed. Used when restoring a previous\n   * state.\n   */\n  public fullStateInstruction: string | RoutingInstruction[];\n\n  /**\n   * The starting scope of the navigation\n   */\n  public scope?: RoutingScope | null;\n\n  /**\n   * The historical index of the navigation\n   */\n  public index?: number;\n\n  /**\n   * Whether the navigation is the first in the sesseion. Index might change\n   * to not require first === 0, firstEntry should be reliable\n   */\n  public firstEntry?: boolean;\n  // public route?: Route;\n\n  /**\n   * The URL (Location) path of the navigation\n   */\n  public path?: string;\n\n  /**\n   * The (resulting) title of the navigation\n   */\n  public title?: string;\n\n  /**\n   * The query of the navigation\n   */\n   public query?: string;\n\n  /**\n   * The fragment of the navigation\n   */\n   public fragment?: string;\n\n  /**\n   * The parameters of the navigation\n   */\n  public parameters?: Record<string, unknown>;\n\n  /**\n   * The data of the navigation\n   */\n  public data?: Record<string, unknown>;\n\n  public constructor(entry: IStoredNavigation = {\n    instruction: '',\n    fullStateInstruction: '',\n  }) {\n    this.instruction = entry.instruction;\n    this.fullStateInstruction = entry.fullStateInstruction;\n    this.scope = entry.scope;\n    this.index = entry.index;\n    this.firstEntry = entry.firstEntry;\n    this.path = entry.path;\n    this.title = entry.title;\n    this.query = entry.query;\n    this.fragment = entry.fragment;\n    this.parameters = entry.parameters;\n    this.data = entry.data;\n  }\n\n  public toStoredNavigation(): IStoredNavigation {\n    return {\n      instruction: this.instruction,\n      fullStateInstruction: this.fullStateInstruction,\n      scope: this.scope,\n      index: this.index,\n      firstEntry: this.firstEntry,\n      path: this.path,\n      title: this.title,\n      query: this.query,\n      fragment: this.fragment,\n      parameters: this.parameters,\n      data: this.data,\n    };\n  }\n}\n\nexport class NavigationFlags {\n  public first: boolean = false;\n  public new: boolean = false;\n  public refresh: boolean = false;\n  public forward: boolean = false;\n  public back: boolean = false;\n  public replace: boolean = false;\n}\n\nexport interface INavigation extends Partial<Omit<Navigation, 'instruction' | 'fullStateInstruction' | 'navigation' | 'toStoredNavigation' | 'useFullStateInstruction' | 'process' | 'timestamp'>> {\n  instruction: string | RoutingInstruction[];\n  fullStateInstruction: string | RoutingInstruction[];\n}\n\n/**\n * The navigation\n */\n\nexport class Navigation extends StoredNavigation {\n  /**\n   * The navigation in a historical context (back, forward, etc)\n   */\n  public navigation: NavigationFlags = new NavigationFlags();\n\n  /**\n   * Whether this is a repeating navigation, in other words the same navigation run again\n   */\n  public repeating: boolean = false;\n\n  /**\n   * The previous navigation\n   */\n  public previous: Navigation | null = null;\n\n  /**\n   * Whether the navigation originates from a browser action (back, forward)\n   */\n  public fromBrowser: boolean = false;\n\n  /**\n   * The origin of the navigation, a view model or element\n   */\n  public origin: ICustomElementViewModel | Element | null = null;\n\n  /**\n   * Whether this navigation is fully replacing a previous one\n   */\n  public replacing: boolean = false;\n\n  /**\n   * Whether this navigation is a refresh/reload with the same parameters\n   */\n  public refreshing: boolean = false;\n\n  /**\n   * Whether this navigation is untracked and shouldn't be added to history\n   */\n  public untracked: boolean = false;\n\n  /**\n   * How the navigation has moved in history compared to previous navigation\n   */\n  public historyMovement?: number;\n\n  /**\n   * The process of the navigation, to be resolved or rejected\n   */\n  public process: OpenPromise<boolean> | null = null;\n\n  /**\n   * When the navigation is created. Only used within session so no need to\n   * persist it.\n   */\n  public timestamp: number;\n\n  /**\n   * Whether the navigation is completed\n   */\n  public completed?: boolean = true;\n\n  public constructor(entry: INavigation | Navigation = {\n    instruction: '',\n    fullStateInstruction: '',\n  }) {\n    super(entry);\n\n    this.fromBrowser = entry.fromBrowser ?? this.fromBrowser;\n    this.origin = entry.origin ?? this.origin;\n    this.replacing = entry.replacing ?? this.replacing;\n    this.refreshing = entry.refreshing ?? this.refreshing;\n    this.untracked = entry.untracked ?? this.untracked;\n    this.historyMovement = entry.historyMovement ?? this.historyMovement;\n    this.process = null;\n\n    this.timestamp = Date.now();\n  }\n\n  public get useFullStateInstruction(): boolean {\n    return (this.navigation.back ?? false) ||\n      (this.navigation.forward ?? false) ||\n      (this.navigation.refresh ?? false);\n  }\n\n  public static create(entry: INavigation = {\n    instruction: '',\n    fullStateInstruction: '',\n  }): Navigation {\n    return new Navigation(entry);\n  }\n}\n\n", "/**\n *\n * NOTE: This file is still WIP and will go through at least one more iteration of refactoring, commenting and clean up!\n * In its current state, it is NOT a good source for learning about the inner workings and design of the router.\n *\n */\nimport { OpenPromise } from './open-promise';\n\nexport class AwaitableMap<K, V> {\n  public map: Map<K, V | OpenPromise<V>> = new Map();\n\n  public set(key: K, value: V): void {\n    const openPromise = this.map.get(key);\n    if (openPromise instanceof OpenPromise) {\n      openPromise.resolve(value);\n      // openPromise.isPending = false;\n    }\n    this.map.set(key, value);\n  }\n\n  public delete(key: K): void {\n    const current = this.map.get(key);\n    if (current instanceof OpenPromise) {\n      current.reject();\n      // current.isPending = false;\n    }\n    this.map.delete(key);\n  }\n\n  public await(key: K): V | Promise<V> {\n    if (!this.map.has(key)) {\n      const openPromise = new OpenPromise<V>(`AwaitableMap: ${key}`);\n      this.map.set(key, openPromise);\n      return openPromise.promise;\n    }\n    const current = this.map.get(key);\n    if (current instanceof OpenPromise) {\n      return current.promise;\n    }\n    return current!;\n  }\n\n  public has(key: K): boolean {\n    return this.map.has(key) && !(this.map.get(key) instanceof OpenPromise);\n  }\n\n  public clone(): AwaitableMap<K, V> {\n    const clone = new AwaitableMap<K, V>();\n    clone.map = new Map(this.map);\n    return clone;\n  }\n}\n", "import { IContainer, onResolve } from '@aurelia/kernel';\nimport { Controller, IHydratedController, ICustomElementController, ICustomElementViewModel, LifecycleHook, LifecycleHooksLookup, ILifecycleHooks } from '@aurelia/runtime-html';\nimport { ComponentAppellation, IRouteableComponent, RouteableComponentType, type ReloadBehavior, LoadInstruction } from '../interfaces';\nimport { Viewport } from './viewport';\nimport { RoutingInstruction } from '../instructions/routing-instruction';\nimport { Navigation } from '../navigation';\nimport { IConnectedCustomElement } from './endpoint';\nimport { Runner, Step } from '../utilities/runner';\nimport { AwaitableMap } from '../utilities/awaitable-map';\nimport { EndpointContent, NavigationCoordinator, Parameters, RoutingScope } from '../index';\nimport { IRouter } from '../router';\nimport { FoundRoute } from '../found-route';\nimport { FallbackAction } from '../router-options';\nimport { ErrorNames, createMappedError } from '../errors';\n\n/**\n * The viewport content encapsulates the component loaded into a viewport\n * and keeps track of the component's lifecycle and routing states, meaning\n * that the callers don't have to query (internal) content state to know if\n * a \"state method\" can be called.\n *\n * During a transition, a viewport has two viewport contents, the current\n * and the next, which is turned back into one when the transition is either\n * finalized or aborted.\n *\n * Viewport contents are used to represent the full component state\n * and can be used for caching.\n */\n\n/**\n * The content states for the viewport content content.\n */\nexport type ContentState = 'created' | 'checkedUnload' | 'checkedLoad' | 'loaded' | 'activating' | 'activated';\n\n/**\n * @internal\n */\nexport class ViewportContent extends EndpointContent {\n  /**\n   * The current content states\n   */\n  public contentStates: AwaitableMap<ContentState, void> = new AwaitableMap();\n\n  /**\n   * Whether the viewport content is from the endpoint cache\n   */\n  public fromCache: boolean = false;\n\n  /**\n   * Whether the viewport content is from the history cache\n   */\n  public fromHistory: boolean = false;\n\n  /**\n   * Whether content is currently being reloaded\n   */\n  public reload: boolean = false;\n\n  /**\n   * Resolved when content is activated (and can be deactivated)\n   */\n  public activatedResolve?: ((value?: void | PromiseLike<void>) => void) | null = null;\n\n  public constructor(\n    public readonly router: IRouter,\n\n    /**\n     * The viewport the viewport content belongs to\n     */\n    viewport: Viewport,\n\n    /**\n     * The routing scope the viewport content belongs to/is owned by\n     */\n    owningScope: RoutingScope | null,\n\n    /**\n     * Whether the viewport has its own routing scope, containing\n     * endpoints it owns\n     */\n    hasScope: boolean,\n\n    /**\n     * The routing instruction that created the viewport content\n     */\n    public instruction: RoutingInstruction = RoutingInstruction.create('') as RoutingInstruction,\n\n    /**\n     * The navigation that created the viewport content\n     */\n    public navigation = Navigation.create({\n      instruction: '',\n      fullStateInstruction: '',\n    }),\n\n    /**\n     * The connected viewport custom element\n     */\n    connectedCE: IConnectedCustomElement | null = null\n  ) {\n    super(router, viewport, owningScope, hasScope, instruction, navigation);\n    // If we've got a container, we're good to resolve type\n    if (!this.instruction.component.isType() && connectedCE?.container != null) {\n      this.instruction.component.type = this.toComponentType(connectedCE.container);\n    }\n  }\n\n  /**\n   * The viewport content's component instance\n   */\n  public get componentInstance(): IRouteableComponent | null {\n    return this.instruction.component.instance;\n  }\n\n  /**\n   * The viewport content's reload behavior, as in how it behaves\n   * when the content is loaded again.\n   */\n  public get reloadBehavior(): ReloadBehavior {\n    if (this.instruction.route instanceof FoundRoute\n      && this.instruction.route.match?.reloadBehavior !== null\n    ) {\n      return this.instruction.route.match?.reloadBehavior as ReloadBehavior;\n    }\n    return (this.instruction.component.instance !== null &&\n      'reloadBehavior' in this.instruction.component.instance &&\n      this.instruction.component.instance.reloadBehavior !== void 0)\n      ? this.instruction.component.instance.reloadBehavior\n      : 'default';\n  }\n\n  /**\n   * Get the controller of the component in the viewport content.\n   */\n  public get controller(): ICustomElementController | undefined {\n    return this.instruction.component.instance?.$controller;\n  }\n\n  /**\n   * Whether the viewport content's component is equal to that of\n   * another viewport content.\n   *\n   * @param other - The viewport content to compare with\n   */\n  public equalComponent(other: ViewportContent): boolean {\n    return this.instruction.sameComponent(this.router, other.instruction);\n  }\n\n  /**\n   * Whether the viewport content's parameters is equal to that of\n   * another viewport content.\n   *\n   * @param other - The viewport content to compare with\n   */\n  public equalParameters(other: ViewportContent): boolean {\n    return this.instruction.sameComponent(this.router, other.instruction, true) &&\n      // TODO: Review whether query is enough or if parameters need\n      // to be checked as well depending on when query is updated.\n      // Should probably be able to compare parameters vs query as well.\n      (this.navigation.query ?? '') === (other.navigation.query ?? '');\n  }\n\n  /**\n   * Whether the viewport content is equal from a caching perspective to\n   * that of another viewport content.\n   *\n   * @param other - The viewport content to compare with\n   */\n  public isCacheEqual(other: ViewportContent): boolean {\n    return this.instruction.sameComponent(this.router, other.instruction, true);\n  }\n\n  /**\n   * Get the controller of the component in the viewport content.\n   *\n   * @param connectedCE - The custom element connected to the viewport\n   */\n  public contentController(connectedCE: IConnectedCustomElement): ICustomElementController {\n    return Controller.$el(\n      connectedCE.container.createChild(),\n      this.instruction.component.instance as ICustomElementViewModel,\n      connectedCE.element,\n      null,\n    );\n  }\n\n  /**\n   * Create the component for the viewport content (based on the instruction)\n   *\n   * @param connectedCE - The custom element connected to the viewport\n   * @param fallback - A (possible) fallback component to create if the\n   * instruction component can't be created. The name of the failing\n   * component is passed as parameter `id` to the fallback component\n   * @param fallbackAction - Whether the children of an unloadable component\n   * will be processed under the fallback component or if the child\n   * instructions will be aborted.\n   */\n  public createComponent(coordinator: NavigationCoordinator, connectedCE: IConnectedCustomElement, fallback?: ComponentAppellation, fallbackAction?: FallbackAction): void | Promise<void> {\n    // Can be called at multiple times, only process the first\n    if (this.contentStates.has('created')) {\n      return;\n    }\n    // Don't load cached content or instantiated history content\n    if (!this.fromCache && !this.fromHistory) {\n      try {\n        return onResolve(\n          this.toComponentInstance(connectedCE.container, connectedCE.controller, connectedCE.element),\n          (component: IRouteableComponent | null) => {\n            this.instruction.component.set(component);\n            this.contentStates.set('created', void 0);\n          }) as void | Promise<void>;\n      } catch (e: unknown) {\n        this._assertInstantiationError(e);\n\n        // If there's a fallback component...\n        if ((fallback ?? '') !== '') {\n          if (fallbackAction === 'process-children') {\n            // ...set the failed component as the first parameter (0)...\n            this.instruction.parameters.set([this.instruction.component.name]);\n          } else { // 'abort'\n            // ...set the unparsed string of the failed component as the first parameter (0)...\n            this.instruction.parameters.set([this.instruction.unparsed ?? this.instruction.component.name]);\n            // ...if the instruction has children...\n            if (this.instruction.hasNextScopeInstructions) {\n              // ...remove the children from the coordinator\n              coordinator.removeInstructions(this.instruction.nextScopeInstructions!);\n              // ...and prevent processing of the child instructions.\n              this.instruction.nextScopeInstructions = null;\n            }\n          }\n          // ...fallback is the new component...\n          this.instruction.component.set(fallback);\n\n          // ...and try again.\n          try {\n            return onResolve(\n              this.toComponentInstance(connectedCE.container, connectedCE.controller, connectedCE.element),\n              (fallbackComponent: IRouteableComponent | null) => {\n                this.instruction.component.set(fallbackComponent);\n                this.contentStates.set('created', void 0);\n              }) as void | Promise<void>;\n          } catch (ee) {\n            this._assertInstantiationError(ee);\n\n            throw createMappedError(ErrorNames.endpoint_instantiation_error, this.instruction.component.name, ee);\n          }\n        } else {\n          throw createMappedError(ErrorNames.endpoint_instantiation_error, this.instruction.component.name);\n        }\n      }\n    }\n    this.contentStates.set('created', void 0);\n  }\n\n  /**\n   * Check if the viewport content's component can be loaded.\n   */\n  public canLoad(): boolean | LoadInstruction | LoadInstruction[] | Promise<boolean | LoadInstruction | LoadInstruction[]> {\n    // Since canLoad is called from more than one place multiple calls can happen (and is fine)\n    if (!this.contentStates.has('created') || (this.contentStates.has('checkedLoad') && !this.reload)) {\n      // If we got here, an earlier check has already stated it can be loaded\n      return true;\n    }\n    const instance = this.instruction.component.instance!;\n    if (instance == null) {\n      return true;\n    }\n\n    this.contentStates.set('checkedLoad', void 0);\n\n    // Propagate parent parameters\n    // TODO: Do we really want this?\n    const parentParameters = (this.endpoint as Viewport)\n      .parentViewport?.getTimeContent(this.navigation.timestamp)?.instruction?.typeParameters(this.router);\n    const parameters = this.instruction.typeParameters(this.router);\n    const merged = { ...this.navigation.parameters, ...parentParameters, ...parameters };\n\n    const hooks = this._getLifecycleHooks(instance, 'canLoad')\n      .map(hook => ((innerStep: Step | null) => {\n        if (innerStep?.previousValue != null && innerStep.previousValue !== true) {\n          innerStep.exit(); // To prevent more calls down the pipeline\n          return innerStep.previousValue ?? false;\n        }\n        // TODO: If requested, pass previous value into hook\n        return hook(instance, merged, this.instruction, this.navigation);\n      }));\n\n    if (instance.canLoad != null) {\n      hooks.push((innerStep: Step | null) => {\n        if ((innerStep?.previousValue ?? true) === false) {\n          return false;\n        }\n        // TODO: If requested, pass previous value into hook\n        return instance.canLoad!(merged, this.instruction, this.navigation);\n      });\n    }\n\n    if (hooks.length === 0) {\n      return true;\n    }\n\n    if (hooks.length === 1) {\n      return hooks[0](null);\n    }\n    return Runner.run('canLoad', ...hooks) as Promise<RoutingInstruction[]>;\n  }\n\n  /**\n   * Check if the viewport content's component can be unloaded.\n   *\n   * @param navigation - The navigation that causes the content change\n   */\n  public canUnload(navigation: Navigation | null): boolean | Promise<boolean> {\n    // Since canUnload is called recursively multiple calls can happen (and is fine)\n    if (this.contentStates.has('checkedUnload') && !this.reload) {\n      // If we got here, an earlier check has already stated it can be unloaded\n      return true;\n    }\n    this.contentStates.set('checkedUnload', void 0);\n\n    // If content hasn't loaded a component, we're done\n    if (!this.contentStates.has('loaded')) {\n      return true;\n    }\n\n    const instance = this.instruction.component.instance!;\n\n    // If it's an unload without a navigation, such as custom element simply\n    // being removed, create an empty navigation for canUnload hook\n    if (navigation === null) {\n      navigation = Navigation.create({\n        instruction: '',\n        fullStateInstruction: '',\n        previous: this.navigation,\n      });\n    }\n\n    const hooks = this._getLifecycleHooks(instance, 'canUnload').map(hook => ((innerStep: Step | null) => {\n      if ((innerStep?.previousValue ?? true) === false) {\n        return false;\n      }\n      return hook(instance, this.instruction, navigation);\n    }));\n\n    if (instance.canUnload != null) {\n      hooks.push((innerStep: Step | null) => {\n        if ((innerStep?.previousValue ?? true) === false) {\n          return false;\n        }\n        // TODO: If requested, pass previous value into hook\n        return instance.canUnload?.(this.instruction, navigation) as boolean | Promise<boolean>;\n      });\n    }\n\n    if (hooks.length === 0) {\n      return true;\n    }\n\n    if (hooks.length === 1) {\n      return hooks[0](null);\n    }\n    return Runner.run('canUnload', ...hooks) as boolean | Promise<boolean>;\n  }\n\n  /**\n   * Load the viewport content's content.\n   *\n   * @param step - The previous step in this transition Run\n   */\n  public load(step: Step<void>): Step<void> {\n    return Runner.run(step,\n      () => this.contentStates.await('checkedLoad'),\n      () => {\n        // Since load is called from more than one place multiple calls can happen (and is fine)\n        if (!this.contentStates.has('created') || (this.contentStates.has('loaded') && !this.reload)) {\n          // If we got here, it's already loaded\n          return;\n        }\n        this.reload = false;\n\n        this.contentStates.set('loaded', void 0);\n\n        const instance = this.instruction.component.instance!;\n\n        // Propagate parent parameters\n        // TODO: Do we really want this?\n        const parentParameters = (this.endpoint as Viewport)\n          .parentViewport?.getTimeContent(this.navigation.timestamp)?.instruction?.typeParameters(this.router);\n        const parameters = this.instruction.typeParameters(this.router);\n        const merged = { ...this.navigation.parameters, ...parentParameters, ...parameters };\n\n        const hooks = this._getLifecycleHooks(instance, 'loading').map(hook =>\n          () => hook(instance, merged, this.instruction, this.navigation));\n\n        hooks.push(...this._getLifecycleHooks(instance, 'load').map(hook =>\n          () => {\n            // eslint-disable-next-line no-console\n            console.warn(`[Deprecated] Found deprecated hook name \"load\" in ${this.instruction.component.name}. Please use the new name \"loading\" instead.`);\n            return hook(instance, merged, this.instruction, this.navigation);\n          }));\n\n        if (hooks.length !== 0) {\n          // Add hook in component\n          if (typeof instance.loading === 'function') {\n            hooks.push(() => instance.loading!(merged, this.instruction, this.navigation));\n          }\n          if (hasVmHook(instance, 'load')) {\n            // eslint-disable-next-line no-console\n            console.warn(`[Deprecated] Found deprecated hook name \"load\" in ${this.instruction.component.name}. Please use the new name \"loading\" instead.`);\n            hooks.push(() => instance.load(merged, this.instruction, this.navigation));\n          }\n\n          return Runner.run('load', ...hooks);\n        }\n\n        // Skip if there's no hook in component\n        if (hasVmHook(instance, 'loading')) {\n          return instance.loading(merged, this.instruction, this.navigation);\n        }\n        // Skip if there's no hook in component\n        if (hasVmHook(instance, 'load')) {\n          // eslint-disable-next-line no-console\n          console.warn(`[Deprecated] Found deprecated hook name \"load\" in ${this.instruction.component.name}. Please use the new name \"loading\" instead.`);\n          return instance.load(merged, this.instruction, this.navigation);\n        }\n      }\n    ) as Step<void>;\n  }\n\n  /**\n   * Unload the viewport content's content.\n   *\n   * @param navigation - The navigation that causes the content change\n   */\n  public unload(navigation: Navigation | null): void | Promise<void> {\n    // Since load is called from more than one place multiple calls can happen (and is fine)\n    if (!this.contentStates.has('loaded')) {\n      // If we got here, it's already unloaded (or wasn't loaded in the first place)\n      return;\n    }\n    this.contentStates.delete('loaded');\n\n    const instance = this.instruction.component.instance!;\n\n    if (navigation === null) {\n      navigation = Navigation.create({\n        instruction: '',\n        fullStateInstruction: '',\n        previous: this.navigation,\n      });\n    }\n\n    const hooks = this._getLifecycleHooks(instance, 'unloading').map(hook =>\n      () => hook(instance, this.instruction, navigation));\n\n    hooks.push(...this._getLifecycleHooks(instance, 'unload').map(hook =>\n      () => {\n        // eslint-disable-next-line no-console\n        console.warn(`[Deprecated] Found deprecated hook name \"unload\" in ${this.instruction.component.name}. Please use the new name \"unloading\" instead.`);\n        return hook(instance, this.instruction, navigation);\n      }));\n\n    if (hooks.length !== 0) {\n      // Add hook in component\n      if (hasVmHook(instance, 'unloading')) {\n        hooks.push(() => instance.unloading(this.instruction, navigation));\n      }\n      if (hasVmHook(instance, 'unload')) {\n        // eslint-disable-next-line no-console\n        console.warn(`[Deprecated] Found deprecated hook name \"unload\" in ${this.instruction.component.name}. Please use the new name \"unloading\" instead.`);\n        hooks.push(() => instance.unload(this.instruction, navigation));\n      }\n\n      return Runner.run('unload', ...hooks) as void | Promise<void>;\n    }\n\n    // Skip if there's no hook in component\n    if (hasVmHook(instance, 'unloading')) {\n      return instance.unloading(this.instruction, navigation);\n    }\n    if (hasVmHook(instance, 'unload')) {\n      // eslint-disable-next-line no-console\n      console.warn(`[Deprecated] Found deprecated hook name \"unload\" in ${this.instruction.component.name}. Please use the new name \"unloading\" instead.`);\n      return instance.unload(this.instruction, navigation);\n    }\n  }\n\n  /**\n   * Activate (bind and attach) the content's component.\n   *\n   * @param step - The previous step in this transition Run\n   * @param initiator - The controller initiating the activation\n   * @param parent - The parent controller for the content's component controller\n   * @param flags - The lifecycle flags\n   * @param connectedCE - The viewport's connectd custom element\n   * @param boundCallback - A callback that's called when the content's component has been bound\n   * @param attachPromise - A promise that th content's component controller will await before attaching\n   */\n  public activateComponent(\n    step: Step<void>,\n    initiator: IHydratedController | null,\n    parent: ICustomElementController | null,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    connectedCE: IConnectedCustomElement,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    boundCallback: unknown,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    attachPromise: void | Promise<void> | undefined\n  ): Step<void> {\n    return Runner.run(step,\n      () => this.contentStates.await('loaded'),\n      () => this.waitForParent(parent), // TODO: It might be possible to refactor this away\n      () => {\n        if (this.contentStates.has('activating') || this.contentStates.has('activated')) {\n          return;\n        }\n        this.contentStates.set('activating', void 0);\n\n        return this.controller?.activate(\n          initiator ?? this.controller,\n          parent,\n          void 0 /* , boundCallback, this.instruction.topInstruction ? attachPromise : void 0 */) as Promise<void>;\n      },\n      () => {\n        this.contentStates.set('activated', void 0);\n      },\n      /* TODO: This should be added back in somehow/somewhere\n      () => {\n        if (this.fromCache || this.fromHistory) {\n          const elements = Array.from(connectedCE.element.getElementsByTagName('*'));\n          for (const el of elements) {\n            const attr = el.getAttribute('au-element-scroll');\n            if (attr) {\n              const [top, left] = attr.split(',');\n              el.removeAttribute('au-element-scroll');\n              el.scrollTo(+left, +top);\n            }\n          }\n        }\n      },\n    */\n    ) as Step<void>;\n  }\n\n  /**\n   * Deactivate (detach and unbind) the content's component.\n   *\n   * @param step - The previous step in this transition Run\n   * @param initiator - The controller initiating the activation\n   * @param parent - The parent controller for the content's component controller\n   * @param flags - The lifecycle flags\n   * @param connectedCE - The viewport's connectd custom element\n   * @param stateful - Whether the content's component is stateful and shouldn't be disposed\n   */\n  public deactivateComponent(step: Step<void> | null, initiator: IHydratedController | null, parent: ICustomElementController | null, connectedCE: IConnectedCustomElement, stateful: boolean = false): void | Promise<void> | Step<void> {\n    if (!this.contentStates.has('activated') && !this.contentStates.has('activating')) {\n      return;\n    }\n    return Runner.run(\n      step,\n      // TODO: Revisit once it's possible to abort within lifecycle hooks\n      // () => {\n      //   if (!this.contentStates.has('activated')) {\n      //     const elements = Array.from(connectedCE.element.children);\n      //     for (const el of elements) {\n      //       (el as HTMLElement).style.display = 'none';\n      //     }\n      //     return this.contentStates.await('activated');\n      //   }\n      // },\n      // () => this.waitForActivated(this.controller, connectedCE),\n      () => {\n        if (stateful && connectedCE.element !== null) {\n          const elements = Array.from(connectedCE.element.getElementsByTagName('*'));\n          for (const el of elements) {\n            if (el.scrollTop > 0 || el.scrollLeft) {\n              el.setAttribute('au-element-scroll', `${el.scrollTop},${el.scrollLeft}`);\n            }\n          }\n        }\n\n        this.contentStates.delete('activated');\n        this.contentStates.delete('activating');\n        return this.controller?.deactivate(initiator ?? this.controller, parent);\n      }\n    ) as Step<void>;\n  }\n\n  /**\n   * Dispose the content's component.\n   *\n   * @param connectedCE - The viewport's connectd custom element\n   * @param cache - The cache to push the viewport content to if stateful\n   * @param stateful - Whether the content's component is stateful and shouldn't be disposed\n   */\n  public disposeComponent(connectedCE: IConnectedCustomElement, cache: ViewportContent[], stateful: boolean = false): void {\n    if (!this.contentStates.has('created') || this.instruction.component.instance == null) {\n      return;\n    }\n\n    // Don't unload components when stateful\n    // TODO: We're missing stuff here\n    if (!stateful) {\n      this.contentStates.delete('created');\n      return this.controller?.dispose();\n    } else {\n      cache.push(this);\n    }\n  }\n\n  /**\n   * Free the content's content.\n   *\n   * @param step - The previous step in this transition Run\n   * @param connectedCE - The viewport's connectd custom element\n   * @param navigation - The navigation causing the content to be freed\n   * @param cache - The cache to push the viewport content to if stateful\n   * @param stateful - Whether the content's component is stateful and shouldn't be disposed\n   */\n  public freeContent(step: Step<void>, connectedCE: IConnectedCustomElement | null, navigation: Navigation | null, cache: ViewportContent[], stateful: boolean = false): Step<void> {\n    return Runner.run(step,\n      () => this.unload(navigation),\n      (innerStep: Step<void>) => this.deactivateComponent(innerStep, null, connectedCE!.controller, connectedCE!, stateful),\n      () => this.disposeComponent(connectedCE!, cache, stateful),\n    ) as Step<void>;\n  }\n\n  /**\n   * Get the content's component name (if any).\n   */\n  public toComponentName(): string | null {\n    return this.instruction.component.name;\n  }\n\n  /**\n   * Get the content's component type (if any).\n   */\n  public toComponentType(container: IContainer): RouteableComponentType | null {\n    if (this.instruction.component.none) {\n      return null;\n    }\n    return this.instruction.component.toType(container, this.instruction);\n  }\n\n  /**\n   * Get the content's component instance (if any).\n   */\n  public toComponentInstance(parentContainer: IContainer, parentController: IHydratedController, parentElement: HTMLElement): IRouteableComponent | null | Promise<IRouteableComponent> {\n    if (this.instruction.component.none) {\n      return null;\n    }\n    return this.instruction.component.toInstance(parentContainer, parentController, parentElement, this.instruction);\n  }\n\n  /**\n   * Wait for the viewport's parent to be active.\n   *\n   * @param parent - The parent controller to the viewport's controller\n   */\n  private waitForParent(parent: ICustomElementController | null): void | Promise<void> {\n    if (parent === null) {\n      return;\n    }\n    if (!parent.isActive) {\n      return new Promise((resolve) => {\n        (this.endpoint as Viewport).activeResolve = resolve;\n      });\n    }\n  }\n\n  /**\n   * Assert that the error is an instantiation error. If it's not, throw\n   * the error. If it is, log a warning in development mode.\n   *\n   * @param e - The error to assert\n   */\n  private _assertInstantiationError(e: unknown): void {\n    if (!(e as Error).message.startsWith('AUR0009:')) {\n      throw e;\n    }\n\n    if (__DEV__) {\n      const componentName = this.instruction.component.name as string;\n      // eslint-disable-next-line no-console\n      console.warn(createMappedError(ErrorNames.endpoint_instantiation_error, componentName, e));\n    }\n  }\n\n  /** @internal */\n  // TODO: Move this elsewhere and fix the typings\n  private _getLifecycleHooks(instance: IRouteableComponent, name: 'canLoad'): LifecycleHook<IRouteableComponent, 'canLoad'>[];\n  private _getLifecycleHooks(instance: IRouteableComponent, name: 'loading'): LifecycleHook<IRouteableComponent, 'loading'>[];\n  /**\n   * @deprecated\n   */\n  private _getLifecycleHooks(instance: IRouteableComponent, name: 'load'): LifecycleHook<IRouteableComponent, 'loading'>[];\n  private _getLifecycleHooks(instance: IRouteableComponent, name: 'canUnload'): LifecycleHook<IRouteableComponent, 'canUnload'>[];\n  /**\n   * @deprecated\n   */\n  private _getLifecycleHooks(instance: IRouteableComponent, name: 'unload'): LifecycleHook<IRouteableComponent, 'unloading'>[];\n  private _getLifecycleHooks(instance: IRouteableComponent, name: 'unloading'): LifecycleHook<IRouteableComponent, 'unloading'>[];\n  private _getLifecycleHooks(instance: IRouteableComponent, name: LifecycleNames): unknown[] {\n    const hooks = (instance.$controller!.lifecycleHooks as LifecycleHooksLookup<IRouteableComponentDeprecated>)[name] ?? [];\n    return hooks.map(hook => ((hook.instance as ILifecycleHooks<IRouteableComponentDeprecated>)[name]).bind(hook.instance));\n  }\n}\n\ntype IRouteableComponentDeprecated = IRouteableComponent & {\n  load?(parameters: Parameters, instruction: RoutingInstruction, navigation: Navigation): void | Promise<void>;\n  unload?(instruction: RoutingInstruction, navigation: Navigation | null): void | Promise<void>;\n};\n\ntype LifecycleNames = 'load' | 'unload' | 'loading' | 'unloading' | 'canLoad' | 'canUnload';\ntype IHasVmHook<T extends LifecycleNames> = IRouteableComponentDeprecated & {\n  [key in T]: NonNullable<IRouteableComponentDeprecated[key]>;\n};\n\n/**\n * @deprecated\n * 'load' and 'unload' are deprecated in favor of 'loading' and 'unloading'\n */\nfunction hasVmHook(\n  instance: IRouteableComponentDeprecated,\n  lifecycle: 'load' | 'unload',\n): instance is IHasVmHook<typeof lifecycle>;\nfunction hasVmHook(\n  instance: IRouteableComponentDeprecated,\n  lifecycle: 'load' | 'unload' | 'loading' | 'unloading' | 'canLoad' | 'canUnload',\n): instance is IHasVmHook<typeof lifecycle>;\nfunction hasVmHook(\n  instance: IRouteableComponentDeprecated,\n  lifecycle: 'load' | 'unload' | 'loading' | 'unloading' | 'canLoad' | 'canUnload',\n): instance is IHasVmHook<typeof lifecycle> {\n  return typeof instance[lifecycle] === 'function';\n}\n", "import { FallbackAction } from '../router-options';\nimport { IEndpointOptions } from './endpoint';\n\nexport interface IViewportOptions extends Omit<Partial<ViewportOptions>, 'usedBy'> {\n  usedBy?: string | string[];\n}\n\nexport class ViewportOptions implements IEndpointOptions {\n  /**\n   * The default component that's loaded if the viewport is created\n   * without having a component specified (in that navigation).\n   * (Declared here because of name conflict.)\n   */\n  public default: string | undefined = undefined;\n\n  public constructor(\n    /**\n     * Whether the viewport has its own scope (owns other endpoints)\n     */\n    public scope: boolean = true,\n\n    /**\n     * A list of components that is using the viewport. These components\n     * can only be loaded into this viewport and this viewport can't\n     * load any other components.\n     */\n    public usedBy: string[] = [],\n\n    /**\n     * The default component that's loaded if the viewport is created\n     * without having a component specified (in that navigation).\n     */\n    // eslint-disable-next-line default-param-last\n    _default: string = '',\n\n    /**\n     * The component loaded if the viewport can't load the specified\n     * component. The component is passed as a parameter to the fallback.\n     */\n    public fallback: string = '',\n\n    /**\n     * Whether the fallback action is to load the fallback component in\n     * place of the unloadable component and continue with any child\n     * instructions or if the fallback is to be called and the processing\n     * of the children to be aborted.\n     */\n    public fallbackAction: FallbackAction | '' = '',\n\n    /**\n     * The viewport doesn't add its content to the Location URL.\n     */\n    public noLink: boolean = false,\n\n    /**\n     * The viewport doesn't add a title to the browser window title.\n     */\n    public noTitle: boolean = false,\n\n    /**\n     * The viewport's content is stateful.\n     */\n    public stateful: boolean = false,\n\n    /**\n     * The viewport is always added to the routing instruction.\n     */\n    public forceDescription: boolean = false,\n\n    /**\n     * The transitions in the endpoint shouldn't be added to the navigation history\n     */\n    public noHistory: boolean = false,\n  ) {\n    this.default = _default;\n  }\n\n  public static create(options?: IViewportOptions): ViewportOptions {\n    const created = new ViewportOptions();\n    if (options !== void 0) {\n      created.apply(options);\n    }\n    return created;\n  }\n\n  public apply(options: ViewportOptions | IViewportOptions): void {\n    this.scope = options.scope ?? this.scope;\n    this.usedBy = (typeof options.usedBy === 'string'\n      ? options.usedBy.split(',').filter(str => str.length > 0)\n      : options.usedBy\n    )\n      ?? this.usedBy;\n    this.default = options.default ?? this.default;\n    this.fallback = options.fallback ?? this.fallback;\n    this.fallbackAction = options.fallbackAction ?? this.fallbackAction;\n    this.noLink = options.noLink ?? this.noLink;\n    this.noTitle = options.noTitle ?? this.noTitle;\n    this.stateful = options.stateful ?? this.stateful;\n    this.forceDescription = options.forceDescription ?? this.forceDescription;\n    this.noHistory = options.noHistory ?? this.noHistory;\n  }\n}\n", "/* eslint-disable max-lines-per-function */\nimport { IContainer } from '@aurelia/kernel';\nimport { CustomElement, IHydratedController, IHydratedParentController, ICustomElementController } from '@aurelia/runtime-html';\nimport { ComponentAppellation, IRouteableComponent, RouteableComponentType, LoadInstruction } from '../interfaces';\nimport { IRouter } from '../router';\nimport { arrayRemove } from '../utilities/utils';\nimport { ViewportContent } from './viewport-content';\nimport { RoutingInstruction } from '../instructions/routing-instruction';\nimport { TransitionAction, RoutingScope } from '../routing-scope';\nimport { Navigation } from '../navigation';\nimport { NavigationCoordinator } from '../navigation-coordinator';\nimport { Runner, Step } from '../utilities/runner';\nimport { Routes } from '../decorators/routes';\nimport { Route } from '../route';\nimport { Endpoint, IConnectedCustomElement } from './endpoint';\nimport { IViewportOptions, ViewportOptions } from './viewport-options';\n\n/**\n * The viewport is an endpoint that encapsulates an au-viewport custom element\n * instance. It always has at least one viewport content -- the current and also\n * the next when the viewport is in a transition -- even though the viewport\n * content can be empty.\n *\n * If a routing instruction is matched to a viewport during a navigation, the\n * router will ask the viewport if the navigation is approved (based on the state\n * of the current content, next content authorization and so on) and if it is,\n * instruct the navigation coordinator to start the viewport's transition when\n * appropriate. The viewport will then orchestrate, with coordination help from\n * the navigation coordinator, the transition between the current content and\n * the next, including calling relevant routing and lifecycle hooks.\n *\n * In addition to the above, the viewport also serves as the router's interface\n * to the loaded content/component and its configuration such as title and\n * configured routes.\n */\n\nexport class Viewport extends Endpoint {\n  /**\n   * The contents of the viewport. New contents are pushed to this, making\n   * the last one the active one. It always holds at least one content, so\n   * that there's always a current content.\n   */\n  public contents: ViewportContent[] = [];\n\n  /**\n   * Whether the viewport content should be cleared and removed,\n   * regardless of statefulness (and hooks).\n   */\n  public forceRemove: boolean = false;\n\n  /**\n   * The viewport options.\n   */\n  public options: ViewportOptions = new ViewportOptions();\n\n  /**\n   * If set by viewport content, it's resolved when viewport has\n   * been actived/started binding.\n   */\n  public activeResolve?: ((value?: void | PromiseLike<void>) => void) | null = null;\n\n  /**\n   * If set, it's resolved when viewport custom element has been\n   * connected to the viewport endpoint/router.\n   */\n  private connectionResolve?: ((value?: void | PromiseLike<void>) => void) | null = null;\n\n  /**\n   * Whether the viewport is being cleared in the transaction.\n   */\n  private clear: boolean = false;\n\n  /**\n   * The coordinators that have transitions on the viewport.\n   * Wheneve a new coordinator is pushed, any previous are\n   * considered inactive and skips actual transition activities.\n   */\n  private readonly coordinators: NavigationCoordinator[] = [];\n\n  /**\n   * Stores the current state before navigation starts so that it can be restored\n   * if navigation is cancelled/interrupted.\n   * TODO(post-alpha): Look into using viewport content fully for this\n   */\n  private previousViewportState: Viewport | null = null;\n\n  /**\n   * The viewport content cache used for statefulness.\n   */\n  private cache: ViewportContent[] = [];\n\n  /**\n   * The viewport content cache used for history statefulness.\n   */\n  private historyCache: ViewportContent[] = [];\n\n  public constructor(\n    router: IRouter,\n\n    /**\n     * The name of the viewport\n     */\n    name: string,\n\n    /**\n     * The connected ViewportCustomElement (if any)\n     */\n    connectedCE: IConnectedCustomElement | null,\n\n    /**\n     * The routing scope the viewport belongs to/is owned by\n     */\n    owningScope: RoutingScope,\n\n    /**\n     * Whether the viewport has its own routing scope, containing\n     * endpoints it owns\n     */\n    hasScope: boolean,\n\n    /**\n     * The viewport options.\n     */\n    options?: IViewportOptions,\n  ) {\n    super(router, name, connectedCE);\n    this.contents.push(new ViewportContent(router, this, owningScope, hasScope));\n    this.contents[0].completed = true;\n\n    if (options !== void 0) {\n      this.options.apply(options);\n    }\n  }\n\n  /**\n   * The current content of the endpoint\n   */\n  public getContent(): ViewportContent {\n    // If there's only one content, it's always content\n    if (this.contents.length === 1) {\n      return this.contents[0];\n    }\n    let content!: ViewportContent;\n    // Go through all contents looking for last completed\n    for (let i = 0, ii = this.contents.length; i < ii; i++) {\n      if (this.contents[i].completed ?? false) {\n        content = this.contents[i];\n      } else {\n        break;\n      }\n    }\n    return content;\n  }\n\n  /**\n   * The next, to be transitioned in, content of the endpoint\n   */\n  public getNextContent(): ViewportContent | null {\n    // If there's only one content, it's always content\n    if (this.contents.length === 1) {\n      return null;\n    }\n    const lastCompleted = this.contents.indexOf(this.getContent());\n    return this.contents.length > lastCompleted ? this.contents[lastCompleted + 1] : null;\n  }\n\n  /**\n   * The content of the viewport at a specific timestamp.\n   *\n   * @param timestamp - The timestamp\n   */\n  public getTimeContent(timestamp: number): ViewportContent | null {\n    let content: ViewportContent | null = null;\n    // Go through all contents looking for last completed\n    for (let i = 0, ii = this.contents.length; i < ii; i++) {\n      if (this.contents[i].navigation.timestamp > timestamp) {\n        break;\n      }\n      content = this.contents[i];\n    }\n    return content;\n  }\n\n  /**\n   * The content for a specific navigation (or coordinator)\n   */\n  public getNavigationContent(navigation: NavigationCoordinator | Navigation): ViewportContent | null {\n    return super.getNavigationContent(navigation) as ViewportContent | null;\n  }\n\n  /**\n   * The parent viewport.\n   */\n  public get parentViewport(): Viewport | null {\n    let scope = this.connectedScope;\n    while (scope?.parent != null) {\n      scope = scope.parent;\n      if (scope.endpoint.isViewport) {\n        return scope.endpoint as Viewport;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Whether the viewport (content) is empty.\n   */\n  public get isEmpty(): boolean {\n    return this.getContent().componentInstance === null;\n  }\n\n  /**\n   * Whether the viewport content should be cleared and removed,\n   * regardless of statefulness (and hooks). If a parent should\n   * be removed, the viewport should as well.\n   */\n  public get doForceRemove(): boolean {\n    let scope: RoutingScope | null = this.connectedScope;\n    while (scope !== null) {\n      if (scope.isViewport && (scope.endpoint as Viewport).forceRemove) {\n        return true;\n      }\n      scope = scope.parent;\n    }\n    return false;\n  }\n\n  /**\n   * Whether a coordinator handles the active navigation.\n   *\n   * @param coordinator - The coordinator to check\n   */\n  public isActiveNavigation(coordinator: NavigationCoordinator): boolean {\n    return this.coordinators[this.coordinators.length - 1] === coordinator;\n  }\n\n  /**\n   * For debug purposes.\n   */\n  public toString(): string {\n    const contentName = this.getContent()?.instruction.component.name ?? '';\n    const nextContentName = this.getNextContent()?.instruction.component.name ?? '';\n    return `v:${this.name}[${contentName}->${nextContentName}]`;\n  }\n\n  /**\n   * Set the next content for the viewport. Returns the action that the viewport\n   * will take when the navigation coordinator starts the transition. Note that a\n   * swap isn't guaranteed, current component configuration can result in a skipped\n   * transition.\n   *\n   * @param instruction - The routing instruction describing the next content\n   * @param navigation - The navigation that requests the content change\n   */\n  public setNextContent(instruction: RoutingInstruction, navigation: Navigation): TransitionAction {\n    instruction.endpoint.set(this);\n    this.clear = instruction.isClear(this.router);\n\n    const content = this.getContent();\n    // Can have a (resolved) type or a string (to be resolved later)\n    const nextContent = new ViewportContent(this.router, this, this.owningScope, this.scope.hasScope, !this.clear ? instruction : void 0, navigation, this.connectedCE ?? null);\n    this.contents.push(nextContent);\n\n    nextContent.fromHistory = nextContent.componentInstance !== null && navigation.navigation != null\n      ? !!navigation.navigation.back || !!navigation.navigation.forward\n      : false;\n\n    if (this.options.stateful) {\n      // TODO: Add a parameter here to decide required equality\n      const cached = this.cache.find((item) => nextContent.isCacheEqual(item));\n      if (cached !== void 0) {\n        this.contents.splice(this.contents.indexOf(nextContent), 1, cached);\n        nextContent.fromCache = true;\n      } else {\n        this.cache.push(nextContent);\n      }\n    }\n\n    // If we get the same _instance_, don't do anything (happens with cached and history)\n    if (nextContent.componentInstance !== null && content.componentInstance === nextContent.componentInstance) {\n      nextContent.delete();\n      this.contents.splice(this.contents.indexOf(nextContent), 1);\n      return this.transitionAction = 'skip';\n    }\n\n    if (!content.equalComponent(nextContent) ||\n      navigation.navigation.refresh || // Navigation 'refresh' performed\n      content.reloadBehavior === 'refresh' // ReloadBehavior 'refresh' takes precedence\n    ) {\n      return this.transitionAction = 'swap';\n    }\n\n    // If we got here, component is the same name/type\n\n    // Explicitly don't allow navigation back to the same component again\n    if (content.reloadBehavior === 'disallow') {\n      nextContent.delete();\n      this.contents.splice(this.contents.indexOf(nextContent), 1);\n      return this.transitionAction = 'skip';\n    }\n\n    // Explicitly re-load same component again\n    // TODO(alpha): NEED TO CHECK THIS TOWARDS activeContent REGARDING scope\n    if (content.reloadBehavior === 'reload') {\n      content.reload = true;\n\n      nextContent.instruction.component.set(content.componentInstance);\n      nextContent.contentStates = content.contentStates.clone();\n      nextContent.reload = content.reload;\n      return this.transitionAction = 'reload';\n    }\n\n    // ReloadBehavior is now 'default'\n\n    // Requires updated parameters if viewport stateful\n    if (this.options.stateful && content.equalParameters(nextContent)) {\n      nextContent.delete();\n      this.contents.splice(this.contents.indexOf(nextContent), 1);\n      return this.transitionAction = 'skip';\n    }\n\n    if (!content.equalParameters(nextContent)) {\n      // TODO: Fix a config option for this\n      // eslint-disable-next-line no-constant-condition\n      if (false) { // Re-use component, only reload with new parameters\n        content.reload = true;\n        nextContent.instruction.component.set(content.componentInstance);\n        nextContent.contentStates = content.contentStates.clone();\n        nextContent.reload = content.reload;\n        return this.transitionAction = 'reload';\n      } else { // Perform a full swap\n        return this.transitionAction = 'swap';\n      }\n    }\n\n    // Default is to do nothing\n    nextContent.delete();\n    this.contents.splice(this.contents.indexOf(nextContent), 1);\n    return this.transitionAction = 'skip';\n  }\n\n  /**\n   * Connect a ViewportCustomElement to this viewport endpoint, applying options\n   * while doing so.\n   *\n   * @param connectedCE - The custom element to connect\n   * @param options - The options to apply\n   */\n  public setConnectedCE(connectedCE: IConnectedCustomElement, options: IViewportOptions): void {\n    options = options ?? {};\n    if (this.connectedCE !== connectedCE) {\n      // TODO: Restore this state on navigation cancel\n      this.previousViewportState = { ...this };\n      this.clearState();\n      this.connectedCE = connectedCE;\n      this.options.apply(options);\n      this.connectionResolve?.();\n    }\n\n    const parentDefaultRoute = (this.scope.parent?.endpoint.getRoutes() ?? [])\n      .filter(route => (Array.isArray(route.path) ? route.path : [route.path]).includes(''))\n      .length > 0;\n\n    if (this.getContent().componentInstance === null\n      && this.getNextContent()?.componentInstance == null\n      && (this.options.default || parentDefaultRoute)\n    ) {\n      const instructions = RoutingInstruction.parse(this.router, this.options.default ?? '');\n\n      if (instructions.length === 0 && parentDefaultRoute) {\n        const foundRoute = this.scope.parent?.findInstructions(\n          [RoutingInstruction.create('') as RoutingInstruction],\n          false,\n          this.router.configuration.options.useConfiguredRoutes\n        );\n\n        if (foundRoute?.foundConfiguration) {\n          instructions.push(...foundRoute.instructions);\n        }\n      }\n\n      for (const instruction of instructions) {\n        // Set to name to be delayed one turn (refactor: not sure why, so changed it)\n        instruction.endpoint.set(this);\n        instruction.scope = this.owningScope;\n        instruction.default = true;\n      }\n      this.router.load(instructions, { append: true }).catch(error => { throw error; });\n    }\n  }\n\n  // TODO(alpha): Look into this!\n  public remove(step: Step | null, connectedCE: IConnectedCustomElement | null): boolean | Promise<boolean> {\n    // TODO: Review this: should it go from promise to value somewhere?\n    if (this.connectedCE === connectedCE) {\n      return Runner.run(step,\n        (innerStep: Step<void>) => {\n          if (this.getContent().componentInstance !== null) {\n            return this.getContent().freeContent(\n              innerStep,\n              this.connectedCE,\n              (this.getNextContent()?.navigation ?? null),\n              this.historyCache,\n              this.doForceRemove ? false : this.router.statefulHistory || this.options.stateful\n            ); // .catch(error => { throw error; });\n          }\n        },\n        (innerStep: Step<void>) => {\n          if (this.doForceRemove) {\n            const removes = [];\n            for (const content of this.historyCache) {\n              removes.push((innerInnerStep: Step<void>) => content.freeContent(\n                innerInnerStep,\n                null,\n                null,\n                this.historyCache,\n                false,\n              ));\n            }\n            removes.push(() => { this.historyCache = []; });\n            return Runner.run(innerStep,\n              ...removes,\n            );\n          }\n          return true;\n        }\n      ) as boolean | Promise<boolean>;\n    }\n    return false;\n  }\n\n  /**\n   * Transition from current content to the next.\n   *\n   * @param coordinator - The coordinator of the navigation\n   */\n  public async transition(coordinator: NavigationCoordinator): Promise<void> {\n    const navigatingPrefix = this.router.configuration.options.indicators.viewportNavigating;\n\n    this.coordinators.push(coordinator);\n    // If this isn't the first coordinator, a navigation is already in process...\n    while (this.coordinators[0] !== coordinator) {\n      // ...so first wait for it to finish.\n      await this.coordinators[0].waitForSyncState('completed');\n    }\n\n    // Get the parent viewport...\n    let actingParentViewport = this.parentViewport;\n    // ...but not if it's not acting (reloading or swapping)\n    if (actingParentViewport !== null\n      && actingParentViewport.transitionAction !== 'reload'\n      && actingParentViewport.transitionAction !== 'swap'\n    ) {\n      actingParentViewport = null;\n    }\n    // If actingParentViewport has a value, that viewport's routing\n    // hooks needs to be awaited before starting this viewport's\n    // corresponding routing hook.\n\n    // First create a list with the steps that should run in the order\n    // they should run and then, at the end, run them. Each hook step\n    // registers its completeness with the navigation coordinator, which\n    // keeps track of entity/endpoint transition states and restrictions\n    // as well as pausing continuation if needed.\n\n    // The transition guard hooks, canUnload and canLoad, both of which\n    // can cancel the entire navigation\n    const guardSteps = [\n      (step: Step<boolean>) => {\n        if (this.isActiveNavigation(coordinator)) {\n          return this.canUnload(coordinator, step);\n        }\n      },\n\n      (step: Step<boolean>) => {\n        if (this.isActiveNavigation(coordinator)) {\n          if ((step.previousValue ?? true) === false) { // canUnloadResult: boolean\n            // step.cancel();\n            coordinator.cancel();\n          }\n        }\n      },\n\n      (step: Step<boolean>) => {\n        if (this.isActiveNavigation(coordinator)) {\n          return RoutingInstruction.resolve([this.getNavigationContent(coordinator)!.instruction]);\n        }\n      },\n\n      (step: Step<boolean>) => {\n        if (this.isActiveNavigation(coordinator)) {\n          if (this.router.isRestrictedNavigation) { // Create the component early if restricted navigation\n            const routerOptions = this.router.configuration.options;\n            return this.getNavigationContent(coordinator)!.createComponent(\n              coordinator,\n              this.connectedCE!,\n              this.options.fallback || routerOptions.fallback,\n              this.options.fallbackAction || routerOptions.fallbackAction);\n          }\n        }\n      },\n\n      () => coordinator.addEndpointState(this, 'guardedUnload'),\n      () => coordinator.waitForSyncState('guardedUnload', this), // Awaits all `canUnload` hooks\n      () => actingParentViewport !== null ? coordinator.waitForEndpointState(actingParentViewport, 'guardedLoad') : void 0, // Awaits parent `canLoad`\n\n      (step: Step<boolean>) => {\n        if (this.isActiveNavigation(coordinator)) {\n          return this.canLoad(coordinator, step);\n        }\n      },\n\n      (step: Step) => {\n        if (this.isActiveNavigation(coordinator)) {\n          let canLoadResult = (step.previousValue ?? true) as boolean | LoadInstruction | LoadInstruction[];\n          if (typeof canLoadResult === 'boolean') { // canLoadResult: boolean | LoadInstruction | LoadInstruction[],\n            if (!canLoadResult) {\n              step.cancel();\n              coordinator.cancel();\n              const instruction = this.getNavigationContent(coordinator)!.instruction;\n              coordinator.removeInstructions(instruction.dynasty);\n              instruction.nextScopeInstructions = null;\n              return;\n            }\n          } else { // Denied and (probably) redirected\n            const instruction = this.getNavigationContent(coordinator)!.instruction;\n            coordinator.removeInstructions(instruction.dynasty);\n            instruction.nextScopeInstructions = null;\n            if (typeof canLoadResult === 'string') {\n              const scope = this.scope;\n              const options = this.router.configuration.options;\n              let instructions = RoutingInstruction.parse(this.router, canLoadResult);\n              const foundRoute = scope.parent?.findInstructions(instructions, options.useDirectRouting, options.useConfiguredRoutes);\n              if (foundRoute?.foundConfiguration || foundRoute?.foundInstructions) {\n                instructions = foundRoute.instructions;\n              }\n              for (const instruction of instructions) {\n                instruction.endpoint.set(this);\n                instruction.scope = scope.owningScope;\n              }\n              canLoadResult = instructions;\n            }\n            return Runner.run(step,\n              () => {\n                void this.router.load(canLoadResult, { append: coordinator });\n              },\n              (innerStep: Step<void>) => this.cancelContentChange(coordinator, innerStep),\n              () => RoutingInstruction.resolve(canLoadResult as RoutingInstruction[]),\n              (innerStep: Step<void>) => {\n                return innerStep.exit();\n              },\n            );\n          }\n        }\n        coordinator.addEndpointState(this, 'guardedLoad');\n        coordinator.addEndpointState(this, 'guarded');\n      },\n    ];\n\n    // The transition routing hooks, unloading and loading\n    const routingSteps = [\n      () => coordinator.waitForSyncState('guarded', this),\n      (step: Step<void>) => {\n        if (this.isActiveNavigation(coordinator)) {\n          return this.unload(coordinator, step);\n        }\n      },\n      () => coordinator.addEndpointState(this, 'unloaded'),\n\n      () => coordinator.waitForSyncState('unloaded', this),\n      () => actingParentViewport !== null ? coordinator.waitForEndpointState(actingParentViewport, 'loaded') : void 0,\n      (step: Step<void>) => {\n        if (this.isActiveNavigation(coordinator)) {\n          return this.load(coordinator, step);\n        }\n      },\n      () => coordinator.addEndpointState(this, 'loaded'),\n      () => coordinator.addEndpointState(this, 'routed'),\n    ];\n\n    // The lifecycle hooks, with order and parallelism based on configuration\n    const lifecycleSteps: ((step: Step<void | void[]>) => Step<void> | Promise<void> | void)[] = [\n      () => coordinator.waitForSyncState('routed', this),\n      () => coordinator.waitForEndpointState(this, 'routed'),\n    ];\n\n    const swapOrder = this.router.configuration.options.swapOrder;\n    switch (swapOrder) {\n      case 'detach-current-attach-next':\n        lifecycleSteps.push(\n          (step) => { if (this.isActiveNavigation(coordinator)) { return this.removeContent(step as Step<void>, coordinator); } },\n          (step) => { if (this.isActiveNavigation(coordinator)) { return this.addContent(step as Step<void>, coordinator); } },\n        );\n        break;\n      case 'attach-next-detach-current':\n        lifecycleSteps.push(\n          (step) => { if (this.isActiveNavigation(coordinator)) { return this.addContent(step as Step<void>, coordinator); } },\n          (step) => { if (this.isActiveNavigation(coordinator)) { return this.removeContent(step as Step<void>, coordinator); } },\n        );\n        break;\n      case 'detach-attach-simultaneously':\n        lifecycleSteps.push((step): Step<void> =>\n          Runner.runParallel(step,\n            (innerStep: Step<void>) => { if (this.isActiveNavigation(coordinator)) { return this.removeContent(innerStep, coordinator); } },\n            (innerStep: Step<void>) => { if (this.isActiveNavigation(coordinator)) { return this.addContent(innerStep, coordinator); } },\n          ) as Step<void>,\n        );\n        break;\n      case 'attach-detach-simultaneously':\n        lifecycleSteps.push((step): Step<void> =>\n          Runner.runParallel(step,\n            (innerStep: Step<void>) => { if (this.isActiveNavigation(coordinator)) { return this.addContent(innerStep, coordinator); } },\n            (innerStep: Step<void>) => { if (this.isActiveNavigation(coordinator)) { return this.removeContent(innerStep, coordinator); } },\n          ) as Step<void>,\n        );\n        break;\n    }\n\n    lifecycleSteps.push(() => coordinator.addEndpointState(this, 'swapped'));\n\n    // Set activity indicator (class) on the connected custom element\n    this.connectedCE?.setActivity?.(navigatingPrefix, true);\n    this.connectedCE?.setActivity?.(coordinator.navigation.navigation, true);\n\n    // Run the steps and do the transition\n    const result = Runner.run('transition',\n      (step: Step<void>) => coordinator.setEndpointStep(this, step.root),\n      ...guardSteps,\n      ...routingSteps,\n      ...lifecycleSteps,\n      () => coordinator.addEndpointState(this, 'completed'),\n      () => coordinator.waitForSyncState('bound'),\n      () => {\n        this.connectedCE?.setActivity?.(navigatingPrefix, false);\n        this.connectedCE?.setActivity?.(coordinator.navigation.navigation, false);\n      },\n    );\n\n    if (result instanceof Promise) {\n      result.catch(_err => { /* Happens when unload or load is prevented. TODO: React? */ });\n    }\n  }\n\n  /**\n   * Check if the current content can be unloaded.\n   *\n   * @param step - The previous step in this transition Run\n   */\n  public canUnload(coordinator: NavigationCoordinator, step: Step<boolean> | null): boolean | Promise<boolean> {\n    return Runner.run(step,\n      (innerStep: Step<boolean>) => {\n        return this.getContent().connectedScope.canUnload(coordinator, innerStep);\n      },\n      (innerStep: Step<boolean>) => {\n        if ((innerStep.previousValue ?? true) === false) { // canUnloadChildren\n          return false;\n        }\n        return this.getContent().canUnload(coordinator.navigation);\n      },\n    ) as boolean | Promise<boolean>;\n  }\n\n  /**\n   * Check if the next content can be loaded.\n   *\n   * @param step - The previous step in this transition Run\n   */\n  public canLoad(coordinator: NavigationCoordinator, step: Step<boolean>): boolean | LoadInstruction | LoadInstruction[] | Promise<boolean | LoadInstruction | LoadInstruction[]> {\n    if (this.clear) {\n      return true;\n    }\n\n    return Runner.run(step,\n      () => this.waitForConnected(),\n      () => {\n        const routerOptions = this.router.configuration.options;\n        const navigationContent = this.getNavigationContent(coordinator)!;\n        return navigationContent.createComponent(\n          coordinator,\n          this.connectedCE!,\n          this.options.fallback || routerOptions.fallback,\n          this.options.fallbackAction || routerOptions.fallbackAction);\n      },\n      () => this.getNavigationContent(coordinator)!.canLoad(),\n    ) as boolean | LoadInstruction | LoadInstruction[] | Promise<boolean | LoadInstruction | LoadInstruction[]>;\n  }\n\n  /**\n   * Load the next content.\n   *\n   * @param step - The previous step in this transition Run\n   */\n  public load(coordinator: NavigationCoordinator, step: Step<void>): Step<void> | void {\n    if (this.clear) {\n      return;\n    }\n\n    return this.getNavigationContent(coordinator)!.load(step);\n  }\n\n  /**\n   * Add (activate) the next content.\n   *\n   * @param step - The previous step in this transition Run\n   * @param coordinator - The navigation coordinator\n   */\n  public addContent(step: Step<void>, coordinator: NavigationCoordinator): void | Step<void> {\n    return this.activate(step, null, this.connectedController, coordinator);\n  }\n\n  /**\n   * Remove (deactivate) the current content.\n   *\n   * @param step - The previous step in this transition Run\n   * @param coordinator - The navigation coordinator\n   */\n  public removeContent(step: Step<void> | null, coordinator: NavigationCoordinator): void | Step<void> {\n    if (this.isEmpty) {\n      return;\n    }\n\n    const manualDispose = this.router.statefulHistory || (this.options.stateful ?? false);\n    return Runner.run(step,\n      // TODO: This also needs to be added when coordinator isn't active (and\n      // this method isn't called)\n      () => coordinator.addEndpointState(this, 'bound'),\n      () => coordinator.waitForSyncState('bound'),\n      (innerStep: Step<void>) => this.deactivate(\n        innerStep,\n        null,\n        this.connectedController,\n      ),\n      () => manualDispose ? this.dispose() : void 0,\n    ) as Step<void>;\n  }\n\n  /**\n   * Activate the next content component, running `load` first. (But it only\n   * runs if it's not already run.) Called both when transitioning and when\n   * the custom element triggers it.\n   *\n   * @param step - The previous step in this transition Run\n   * @param initiator - The controller that initiates the activate\n   * @param parent - The parent controller\n   * @param flags - The lifecycle flags for `activate`\n   * @param coordinator - The navigation coordinator\n   */\n  public activate(step: Step<void> | null, initiator: IHydratedController | null, parent: IHydratedParentController | null, coordinator: NavigationCoordinator | undefined): void | Step<void> {\n    if ((this.activeContent as ViewportContent).componentInstance !== null) {\n      return Runner.run(step,\n        () => (this.activeContent as ViewportContent).canLoad(), // Only acts if not already checked\n        (innerStep: Step<void>) => (this.activeContent as ViewportContent).load(innerStep), // Only acts if not already loaded\n        (innerStep: Step<void>) => (this.activeContent as ViewportContent).activateComponent(\n          innerStep,\n          initiator,\n          parent as ICustomElementController,\n          this.connectedCE!,\n          // TODO: This also needs to be added when coordinator isn't active (and\n          // this method isn't called)\n          () => coordinator?.addEndpointState(this, 'bound'),\n          coordinator?.waitForSyncState('bound'),\n        ),\n      ) as Step<void>;\n    }\n  }\n\n  /**\n   * Deactivate the current content component. Called both when\n   * transitioning and when the custom element triggers it.\n   *\n   * @param initiator - The controller that initiates the deactivate\n   * @param parent - The parent controller\n   * @param flags - The lifecycle flags for `deactivate`\n   */\n  public deactivate(step: Step<void> | null, initiator: IHydratedController | null, parent: IHydratedParentController | null): void | Promise<void> {\n    const content = this.getContent();\n    if (content?.componentInstance != null &&\n      !content.reload &&\n      content.componentInstance !== this.getNextContent()?.componentInstance) {\n\n      return content.deactivateComponent(\n        step,\n        initiator,\n        parent as ICustomElementController,\n        this.connectedCE!,\n        this.router.statefulHistory || this.options.stateful\n      ) as Promise<void>;\n    }\n  }\n\n  /**\n   * Unload the current content.\n   *\n   * @param step - The previous step in this transition Run\n   */\n  public unload(coordinator: NavigationCoordinator, step: Step<void> | null): void | Step<void> {\n    return Runner.run(step,\n      (unloadStep: Step<void>) => this.getContent().connectedScope.unload(coordinator, unloadStep),\n      () => this.getContent().componentInstance != null ? this.getContent().unload(coordinator.navigation ?? null) : void 0,\n    ) as Step<void>;\n  }\n\n  /**\n   * Dispose the current content.\n   */\n  public dispose(): void {\n    if (this.getContent().componentInstance !== null &&\n      !this.getContent().reload &&\n      this.getContent().componentInstance !== this.getNextContent()?.componentInstance) {\n      this.getContent().disposeComponent(\n        this.connectedCE!,\n        this.historyCache,\n        this.router.statefulHistory || this.options.stateful\n      );\n    }\n  }\n\n  /**\n   * Finalize the change of content by making the next content the current\n   * content. The previously current content is deleted.\n   */\n  public finalizeContentChange(coordinator: NavigationCoordinator, step: Step<void> | null): void | Step<void> {\n    const nextContentIndex = this.contents.findIndex(content => content.navigation === coordinator.navigation);\n    let nextContent = this.contents[nextContentIndex];\n    const previousContent = this.contents[nextContentIndex - 1];\n    // const previousContents = this.contents.slice(0, nextContentIndex);\n\n    if (this.clear) {\n      const emptyContent = new ViewportContent(this.router, this, this.owningScope, this.scope.hasScope, void 0, nextContent.navigation);\n      this.contents.splice(nextContentIndex, 1, emptyContent);\n      nextContent.delete();\n      nextContent = emptyContent;\n    } else {\n      nextContent.reload = false;\n    }\n\n    previousContent.delete();\n\n    // TODO: Fix this so that multiple removes work!\n    // const freeSteps = [];\n    // for (const previousContent of previousContents) {\n    //   freeSteps.push(\n    //     (innerStep: Step<void>) => {\n    //       // return previousContent.freeContent(\n    //       //   innerStep,\n    //       //   this.connectedCE,\n    //       //   previousContent.navigation,\n    //       //   this.historyCache,\n    //       //   this.router.statefulHistory || this.options.stateful)\n    //     },\n    //     () => previousContent.delete(),\n    //   );\n    // }\n\n    // return Runner.run(step,\n    //   ...freeSteps,\n    //   () => {\n    // if (nextContent !== null) {\n    nextContent.completed = true;\n    // }\n    this.transitionAction = '';\n\n    nextContent.contentStates.delete('checkedUnload');\n    nextContent.contentStates.delete('checkedLoad');\n\n    this.previousViewportState = null;\n\n    const navigatingPrefix = this.router.configuration.options.indicators.viewportNavigating;\n    this.connectedCE?.setActivity?.(navigatingPrefix, false);\n    this.connectedCE?.setActivity?.(coordinator.navigation.navigation, false);\n\n    let removeable = 0;\n    for (let i = 0, ii = nextContentIndex; i < ii; i++) {\n      if (!(this.contents[0].navigation.completed ?? false)) {\n        break;\n      }\n      removeable++;\n    }\n    this.contents.splice(0, removeable);\n\n    arrayRemove(this.coordinators, (coord => coord === coordinator));\n    //   }\n    // ) as Step<void>;\n  }\n\n  /**\n   * Cancel the change of content. The next content is freed/discarded.\n   *\n   * @param step - The previous step in this transition Run\n   */\n  public cancelContentChange(coordinator: NavigationCoordinator, noExitStep: Step<void> | null = null): void | Step<void> {\n    // First cancel content change in all children\n    [...new Set(this.scope.children.map(scope => scope.endpoint))].forEach(child => child.cancelContentChange(coordinator, noExitStep));\n\n    const nextContentIndex = this.contents.findIndex(content => content.navigation === coordinator.navigation);\n    if (nextContentIndex < 0) {\n      return;\n    }\n\n    const step = coordinator.getEndpointStep(this)?.current ?? null;\n    const nextContent = this.contents[nextContentIndex];\n    const previousContent = this.contents[nextContentIndex - 1];\n\n    nextContent.instruction.cancelled = true;\n\n    return Runner.run(step,\n      (innerStep: Step<void>) => {\n        return nextContent.freeContent(\n          innerStep,\n          this.connectedCE,\n          nextContent.navigation,\n          this.historyCache,\n          this.router.statefulHistory || this.options.stateful);\n      },\n      () => {\n        if (this.previousViewportState) {\n          Object.assign(this, this.previousViewportState);\n        }\n        nextContent?.delete();\n        if (nextContent !== null) {\n          this.contents.splice(this.contents.indexOf(nextContent), 1);\n        }\n        this.transitionAction = '';\n\n        previousContent?.contentStates.delete('checkedUnload');\n        previousContent?.contentStates.delete('checkedLoad');\n\n        const navigatingPrefix = this.router.configuration.options.indicators.viewportNavigating;\n        this.connectedCE?.setActivity?.(navigatingPrefix, false);\n        this.connectedCE?.setActivity?.(coordinator.navigation.navigation, false);\n\n        coordinator.removeEndpoint(this);\n\n        arrayRemove(this.coordinators, (coord => coord === coordinator));\n      },\n      () => {\n        if (step !== noExitStep) {\n          return step?.exit();\n        }\n      }\n    ) as Step<void>;\n  }\n\n  /**\n   * Whether the viewport wants a specific component. Used when\n   * matching routing instructions to viewports.\n   *\n   * @param component - The component to check\n   *\n   * TODO: Deal with non-string components\n   */\n  public wantComponent(component: ComponentAppellation): boolean {\n    return this.options.usedBy.includes(component as string);\n  }\n\n  /**\n   * Whether the viewport accepts a specific component. Used when\n   * matching routing instructions to viewports.\n   *\n   * @param component - The component to check\n   *\n   * TODO: Deal with non-string components\n   */\n  public acceptComponent(component: ComponentAppellation): boolean {\n    if (component === '-' || component === null) {\n      return true;\n    }\n    const usedBy = this.options.usedBy;\n    if (usedBy.length === 0) {\n      return true;\n    }\n    if (usedBy.includes(component as string)) {\n      return true;\n    }\n    if (usedBy.filter((value) => value.includes('*')).length) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Free/discard a history cached content containing a specific component.\n   *\n   * @param step - The previous step in this transition Run\n   * @param component - The component to look for\n   *\n   * TODO: Deal with multiple contents containing the component\n   */\n  public freeContent(step: Step<void> | null, component: IRouteableComponent): void | Promise<void> | Step<void> {\n    const content = this.historyCache.find(cached => cached.componentInstance === component);\n    if (content !== void 0) {\n      return Runner.run(step,\n        (innerStep: Step<void>) => {\n          this.forceRemove = true;\n          return content.freeContent(\n            innerStep,\n            null,\n            null,\n            this.historyCache,\n            false,\n          );\n        },\n        () => {\n          this.forceRemove = false;\n          arrayRemove(this.historyCache, (cached => cached === content));\n        },\n      );\n    }\n  }\n\n  /**\n   * Get any configured routes in the relevant content's component type.\n   */\n  public getRoutes(): Route[] {\n    const routes = [];\n    let componentType = this.getComponentType();\n    if (componentType != null) {\n      componentType = componentType.constructor === componentType.constructor.constructor\n        ? componentType\n        : componentType.constructor as RouteableComponentType;\n\n      routes.push(...(Routes.getConfiguration(componentType) ?? []));\n    }\n    return routes;\n  }\n\n  /**\n   * Get the title for the content.\n   *\n   * @param navigation - The navigation that requests the content change\n   */\n  public getTitle(navigation: Navigation): string {\n    if (this.options.noTitle) {\n      return '';\n    }\n    const componentType = this.getComponentType();\n    if (componentType === null) {\n      return '';\n    }\n    let title = '';\n    const typeTitle = componentType.title;\n    if (typeTitle !== void 0) {\n      if (typeof typeTitle === 'string') {\n        title = typeTitle;\n      } else {\n        const component = this.getComponentInstance();\n        title = typeTitle.call(component, component!, navigation);\n      }\n    } else if (this.router.configuration.options.title.useComponentNames) {\n      let name = this.getContentInstruction()!.component.name ?? '';\n      // TODO(alpha): Allow list of component prefixes\n      const prefix = (this.router.configuration.options.title.componentPrefix ?? '') as string;\n      if (name.startsWith(prefix)) {\n        name = name.slice(prefix.length);\n      }\n      name = name.replace('-', ' ');\n      title = name.slice(0, 1).toLocaleUpperCase() + name.slice(1);\n    }\n    return title;\n  }\n\n  /**\n   * Get component type of the relevant, current or next, content.\n   */\n  private getComponentType(): RouteableComponentType | null {\n    let componentType = this.getContentInstruction()!.component.type ?? null;\n    if (componentType === null) {\n      const controller = CustomElement.for(this.connectedCE!.element);\n      componentType = (controller.container as\n        IContainer & { componentType: RouteableComponentType })\n        .componentType;\n    }\n    return componentType ?? null;\n  }\n\n  /**\n   * Get component instance of the relevant, current or next, content.\n   */\n  private getComponentInstance(): IRouteableComponent | null {\n    return this.getContentInstruction()!.component.instance ?? null;\n  }\n\n  /**\n   * Get routing instruction of the relevant, current or next, content.\n   */\n  private getContentInstruction(): RoutingInstruction | null {\n    return this.getNextContent()?.instruction ?? this.getContent().instruction ?? null;\n  }\n\n  /**\n   * Clear the viewport state.\n   *\n   * TODO: Investigate the need.\n   */\n  private clearState(): void {\n    this.options = ViewportOptions.create();\n\n    const owningScope = this.owningScope;\n    const hasScope = this.scope.hasScope;\n    this.getContent().delete();\n    this.contents.shift();\n\n    if (this.contents.length < 1) {\n      throw new Error('no content!');\n    }\n\n    this.contents.push(new ViewportContent(this.router, this, owningScope, hasScope));\n    this.cache = [];\n  }\n\n  /**\n   * If necessary, get a promise to await until a custom element connects.\n   */\n  private waitForConnected(): void | Promise<void> {\n    if (this.connectedCE === null) {\n      return new Promise((resolve) => {\n        this.connectionResolve = resolve;\n      });\n    }\n  }\n}\n", "import { IRouter } from '../router';\nimport { Endpoint, EndpointTypeName } from '../endpoints/endpoint';\nimport { RoutingScope } from '../routing-scope';\nimport { Viewport } from '../endpoints/viewport';\nimport { ViewportScope } from '../endpoints/viewport-scope';\n\n/**\n * Public API - The routing instructions are the core of the router's navigations\n */\n\nexport type EndpointHandle = string | Endpoint;\n\nexport class InstructionEndpoint {\n  public name: string | null = null;\n  public instance: Endpoint | null = null;\n\n  public scope: RoutingScope | null = null;\n\n  public get none(): boolean {\n    return this.name === null && this.instance === null;\n  }\n\n  public get endpointType(): EndpointTypeName | null {\n    if (this.instance instanceof Viewport) {\n      return 'Viewport';\n    }\n    if (this.instance instanceof ViewportScope) {\n      return 'ViewportScope';\n    }\n    return null;\n  }\n\n  public static create(endpointHandle?: EndpointHandle | null): InstructionEndpoint {\n    const endpoint = new InstructionEndpoint();\n    endpoint.set(endpointHandle);\n    return endpoint;\n  }\n\n  public static isName(endpoint: EndpointHandle): endpoint is string {\n    return typeof endpoint === 'string';\n  }\n  public static isInstance(endpoint: EndpointHandle): endpoint is Endpoint {\n    return endpoint instanceof Endpoint;\n  }\n  public static getName(endpoint: EndpointHandle): string | null {\n    if (InstructionEndpoint.isName(endpoint)) {\n      return endpoint;\n    } else {\n      return endpoint ? (endpoint).name : null;\n    }\n  }\n  public static getInstance(endpoint: EndpointHandle): Endpoint | null {\n    if (InstructionEndpoint.isName(endpoint)) {\n      return null;\n    } else {\n      return endpoint;\n    }\n  }\n\n  public set(endpoint?: EndpointHandle | null): void {\n    if (endpoint === undefined || endpoint === '') {\n      endpoint = null;\n    }\n    if (typeof endpoint === 'string') {\n      this.name = endpoint;\n      this.instance = null;\n    } else {\n      this.instance = endpoint;\n      if (endpoint !== null) {\n        this.name = endpoint.name;\n        this.scope = endpoint.owningScope;\n      }\n    }\n  }\n\n  public toInstance(router: IRouter): Endpoint | null {\n    if (this.instance !== null) {\n      return this.instance;\n    }\n    return router.getEndpoint(this.endpointType as EndpointTypeName, this.name as string) as Endpoint | null;\n  }\n\n  public same(other: InstructionEndpoint, compareScope: boolean): boolean {\n    if (this.instance !== null && other.instance !== null) {\n      return this.instance === other.instance;\n    }\n    return (this.endpointType !== null &&\n      other.endpointType !== null &&\n      this.endpointType === other.endpointType\n    ) &&\n      (!compareScope || this.scope === other.scope) &&\n      (this.instance !== null ? this.instance.name : this.name) ===\n      (other.instance !== null ? other.instance.name : other.name);\n  }\n}\n", "import { InstructionParser } from './instruction-parser';\nimport { InstructionParameters, Parameters } from './instruction-parameters';\nimport { InstructionComponent } from './instruction-component';\nimport { ComponentAppellation, ComponentParameters, LoadInstruction } from '../interfaces';\nimport { RoutingScope } from '../routing-scope';\nimport { ViewportScope } from '../endpoints/viewport-scope';\nimport { FoundRoute } from '../found-route';\nimport { Endpoint, EndpointType } from '../endpoints/endpoint';\nimport { Viewport } from '../endpoints/viewport';\nimport { CustomElement } from '@aurelia/runtime-html';\nimport { IRouter, IRouterConfiguration, Navigation, Route } from '../index';\nimport { EndpointHandle, InstructionEndpoint } from './instruction-endpoint';\nimport { Separators } from '../router-options';\nimport { IContainer } from '@aurelia/kernel';\n\nexport interface IRoutingInstructionStringifyOptions {\n  excludeEndpoint?: boolean;\n  endpointContext?: boolean;\n  fullState?: boolean;\n}\n\nconst RoutingInstructionStringifyOptionsDefaults: IRoutingInstructionStringifyOptions = {\n  excludeEndpoint: false,\n  endpointContext: false,\n  fullState: false,\n};\n\n/**\n * The routing instructions are the core of the router's navigations. All\n * navigation instructions to the router are translated to a set of\n * routing instructions. The routing instructions are resolved \"non-early\"\n * to support dynamic, local resolutions.\n *\n * Routing instructions are used to represent the full navigation state\n * and is serialized when storing and restoring the navigation state. (But\n * not full component state with component instance state. ViewportContent\n * is used for that.)\n */\nexport class RoutingInstruction {\n  /**\n   * The component part of the routing instruction.\n   */\n  public component: InstructionComponent;\n\n  /**\n   * The endpoint part of the routing instruction.\n   */\n  public endpoint: InstructionEndpoint;\n\n  /**\n   * The parameters part of the routing instruction.\n   */\n  public parameters: InstructionParameters;\n\n  /**\n   * Whether the routing instruction owns its scope.\n   */\n  public ownsScope: boolean = true;\n\n  /**\n   * The routing instructions in the next scope (\"children\").\n   */\n  public nextScopeInstructions: RoutingInstruction[] | null = null;\n\n  /**\n   * The scope the the routing instruction belongs to.\n   */\n  public scope: RoutingScope | null = null;\n\n  /**\n   * The scope modifier of the routing instruction.\n   */\n  public scopeModifier: string = '';\n\n  /**\n   * Whether the routing instruction can be resolved within the scope without having\n   * endpoint specified. Used when creating string instructions/links/url.\n   */\n  public needsEndpointDescribed: boolean = false;\n\n  /**\n   * The configured route, if any, that the routing instruction is part of.\n   */\n  public route: FoundRoute | string | null = null;\n\n  /**\n   * The instruction is the start/first instruction of a configured route.\n   */\n  public routeStart: boolean = false;\n\n  /**\n   * Whether the routing instruction is the result of a (viewport) default (meaning it\n   * has lower priority when processing instructions).\n   */\n  public default: boolean = false;\n\n  /**\n   * Whether the routing instruction is the top instruction in its routing instruction\n   * hierarchy. Used when syncing swap of all (top) instructions.\n   */\n  public topInstruction: boolean = false;\n\n  /**\n   * The string, if any, that was used to parse the instruction. Includes anything\n   * in the string after the actual part for the instruction itself.\n   */\n  public unparsed: string | null = null;\n\n  /**\n   * Whether the routing instruction has been cancelled (aborted) for some reason\n   */\n  public cancelled: boolean = false;\n\n  public constructor(\n    component?: ComponentAppellation | Promise<ComponentAppellation>,\n    endpoint?: EndpointHandle,\n    parameters?: ComponentParameters,\n  ) {\n    this.component = InstructionComponent.create(component);\n    this.endpoint = InstructionEndpoint.create(endpoint);\n    this.parameters = InstructionParameters.create(parameters);\n  }\n\n  /**\n   * Create a new routing instruction.\n   *\n   * @param component - The component (appelation) part of the instruction. Can be a promise\n   * @param endpoint - The endpoint (handle) part of the instruction\n   * @param parameters - The parameters part of the instruction\n   * @param ownScope - Whether the routing instruction owns its scope\n   * @param nextScopeInstructions - The routing instructions in the next scope (\"children\")\n   */\n  public static create(component?: ComponentAppellation | Promise<ComponentAppellation>, endpoint?: EndpointHandle, parameters?: ComponentParameters, ownsScope: boolean = true, nextScopeInstructions: RoutingInstruction[] | null = null): RoutingInstruction | Promise<RoutingInstruction> {\n    const instruction: RoutingInstruction = new RoutingInstruction(component, endpoint, parameters);\n    instruction.ownsScope = ownsScope;\n    instruction.nextScopeInstructions = nextScopeInstructions;\n\n    return instruction;\n  }\n\n  /**\n   * Create a clear endpoint routing instruction.\n   *\n   * @param endpoint - The endpoint to create the clear instruction for\n   */\n  public static createClear(context: IRouterConfiguration | IRouter, endpoint: EndpointType | Endpoint): RoutingInstruction {\n    const instruction = RoutingInstruction.create(RoutingInstruction.clear(context), endpoint) as RoutingInstruction;\n    // Clear instructions should have the scope of the endpoint\n    instruction.scope = endpoint.scope;\n    return instruction;\n  }\n\n  /**\n   * Get routing instructions based on load instructions.\n   *\n   * @param context - The context (used for syntax) within to parse the instructions\n   * @param loadInstructions - The load instructions to get the routing\n   * instructions from.\n   */\n  public static from(context: IRouterConfiguration | IRouter | IContainer, loadInstructions: LoadInstruction | LoadInstruction[]): RoutingInstruction[] {\n    if (!Array.isArray(loadInstructions)) {\n      loadInstructions = [loadInstructions];\n    }\n    const instructions: RoutingInstruction[] = [];\n    for (const instruction of loadInstructions as LoadInstruction[]) {\n      if (typeof instruction === 'string') {\n        instructions.push(...RoutingInstruction.parse(context, instruction));\n      } else if (instruction instanceof RoutingInstruction) {\n        instructions.push(instruction);\n      } else if (instruction instanceof Promise) {\n        instructions.push(RoutingInstruction.create(instruction) as RoutingInstruction);\n      } else if (InstructionComponent.isAppelation(instruction)) {\n        instructions.push(RoutingInstruction.create(instruction) as RoutingInstruction);\n      } else if (InstructionComponent.isDefinition(instruction)) {\n        instructions.push(RoutingInstruction.create(instruction.Type) as RoutingInstruction);\n      } else if ('component' in instruction || 'id' in instruction) {\n        const viewportComponent = instruction;\n        const newInstruction = RoutingInstruction.create(viewportComponent.component, viewportComponent.viewport, viewportComponent.parameters) as RoutingInstruction;\n        newInstruction.route = instruction.id ?? null;\n        if (viewportComponent.children !== void 0 && viewportComponent.children !== null) {\n          newInstruction.nextScopeInstructions = RoutingInstruction.from(context, viewportComponent.children);\n        }\n        instructions.push(newInstruction);\n      } else if (typeof instruction === 'object' && instruction !== null) {\n        const type = CustomElement.define(instruction);\n        instructions.push(RoutingInstruction.create(type) as RoutingInstruction);\n      } else {\n        instructions.push(RoutingInstruction.create(instruction as ComponentAppellation) as RoutingInstruction);\n      }\n    }\n    return instructions;\n  }\n\n  /**\n   * The routing instruction component that represents \"clear\".\n   */\n  public static clear(context: IRouterConfiguration | IRouter): string {\n    return Separators.for(context).clear;\n  }\n\n  /**\n   * The routing instruction component that represents \"add\".\n   */\n  public static add(context: IRouterConfiguration | IRouter): string {\n    return Separators.for(context).add;\n  }\n\n  /**\n   * Parse an instruction string into a list of routing instructions.\n   *\n   * @param context - The context (used for syntax) within to parse the instructions\n   * @param instructions - The instruction string to parse\n   */\n  public static parse(context: IRouterConfiguration | IRouter | IContainer, instructions: string): RoutingInstruction[] {\n    const seps = Separators.for(context);\n    let scopeModifier = '';\n    // Scope modifier is a start with .. or / and any combination thereof\n    const match = /^[./]+/.exec(instructions);\n    // If it starts with a scope modifier...\n    if (Array.isArray(match) && match.length > 0) {\n      // ...save and...\n      scopeModifier = match[0];\n      // ...extract it.\n      instructions = instructions.slice(scopeModifier.length);\n    }\n    // Parse the instructions...\n    const parsedInstructions: RoutingInstruction[] = InstructionParser.parse(seps, instructions, true, true).instructions;\n    for (const instruction of parsedInstructions) {\n      // ...and set the scope modifier on each of them.\n      instruction.scopeModifier = scopeModifier;\n    }\n    return parsedInstructions;\n  }\n\n  /**\n   * Stringify a list of routing instructions, recursively down next scope/child instructions.\n   *\n   * @param context - The context (used for syntax) within to stringify the instructions\n   * @param instructions - The instructions to stringify\n   * @param options - The options for stringifying the instructions\n   * @param endpointContext - Whether to include endpoint context in the string. [Deprecated] Use the new interface instead: { excludeEndpoint: boolean; endpointContext: boolean; }\n   */\n  public static stringify(context: IRouterConfiguration | IRouter | IContainer, instructions: RoutingInstruction[] | string, options: IRoutingInstructionStringifyOptions | boolean = {}, endpointContext: boolean = false): string {\n    if (typeof options === 'boolean') {\n      // eslint-disable-next-line no-console\n      console.warn(`[Deprecated] Boolean passed to RoutingInstruction.stringify. Please use the new interface instead: { excludeEndpoint: boolean; endpointContext: boolean; }`);\n      options = { excludeEndpoint: options, endpointContext };\n    }\n    options = { ...RoutingInstructionStringifyOptionsDefaults, ...options };\n\n    return typeof (instructions) === 'string'\n      ? instructions\n      : instructions\n        .map(instruction => instruction.stringify(context, options))\n        .filter(instruction => instruction.length > 0)\n        .join(Separators.for(context).sibling);\n  }\n\n  /**\n   * Resolve a list of routing instructions, returning a promise that should be awaited if needed.\n   *\n   * @param instructions - The instructions to resolve\n   */\n  public static resolve(instructions: RoutingInstruction[]): void | Promise<void | ComponentAppellation[]> {\n    const resolvePromises = instructions\n      .filter(instr => instr.isUnresolved)\n      .map(instr => instr.resolve())\n      .filter(result => result instanceof Promise);\n    if (resolvePromises.length > 0) {\n      return Promise.all(resolvePromises) as Promise<void | ComponentAppellation[]>;\n    }\n  }\n\n  /**\n   * Whether the instructions, on any level, contains siblings\n   *\n   * @param instructions - The instructions to check\n   */\n  public static containsSiblings(context: IRouterConfiguration | IRouter, instructions: RoutingInstruction[] | null): boolean {\n    if (instructions === null) {\n      return false;\n    }\n    if (instructions\n      .filter(instruction => !instruction.isClear(context) && !instruction.isClearAll(context))\n      .length > 1) {\n      return true;\n    }\n    return instructions.some(instruction => RoutingInstruction.containsSiblings(context, instruction.nextScopeInstructions));\n  }\n\n  /**\n   * Get all routing instructions, recursively down next scope/child instructions, as\n   * a \"flat\" list.\n   *\n   * @param instructions - The instructions to flatten\n   */\n  public static flat(instructions: RoutingInstruction[]): RoutingInstruction[] {\n    const flat: RoutingInstruction[] = [];\n    for (const instruction of instructions) {\n      flat.push(instruction);\n      if (instruction.hasNextScopeInstructions) {\n        flat.push(...RoutingInstruction.flat(instruction.nextScopeInstructions!));\n      }\n    }\n    return flat;\n  }\n\n  /**\n   * Clone a list of routing instructions.\n   *\n   * @param instructions - The instructions to clone\n   * @param keepInstances - Whether actual instances should be transfered\n   * @param scopeModifier - Whether the scope modifier should be transfered\n   */\n  public static clone(instructions: RoutingInstruction[], keepInstances: boolean = false, scopeModifier: boolean = false): RoutingInstruction[] {\n    return instructions.map(instruction => instruction.clone(keepInstances, scopeModifier));\n  }\n\n  /**\n   * Whether a list of routing instructions contains another list of routing\n   * instructions. If deep, all next scope instructions needs to be contained\n   * in containing next scope instructions as well.\n   *\n   * @param context - The context (used for parameter syntax) to compare within\n   * @param instructionsToSearch - Instructions that should contain (superset)\n   * @param instructionsToFind - Instructions that should be contained (subset)\n   * @param deep - Whether next scope instructions also need to be contained (recursively)\n   */\n  public static contains(context: IRouterConfiguration | IRouter | IContainer, instructionsToSearch: RoutingInstruction[], instructionsToFind: RoutingInstruction[], deep: boolean): boolean {\n    // All instructions to find need to exist in instructions to search\n    return instructionsToFind.every(find => find.isIn(context, instructionsToSearch, deep));\n  }\n\n  /**\n   * The endpoint of the routing instruction if it's a viewport OR if\n   * it can't be decided (no instance, just a name).\n   */\n  public get viewport(): InstructionEndpoint | null {\n    return this.endpoint.instance instanceof Viewport ||\n      this.endpoint.endpointType === null\n      ? this.endpoint\n      : null;\n  }\n\n  /**\n   * The endpoint of the routing instruction if it's a viewport scope OR if\n   * it can't be decided (no instance, just a name).\n   */\n  public get viewportScope(): InstructionEndpoint | null {\n    return this.endpoint.instance instanceof ViewportScope ||\n      this.endpoint.endpointType === null\n      ? this.endpoint\n      : null;\n  }\n\n  /**\n   * The previous instruction for the specific endpoint. This can only evaluate\n   * to a value when the instruction has an assigned endpoint. This is a\n   * convenience property in the API.\n   */\n  public get previous(): RoutingInstruction | null | undefined {\n    return this.endpoint.instance?.getContent()?.instruction;\n  }\n\n  /**\n   * Whether the routing instruction is an \"add\" instruction.\n   */\n  public isAdd(context: IRouterConfiguration | IRouter): boolean {\n    return this.component.name === Separators.for(context).add;\n  }\n  /**\n   * Whether the routing instruction is a \"clear\" instruction.\n   */\n  public isClear(context: IRouterConfiguration | IRouter): boolean {\n    return this.component.name === Separators.for(context).clear;\n  }\n  /**\n   * Whether the routing instruction is an \"add all\" instruction.\n   */\n  public isAddAll(context: IRouterConfiguration | IRouter): boolean {\n    return this.isAdd(context) && ((this.endpoint.name?.length ?? 0) === 0);\n  }\n  /**\n   * Whether the routing instruction is an \"clear all\" instruction.\n   */\n  public isClearAll(context: IRouterConfiguration | IRouter): boolean {\n    return this.isClear(context) && ((this.endpoint.name?.length ?? 0) === 0);\n  }\n\n  /**\n   * Whether the routing instruction has next scope/\"children\" instructions.\n   */\n  public get hasNextScopeInstructions(): boolean {\n    return (this.nextScopeInstructions?.length ?? 0) > 0;\n  }\n\n  /**\n   * Get the dynasty of the routing instruction. The dynasty is the instruction\n   * itself and all its descendants (next scope instructions iteratively).\n   */\n  public get dynasty(): RoutingInstruction[] {\n    const dynasty: RoutingInstruction[] = [this];\n    if (this.hasNextScopeInstructions) {\n      dynasty.push(...this.nextScopeInstructions!.map(instruction => instruction.dynasty).flat());\n    }\n    return dynasty;\n  }\n\n  /**\n   * Whether the routing instruction is unresolved.\n   */\n  public get isUnresolved(): boolean {\n    return this.component.isFunction() || this.component.isPromise();\n  }\n\n  /**\n   * Resolve the routing instruction.\n   */\n  public resolve(): void | Promise<ComponentAppellation> {\n    return this.component.resolve(this);\n  }\n\n  /**\n   * Get the instruction parameters with type specification applied.\n   */\n  public typeParameters(context: IRouterConfiguration | IRouter | IContainer): Parameters {\n    return this.parameters.toSpecifiedParameters(context, this.component.type?.parameters ?? []);\n  }\n\n  /**\n   * Compare the routing instruction's route with the route of another routing\n   * instruction.\n   *\n   * @param other - The routing instruction to compare to\n   */\n  public sameRoute(other: RoutingInstruction): boolean {\n    const thisRoute = this.route?.match;\n    const otherRoute = other.route?.match;\n    if (thisRoute == null || otherRoute == null) {\n      return false;\n    }\n    if (typeof thisRoute === 'string' || typeof otherRoute === 'string') {\n      return thisRoute === otherRoute;\n    }\n\n    return (thisRoute as Route).id === (otherRoute as Route).id;\n  }\n\n  /**\n   * Compare the routing instruction's component with the component of another routing\n   * instruction. Compares on name unless `compareType` is `true`.\n   *\n   * @param context - The context (used for parameter syntax) to compare within\n   * @param other - The routing instruction to compare to\n   * @param compareParameters - Whether parameters should also be compared\n   * @param compareType - Whether comparision should be made on type only (and not name)\n   */\n  public sameComponent(context: IRouterConfiguration | IRouter | IContainer, other: RoutingInstruction, compareParameters: boolean = false, compareType: boolean = false): boolean {\n    if (compareParameters && !this.sameParameters(context, other, compareType)) {\n      return false;\n    }\n    return this.component.same(other.component, compareType);\n  }\n\n  /**\n   * Compare the routing instruction's endpoint with the endpoint of another routing\n   * instruction. Compares on endpoint instance if possible, otherwise name.\n   *\n   * @param other - The routing instruction to compare to\n   * @param compareScope - Whether comparision should be made on scope as well (and not\n   * only instance/name)\n   */\n  public sameEndpoint(other: RoutingInstruction, compareScope: boolean): boolean {\n    return this.endpoint.same(other.endpoint, compareScope);\n  }\n\n  /**\n   * Compare the routing instruction's parameters with the parameters of another routing\n   * instruction. Compares on actual values.\n   *\n   * @param other - The routing instruction to compare to\n   * @param compareType - Whether comparision should be made on type as well\n   */\n  public sameParameters(context: IRouterConfiguration | IRouter | IContainer, other: RoutingInstruction, compareType: boolean = false): boolean {\n    // TODO: Somewhere we need to check for format such as spaces etc\n    if (!this.component.same(other.component, compareType)) {\n      return false;\n    }\n    return this.parameters.same(context, other.parameters, this.component.type);\n  }\n\n  /**\n   * Stringify the routing instruction, recursively down next scope/child instructions.\n   *\n   * @param context - The context (used for syntax) within to stringify the instructions\n   * @param options - The options for stringifying the instructions\n   * @param endpointContext - Whether to include endpoint context in the string.\n   * [Deprecated] Use the new interface instead: { excludeEndpoint: boolean; endpointContext: boolean; }\n   * @param shallow - Whether to stringify next scope instructions\n   */\n  public stringify(context: IRouterConfiguration | IRouter | IContainer, options: IRoutingInstructionStringifyOptions | boolean = {}, endpointContextOrShallow: boolean = false, shallow = false): string {\n    if (typeof options === 'boolean') {\n      // eslint-disable-next-line no-console\n      console.warn(`[Deprecated] Boolean passed to RoutingInstruction.stringify. Please use the new interface instead: { excludeEndpoint: boolean; endpointContext: boolean; }`);\n      options = { excludeEndpoint: options, endpointContext: endpointContextOrShallow };\n    } else {\n      shallow = endpointContextOrShallow;\n    }\n    options = { ...RoutingInstructionStringifyOptionsDefaults, ...options };\n\n    const seps = Separators.for(context);\n    let excludeCurrentEndpoint = options.excludeEndpoint;\n    let excludeCurrentComponent = false;\n\n    // If viewport context is specified...\n    if (options.endpointContext) {\n      const viewport = this.viewport?.instance as Viewport ?? null;\n      // (...it's still skipped if no link option is set on viewport)\n      if (viewport?.options.noLink ?? false) {\n        return '';\n      }\n      // ...viewport can still be excluded if it's not necessary...\n      if (!this.needsEndpointDescribed &&\n        (!(viewport?.options.forceDescription ?? false) // ...and not forced...\n          || (this.viewportScope?.instance != null)) // ...or it has a viewport scope\n      ) {\n        excludeCurrentEndpoint = true;\n      }\n      // ...or if it's the fallback component...\n      if (viewport?.options.fallback === this.component.name) {\n        excludeCurrentComponent = true;\n      }\n      // ...or the default component /* without next scope instructions/children */.\n      if (viewport?.options.default === this.component.name /* && !this.hasNextScopeInstructions */) {\n        excludeCurrentComponent = true;\n      }\n    }\n\n    const nextInstructions: RoutingInstruction[] | null = this.nextScopeInstructions;\n    // Start with the scope modifier (if any)\n    let stringified: string = this.scopeModifier;\n\n    // It's a configured route that's already added as part of a configuration, so skip to next scope!\n    if (this.route instanceof FoundRoute && !this.routeStart) {\n      return !shallow && Array.isArray(nextInstructions)\n        ? RoutingInstruction.stringify(context, nextInstructions, options)\n        : '';\n    }\n    const path = this.stringifyShallow(context, excludeCurrentEndpoint, excludeCurrentComponent, options.fullState);\n    stringified += path.endsWith(seps.scope) ? path.slice(0, -seps.scope.length) : path;\n\n    // If any next scope/child instructions...\n    if (!shallow && Array.isArray(nextInstructions) && nextInstructions.length > 0) {\n      // ...get them as string...\n      const nextStringified = RoutingInstruction.stringify(context, nextInstructions, options);\n      if (nextStringified.length > 0) {\n        // ...and add with scope separator and...\n        stringified += seps.scope;\n        // ...check if scope grouping separators are needed:\n        stringified += nextInstructions.length === 1 // TODO: This should really also check that the instructions have value\n          // only one child, add as-is\n          ? nextStringified\n          // more than one child, add within scope (between () )\n          : `${seps.groupStart}${nextStringified}${seps.groupEnd}`;\n      }\n    }\n    return stringified;\n  }\n\n  /**\n   * Clone the routing instruction.\n   *\n   * @param keepInstances - Whether actual instances should be transfered\n   * @param scopeModifier - Whether the scope modifier should be transfered\n   * @param shallow - Whether it should be a shallow clone only\n   */\n  public clone(keepInstances: boolean = false, scopeModifier: boolean = false, shallow: boolean = false): RoutingInstruction {\n    // Create a clone without instances...\n    const clone = RoutingInstruction.create(\n      this.component.func ?? this.component.promise ?? this.component.type ?? this.component.name!,\n      this.endpoint.name!,\n      this.parameters.typedParameters ?? void 0,\n    ) as RoutingInstruction;\n    // ...and then set them if they should be transfered.\n    if (keepInstances) {\n      clone.component.set(this.component.instance ?? this.component.type ?? this.component.name!);\n      clone.endpoint.set(this.endpoint.instance ?? this.endpoint.name!);\n    }\n    // And transfer the component name afterwards to make sure aliases are kept\n    clone.component.name = this.component.name;\n\n    clone.needsEndpointDescribed = this.needsEndpointDescribed;\n    clone.route = this.route;\n    clone.routeStart = this.routeStart;\n    clone.default = this.default;\n\n    // Only transfer scope modifier if specified\n    if (scopeModifier) {\n      clone.scopeModifier = this.scopeModifier;\n    }\n    clone.scope = keepInstances ? this.scope : null;\n    // Clone all next scope/child instructions\n    if (this.hasNextScopeInstructions && !shallow) {\n      clone.nextScopeInstructions = RoutingInstruction.clone(this.nextScopeInstructions!, keepInstances, scopeModifier);\n    }\n    return clone;\n  }\n\n  /**\n   * Whether the routing instruction is in a list of routing instructions. If\n   * deep, all next scope instructions needs to be contained in containing\n   * next scope instructions as well.\n   *\n   * @param context - The context (used for parameter syntax) to compare within\n   * @param searchIn - Instructions that should contain (superset)\n   * @param deep - Whether next scope instructions also need to be contained (recursively)\n   */\n  public isIn(context: IRouterConfiguration | IRouter | IContainer, searchIn: RoutingInstruction[], deep: boolean): boolean {\n    // Get all instructions with matching component.\n    const matching = searchIn.filter(instruction => {\n      // Match either routes...\n      if (this.route != null || instruction.route != null) {\n        if (!instruction.sameRoute(this)) {\n          return false;\n        }\n      } else {\n        // ... or components\n        if (!instruction.sameComponent(context, this)) {\n          return false;\n        }\n      }\n      // Use own type if we have it, the other's type if not\n      const instructionType = instruction.component.type ?? this.component.type;\n      const thisType = this.component.type ?? instruction.component.type;\n      const instructionParameters = instruction.parameters.toSpecifiedParameters(context, instructionType?.parameters);\n      const thisParameters = this.parameters.toSpecifiedParameters(context, thisType?.parameters);\n\n      if (!InstructionParameters.contains(instructionParameters, thisParameters)) {\n        return false;\n      }\n      return (this.endpoint.none || instruction.sameEndpoint(this, false));\n    });\n    // If no one matches, it's a failure.\n    if (matching.length === 0) {\n      return false;\n    }\n\n    // If no deep match or no next scope instructions...\n    if (!deep || !this.hasNextScopeInstructions) {\n      // ...it's a successful match.\n      return true;\n    }\n\n    // Match the next scope instructions to the next scope instructions of each\n    // of the matching instructions and if at least one match (recursively)...\n    if (matching.some(matched => RoutingInstruction.contains(\n      context,\n      matched.nextScopeInstructions ?? [],\n      this.nextScopeInstructions!,\n      deep))\n    ) {\n      // ...it's a success...\n      return true;\n    }\n    // ...otherwise it's a failure to match.\n    return false;\n  }\n\n  /**\n   * Get the title for the routing instruction.\n   *\n   * @param navigation - The navigation that requests the content change\n   */\n  public getTitle(navigation: Navigation): string {\n    // If it's a configured route...\n    if (this.route instanceof FoundRoute) {\n      // ...get the configured route title.\n      const routeTitle = this.route.match?.title;\n      // If there's a configured title, use it. Otherwise fallback to\n      // titles based on endpoint's component.\n      if (routeTitle != null) {\n        // Only add the title (once) if it's the first instruction\n        if (this.routeStart) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n          return typeof routeTitle === 'string' ? routeTitle : routeTitle(this, navigation);\n        } else {\n          return '';\n        }\n      }\n    }\n    return this.endpoint.instance!.getTitle(navigation);\n  }\n\n  public toJSON(): unknown {\n    return {\n      component: this.component.name ?? undefined,\n      viewport: this.endpoint.name ?? undefined,\n      parameters: this.parameters.parametersRecord ?? undefined,\n      children: this.hasNextScopeInstructions\n        ? this.nextScopeInstructions\n        : undefined,\n    };\n  }\n  /**\n   * Stringify the routing instruction shallowly, NOT recursively down next scope/child instructions.\n   *\n   * @param context - The context (used for syntax) within to stringify the instructions\n   * @param excludeEndpoint - Whether to exclude endpoint names in the string\n   * @param excludeComponent - Whether to exclude component names in the string\n   */\n  private stringifyShallow(context: IRouterConfiguration | IRouter | IContainer, excludeEndpoint: boolean = false, excludeComponent: boolean = false, fullState = false): string {\n    if (!fullState && this.route != null) {\n      const path = this.route instanceof FoundRoute ? this.route.matching : this.route;\n      return path\n        .split('/')\n        .map(part => part.startsWith(':')\n          ? this.parameters.get(context, part.slice(1))\n          : part)\n        .join('/');\n    }\n\n    const seps = Separators.for(context);\n    // Start with component (unless excluded)\n    let instructionString = !excludeComponent || fullState ? this.component.name ?? '' : '';\n\n    // Get parameters specification (names, sort order) from component type\n    // TODO(alpha): Use Metadata!\n    const specification = this.component.type ? this.component.type.parameters : null;\n    // Get parameters according to specification\n    const parameters = InstructionParameters.stringify(context, this.parameters.toSortedParameters(context, specification));\n    if (parameters.length > 0) {\n      // Add to component or use standalone\n      instructionString += !excludeComponent || fullState\n        ? `${seps.parameters}${parameters}${seps.parametersEnd}`\n        : parameters;\n    }\n    // Add endpoint name (unless excluded)\n    if (this.endpoint.name != null && (!excludeEndpoint || fullState)) {\n      instructionString += `${seps.viewport}${this.endpoint.name}`;\n    }\n    // And add no (owned) scope indicator\n    if (!this.ownsScope) {\n      instructionString += seps.noScope;\n    }\n    return instructionString || '';\n  }\n}\n", "import { EventAggregator, IContainer, IEventAggregator, resolve } from '@aurelia/kernel';\nimport { IRouteableComponent } from './interfaces';\nimport { RoutingInstruction } from './instructions/routing-instruction';\nimport { Navigation, IStoredNavigation, INavigation, NavigationFlags } from './navigation';\nimport { Runner, Step } from './utilities/runner';\nimport { arrayUnique } from './utilities/utils';\nimport { Viewport } from './endpoints/viewport';\nimport { OpenPromise } from './utilities/open-promise';\nimport { ErrorNames, createMappedError } from './errors';\n\n/**\n * The navigator is responsible for managing (queueing) navigations and\n * feeding them to the router, keeping track of historical navigations/states\n * and providing an api to historical and current/last state.\n *\n * The navigator uses a first-in-first-out queue with a callback that gets\n * called with a queued item only when the previously processed item has been\n * resolved or rejected. All navigations are enqueued in this queue and once\n * dequeued into the callback the navigator enrich them with historical\n * navigation data and pass it on to the router for processing.\n *\n * An event is fired when a navigation is ready for processing by the router.\n *\n * Whenever the router has finalized or canceled a navigation it informs the\n * navigator which then updates current/last and historical states accordingly\n * and instructs the viewer and store (BrowserViewerStore) to do appropriate\n * updates.\n *\n * TODO: Make the queue not wait until currently processing item is done, so\n * that it won't be necessary to wait for long running navigations to finish\n * before doing a new navigation.\n */\n\n/**\n * The navigator store is responsible for storing historical and current/last\n * navigations and providing navigations between them.\n */\n/**\n * @internal\n */\nexport interface INavigatorStore {\n  readonly length: number;\n  readonly state: Record<string, unknown> | null;\n  go(delta?: number, suppressPopstate?: boolean): Promise<boolean | void>;\n  pushNavigatorState(state: IStoredNavigatorState): Promise<boolean | void>;\n  replaceNavigatorState(state: IStoredNavigatorState): Promise<boolean | void>;\n  popNavigatorState(): Promise<boolean | void>;\n}\n\n/**\n * The navigator viewer is responsible for viewing relevant navigation such\n * as title and URL (Location) path.\n */\n/**\n * @internal\n */\nexport interface INavigatorViewer {\n  start(options: INavigatorViewerOptions): void;\n  stop(): void;\n  setTitle(title: string): void;\n}\n/**\n * @internal\n */\nexport interface INavigatorViewerOptions {\n}\n\nexport class NavigatorNavigateEvent {\n  public static eventName = 'au:router:navigation-navigate';\n\n  public constructor(\n    public readonly eventName: string,\n    public readonly navigation: Navigation\n  ) { }\n  public static create(navigation: INavigation): NavigatorNavigateEvent {\n    return new NavigatorNavigateEvent(\n      NavigatorNavigateEvent.eventName,\n      navigation as Navigation);\n  }\n}\n\nexport interface INavigatorOptions {\n  viewer?: INavigatorViewer;\n  store?: INavigatorStore;\n  statefulHistoryLength?: number;\n}\n\n/**\n * @internal\n */\nexport interface IStoredNavigatorState {\n  state?: Record<string, unknown>;\n  navigations: IStoredNavigation[];\n  navigationIndex: number;\n}\n\n/**\n * @internal\n */\nexport interface INavigatorState {\n  state?: Record<string, unknown>;\n  navigations: Navigation[];\n  navigationIndex: number;\n}\n\n/**\n * @internal\n */\nexport class Navigator {\n  /**\n   * The index of the last _finished_ navigation.\n   */\n  public lastNavigationIndex: number = -1;\n\n  /**\n   * All navigations, historical and current/last\n   */\n  public navigations: Navigation[] = [];\n\n  /**\n   * Navigator options\n   */\n  private options: INavigatorOptions = {\n    /**\n     * How many historical navigations that should be kept stateful,\n     * default 0 means none.\n     */\n    statefulHistoryLength: 0,\n  };\n  /**\n   * Whether the navigator is started\n   */\n  private isActive: boolean = false;\n\n  /**\n   * An uninitialized navigation that's used before the\n   * navigator is started and before first navigation is made\n   */\n  private readonly uninitializedNavigation: Navigation = Navigation.create({\n    instruction: 'NAVIGATOR UNINITIALIZED',\n    fullStateInstruction: '',\n    index: 0,\n    completed: true,\n  });\n\n  private readonly ea: EventAggregator = resolve(IEventAggregator);\n  private readonly container: IContainer = resolve(IContainer);\n\n  public start(options?: INavigatorOptions): void {\n    if (this.isActive) {\n      throw createMappedError(ErrorNames.navigator_already_started);\n    }\n\n    this.isActive = true;\n    this.options = { ...options };\n  }\n\n  public stop(): void {\n    if (!this.isActive) {\n      throw createMappedError(ErrorNames.navigator_not_started);\n    }\n    this.isActive = false;\n  }\n\n  /**\n   * Perform a navigation. The navigation is enriched with historical\n   * navigation data and passed to the router.\n   *\n   * @param navigation - The navigation to perform\n   */\n  public navigate(navigation: INavigation | Navigation): Promise<boolean> {\n    if (!(navigation instanceof Navigation)) {\n      navigation = Navigation.create(navigation);\n    }\n    const navigationFlags = new NavigationFlags();\n\n    // If no proper last navigation, no navigation has been processed this session, meaning\n    // that this one is either a first navigation or a refresh (repeat navigation).\n    if (this.lastNavigationIndex === -1) {\n      // Load the navigation state from the store (mutating `navigations` and\n      // `lastNavigationIndex`) and then set appropriate flags...\n      this.loadState();\n      if (this.lastNavigationIndex !== -1) {\n        navigationFlags.refresh = true;\n      } else {\n        navigationFlags.first = true;\n        navigationFlags.new = true;\n        // ...and create the first navigation.\n        // TODO: Should this really be created here? Shouldn't it be in the viewer?\n        this.lastNavigationIndex = 0;\n        this.navigations = [Navigation.create({\n          index: 0,\n          instruction: '',\n          fullStateInstruction: '',\n          // path: this.options.viewer.getPath(true),\n          // fromBrowser: null,\n        })];\n      }\n    }\n    // If navigation has an index and isn't replacing or refreshing, it's a historical\n    // navigation...\n    if (navigation.index !== void 0 && !(navigation.replacing ?? false) && !(navigation.refreshing ?? false)) {\n      // ...set the movement size...\n      navigation.historyMovement = navigation.index - Math.max(this.lastNavigationIndex, 0);\n      // ...and set the navigation instruction.\n      navigation.instruction = this.navigations[navigation.index] != null ? this.navigations[navigation.index].fullStateInstruction : navigation.fullStateInstruction;\n      // Set appropriate navigation flags.\n      navigation.replacing = true;\n      if (navigation.historyMovement > 0) {\n        navigationFlags.forward = true;\n      } else if (navigation.historyMovement < 0) {\n        navigationFlags.back = true;\n      }\n    } else if ((navigation.refreshing ?? false) || navigationFlags.refresh) { // If the navigation is a refresh...\n      // ...just reuse the navigation.\n      // navigation.index = this.lastNavigationIndex;\n      navigation = this.navigations[this.lastNavigationIndex];\n      navigation.replacing = true;\n      navigation.refreshing = true;\n    } else if (navigation.replacing ?? false) {  // If the navigation is replacing...\n      // ...set appropriate flags...\n      navigationFlags.replace = true;\n      navigationFlags.new = true;\n      // ...and reuse last index.\n      navigation.index = this.lastNavigationIndex;\n    } else { // If the navigation is a new navigation...\n      // ...set navigation flag...\n      navigationFlags.new = true;\n      // ...and create a new index.\n      navigation.index = this.lastNavigationIndex + 1;\n      this.navigations[navigation.index] = navigation as Navigation;\n    }\n\n    // Set the appropriate flags.\n    (navigation as Navigation).navigation = navigationFlags;\n    // Set the previous navigation.\n    navigation.previous = this.navigations[Math.max(this.lastNavigationIndex, 0)];\n    // Create a process with an awaitable promise.\n    (navigation as Navigation).process = new OpenPromise(`navigation: ${navigation.path}`);\n\n    // Set the last navigated index to the navigation index\n    this.lastNavigationIndex = navigation.index as number;\n\n    this.notifySubscribers(navigation as Navigation);\n\n    return (navigation as Navigation).process!.promise;\n  }\n\n  /**\n   * Finalize a navigation and make it the last navigation.\n   *\n   * @param navigation - The navigation to finalize\n   */\n  public async finalize(navigation: Navigation, isLast: boolean): Promise<void> {\n    // If this navigation shouldn't be added to history...\n    if (navigation.untracked ?? false) {\n      // ...and it's a navigation from the browser (back, forward, url)...\n      if ((navigation.fromBrowser ?? false) && this.options.store != null) {\n        // ...pop it from browser's history and...\n        await this.options.store.popNavigatorState();\n      }\n      // ...restore the previous last navigation (and no need to save).\n    } else if (navigation.replacing ?? false) { // If this isn't creating a new navigation...\n      if ((navigation.historyMovement ?? 0) === 0) { // ...and it's not a navigation in the history...\n        // ...use last navigation index.\n        this.navigations[navigation.previous!.index!] = navigation;\n      }\n      await this.saveState(navigation.index!, false);\n    } else { // New navigation\n      const index = navigation.index as number;\n      // Discard anything after the new navigation so that it becomes the last.\n      if (isLast) {\n        this.navigations = this.navigations.slice(0, index);\n      }\n      this.navigations[index] = navigation;\n      // Need to make sure components in discarded routing instructions are\n      // disposed if stateful history is used...\n      if ((this.options.statefulHistoryLength ?? 0) > 0) {\n        // ...but not the ones that should be preserved, so keep...\n        const indexPreserve = this.navigations.length - (this.options.statefulHistoryLength ?? 0);\n        // ...the last ones as is.\n        for (const navig of this.navigations.slice(index)) {\n          // Only non-string instructions has components to dispose.\n          if (typeof navig.instruction !== 'string' || typeof navig.fullStateInstruction !== 'string') {\n            // Use serialize to dispose routing instruction components\n            // since the end result is the same. Pass the navigations\n            // that should be preserved so that components in them aren't\n            // disposed if they also exist in discarded routing instructions.\n            await this.serializeNavigation(navig, this.navigations.slice(indexPreserve, index));\n          }\n        }\n      }\n      // If it's a navigation from the browser (back, forward, url) we replace the state\n      await this.saveState(navigation.index!, !(navigation.fromBrowser ?? false));\n    }\n  }\n\n  /**\n   * Cancel a navigation and move to last finalized navigation.\n   *\n   * @param navigation - The navigation to cancel\n   */\n  public async cancel(navigation: Navigation): Promise<void> {\n    if (this.options.store != null) {\n      // If it's a new navigation...\n      if (navigation.navigation?.new) {\n        // ...from the browser (url)...\n        if (navigation.fromBrowser ?? false) {\n          // ...pop it from the browser's History.\n          await this.options.store.popNavigatorState();\n        }\n        // Undo the history movement back to previous last navigation\n      } else if ((navigation.historyMovement ?? 0) !== 0) {\n        await this.options.store.go(-navigation.historyMovement!, true);\n      }\n    }\n  }\n\n  /**\n   * Go to an earlier or later navigation in navigation history.\n   *\n   * @param movement - Amount of steps to move, positive or negative\n   */\n  public async go(movement: number): Promise<boolean | void> {\n    let newIndex = this.lastNavigationIndex + movement;\n\n    // Stop going past last navigation\n    newIndex = Math.min(newIndex, this.navigations.length - 1);\n\n    // Move the store's history (but suppress the event so it's\n    // a noop as far as the router is concerned)\n    await this.options.store!.go(movement, true);\n\n    // Get the appropriate navigation...\n    const navigation = this.navigations[newIndex];\n    // ...and enqueue it again.\n    return this.navigate(navigation);\n  }\n\n  /**\n   * Get the stored navigator state (json okay) as well as the last\n   * navigation and all historical navigations from the store.\n   */\n  public getState(): IStoredNavigatorState {\n    // Get the stored state and...\n    const state: Partial<IStoredNavigatorState> = this.options.store != null ? { ...this.options.store.state } : {};\n    // ...separate the historical navigations...\n    const navigations = (state?.navigations ?? []);\n    // ...and the last state.\n    const navigationIndex = state?.navigationIndex as number ?? -1;\n    return { navigations, navigationIndex };\n  }\n\n  /**\n   * Load the state stored in the store into the navigator's last and\n   * historical states.\n   */\n  public loadState(): void {\n    // Get the stored navigations (json)...\n    const { navigations, navigationIndex } = this.getState();\n    // ...and create the historical Navigations...\n    this.navigations = navigations.map(navigation => Navigation.create(navigation));\n    // ...and the last navigation index.\n    this.lastNavigationIndex = navigationIndex;\n  }\n\n  /**\n   * Save the last state to history and save the history to the store,\n   * converting to json when necessary.\n   *\n   * @param index - The index of the last navigation\n   * @param push - Whether the last state should be pushed as a new entry\n   * in the history or replace the last position.\n   */\n  public async saveState(index: number, push: boolean): Promise<boolean | void> {\n    // Make sure all navigations are clean of non-persisting data\n    for (let i = 0; i < this.navigations.length; i++) {\n      this.navigations[i] = Navigation.create(this.navigations[i].toStoredNavigation());\n    }\n\n    // If preserving history, serialize navigations that aren't preserved:\n    // Should preserve...\n    if ((this.options.statefulHistoryLength ?? 0) > 0) {\n      // ...from 'index' and to the end.\n      const index = this.navigations.length - (this.options.statefulHistoryLength ?? 0);\n      // Work from beginning to the index that should be preserved...\n      for (let i = 0; i < index; i++) {\n        const navigation = this.navigations[i];\n        // ...and serialize the navigation if necessary. (Serializing will free\n        // components that are no longer used.)\n        if (typeof navigation.instruction !== 'string' || typeof navigation.fullStateInstruction !== 'string') {\n          await this.serializeNavigation(navigation, this.navigations.slice(index));\n        }\n      }\n    }\n\n    // If there's a store...\n    if (this.options.store == null) {\n      return Promise.resolve();\n    }\n    // ...prepare the state...\n    const state: IStoredNavigatorState = {\n      navigations: (this.navigations ?? []).map((navigation: Navigation) => this.toStoreableNavigation(navigation)),\n      navigationIndex: index,\n    };\n    // ...and save it in the right place.\n    if (push) {\n      return this.options?.store?.pushNavigatorState(state);\n    } else {\n      return this.options.store.replaceNavigatorState(state);\n    }\n  }\n\n  /**\n   * Refresh (reload) the last navigation.\n   */\n  public async refresh(): Promise<boolean | void> {\n    // Don't refresh if there's been no navigation before\n    if (this.lastNavigationIndex === -1) {\n      return Promise.reject();\n    }\n    const navigation = this.navigations[this.lastNavigationIndex];\n\n    // Set navigation flags...\n    navigation.replacing = true;\n    navigation.refreshing = true;\n    // ...and enqueue the navigation again.\n    return this.navigate(navigation);\n  }\n\n  /**\n   * Notifies subscribers that a navigation has been dequeued for processing.\n   *\n   * @param navigation - The Navigation to process\n   */\n  private notifySubscribers(navigation: Navigation): void {\n    this.ea.publish(NavigatorNavigateEvent.eventName, NavigatorNavigateEvent.create(navigation));\n  }\n\n  /**\n   * Make a Navigation storeable/json safe.\n   *\n   * @param navigation - The navigation to make storeable\n   */\n  private toStoreableNavigation(navigation: Navigation | IStoredNavigation): IStoredNavigation {\n    // Get a navigation with only the properties that are stored\n    const storeable = navigation instanceof Navigation ? navigation.toStoredNavigation() : navigation;\n    // Make sure instruction is a string\n    storeable.instruction = RoutingInstruction.stringify(this.container, storeable.instruction);\n    // Make sure full state instruction is a string\n    storeable.fullStateInstruction = RoutingInstruction.stringify(this.container, storeable.fullStateInstruction, { endpointContext: true, fullState: true });\n    // Only string scopes can be stored\n    if (typeof storeable.scope !== 'string') {\n      storeable.scope = null;\n    }\n    // TODO: Filter out non-json compatible data and parameters!\n    return storeable;\n  }\n\n  /**\n   * Serialize a navigation to string(s), freeing/disposing all components in it.\n   * (Only components that doesn't exist in a preserved navigation will be disposed.)\n   *\n   * @param navigation - The navigation to serialize\n   * @param preservedNavigations - Navigations that should be preserved, meaning\n   * that any component used in them should not be disposed\n   */\n  private async serializeNavigation(navigation: Navigation, preservedNavigations: Navigation[]): Promise<void> {\n    let excludeComponents = [];\n    // Components in preserved navigations should not be serialized/freed\n    for (const preservedNavigation of preservedNavigations) {\n      // Get components from instruction...\n      if (typeof preservedNavigation.instruction !== 'string') {\n        excludeComponents.push(...RoutingInstruction.flat(preservedNavigation.instruction)\n          .filter(instruction => instruction.endpoint.instance !== null) // Both endpoint instance and...\n          .map(instruction => instruction.component.instance)); // ...component instance should be set\n      }\n      // ...and full state instruction\n      if (typeof preservedNavigation.fullStateInstruction !== 'string') {\n        excludeComponents.push(...RoutingInstruction.flat(preservedNavigation.fullStateInstruction)\n          .filter(instruction => instruction.endpoint.instance !== null) // Both endpoint instance and...\n          .map(instruction => instruction.component.instance)); // ...component instance should be set\n      }\n    }\n    // Make excluded components unique\n    excludeComponents = arrayUnique(excludeComponents) as IRouteableComponent[];\n\n    let instructions: RoutingInstruction[] = [];\n    // The instructions, one or two, with possible components to free\n    if (typeof navigation.fullStateInstruction !== 'string') {\n      // Save the instruction\n      instructions.push(...navigation.fullStateInstruction);\n      navigation.fullStateInstruction = RoutingInstruction.stringify(this.container, navigation.fullStateInstruction, { endpointContext: true, fullState: true });\n    }\n    if (typeof navigation.instruction !== 'string') {\n      // Save the instruction\n      instructions.push(...navigation.instruction);\n      navigation.instruction = RoutingInstruction.stringify(this.container, navigation.instruction);\n    }\n\n    // Process only the instructions with instances and make them unique\n    instructions = instructions.filter(\n      (instruction, i, arr) =>\n        instruction.component.instance != null\n        && arr.indexOf(instruction) === i\n    );\n\n    // Already freed components (updated when component is freed)\n    const alreadyDone: IRouteableComponent[] = [];\n    for (const instruction of instructions) {\n      // Free (and dispose) instruction components except excluded and already done\n      await this.freeInstructionComponents(instruction, excludeComponents, alreadyDone);\n    }\n  }\n\n  /**\n   * Free (and dispose) components in a routing instruction unless the components\n   * should be excluded (due to also being in non-freed instructions) or have already\n   * been freed/disposed.\n   *\n   * @param instruction - Routing instruction to free components in\n   * @param excludeComponents - Components to exclude\n   * @param alreadyDone - Components that's already been freed/disposed\n   */\n  private freeInstructionComponents(instruction: RoutingInstruction, excludeComponents: IRouteableComponent[], alreadyDone: IRouteableComponent[]): void | Promise<void> {\n    const component = instruction.component.instance;\n    const viewport = instruction.viewport?.instance as Viewport ?? null;\n    // Both viewport and component instance should be set in order to free/dispose\n    if (component === null || viewport === null || alreadyDone.some(done => done === component)) {\n      return;\n    }\n    if (!excludeComponents.some(exclude => exclude === component)) {\n      return Runner.run('freeInstructionComponents',\n        (step: Step<void>) => viewport.freeContent(step, component),\n        () => {\n          alreadyDone.push(component);\n        },\n      ) as void | Promise<void>;\n    }\n    // If there are any next scope/child instructions...\n    if (instruction.hasNextScopeInstructions) {\n      for (const nextInstruction of instruction.nextScopeInstructions!) {\n        // ...try freeing/disposing them as well.\n        return this.freeInstructionComponents(nextInstruction, excludeComponents, alreadyDone);\n      }\n    }\n  }\n}\n", "import {\n  RouteRecognizer as $RouteRecognizer,\n  IConfigurableRoute as $IConfigurableRoute,\n  ConfigurableRoute as $ConfigurableRoute,\n  RecognizedRoute as $RecognizedRoute,\n  Endpoint as $Endpoint,\n} from '@aurelia/route-recognizer';\n\nimport { Route } from './route';\n\ndeclare class $$RouteRecognizer extends $RouteRecognizer<Route> {}\ndeclare class $$ConfigurableRoute extends $ConfigurableRoute<Route> {}\ndeclare class $$RecognizedRoute extends $RecognizedRoute<Route> {}\ndeclare class $$Endpoint extends $Endpoint<Route> {}\n\nexport interface RouteRecognizer extends $RouteRecognizer<Route> {}\nexport type IConfigurableRoute = $IConfigurableRoute<Route>;\nexport interface ConfigurableRoute extends $ConfigurableRoute<Route> {}\nexport interface RecognizedRoute extends $RecognizedRoute<Route> {}\nexport interface Endpoint extends $Endpoint<Route> {}\n\nexport const RouteRecognizer = $RouteRecognizer as typeof $$RouteRecognizer;\nexport const ConfigurableRoute = $ConfigurableRoute as typeof $$ConfigurableRoute;\nexport const RecognizedRoute = $RecognizedRoute as typeof $$RecognizedRoute;\nexport const Endpoint = $Endpoint as typeof $$Endpoint;\n", "/**\n *\n * NOTE: This file is still WIP and will go through at least one more iteration of refactoring, commenting and clean up!\n * In its current state, it is NOT a good source for learning about the inner workings and design of the router.\n *\n */\nimport { arrayRemove } from './utils';\n\n/**\n * @internal - Helper class\n */\nexport class Collection<T> extends Array<T> {\n  private currentIndex: number = -1;\n\n  public next(): T | null {\n    if (this.length > this.currentIndex + 1) {\n      return this[++this.currentIndex];\n    } else {\n      this.currentIndex = -1;\n      return null;\n    }\n  }\n\n  public removeCurrent(): void {\n    this.splice(this.currentIndex--, 1);\n  }\n\n  public remove(instruction?: T): void {\n    arrayRemove(this, value => value === instruction);\n  }\n}\n", "import { ViewportScope } from './endpoints/viewport-scope';\nimport { RoutingInstruction } from './instructions/routing-instruction';\nimport { Viewport } from './endpoints/viewport';\nimport { arrayRemove } from './utilities/utils';\nimport { Collection } from './utilities/collection';\nimport { RoutingScope } from './routing-scope';\nimport { IRouter } from './index';\n\n/**\n * The EndpointMatcher finds endpoints, viewports and viewport scopes, that matches routing instructions' criteria.\n * It works based on RoutingScope and is a pure helper class to it. The only public method, `matchEndpoints`, is\n * invoked on two occassions during a navigation:\n * - when the router is looking for the matching endpoints to the routing instructions in a navigation, and\n * - when the router is looking for the minimum way to describe the full current state of all endpoints. In this\n * second invokation, pre-existing matching endpoints on the routing instruction are ignored.\n *\n * It mutates the actual routing instructions in which is good for the first occassion but requires a cloning of\n * the routing instructions representing the full current state before the second invokation.\n *\n * Endpoints are matched in priority order\n * 1) already existing instances (skipped in second occassion, minimum descripton of full state)\n * 2) viewport scope matching segment (component/path part)\n * 3) component configuration on viewports (used-by)\n * 4) viewport (non-instance) specified in routing instruction (skipped in second occassion, minimum descripton)\n * 5) if there's a single available viewport last\n * 6) viewport specified in routing instruction (only in second occassion, minimum descripton)\n */\nexport interface IMatchEndpointsResult {\n  matchedInstructions: RoutingInstruction[];\n  remainingInstructions: RoutingInstruction[];\n}\n\nexport class EndpointMatcher {\n\n  // TODO: In addition to check whether the viewport is configured for components, check if\n  // the components are configured for viewports.\n  // TODO: When matching/checking on component and viewport, match on ComponentAppelation\n  // and ViewportHandle.\n\n  /**\n   * Finds endpoints, viewports and viewport scopes, that matches routing instructions' criteria.\n   * See comment at the top of the file for more details.\n   *\n   * @param instructions - The routing instructions to find matches for\n   * @param routingScope - The routing scope where to find the matching endpoints\n   * @param alreadyMatched - Already matched routing instructions whose endpoints are no longer available\n   * @param disregardViewports - Ignore already existing matchin endpoints on the routing instructions\n   */\n  // Note: This can't change state other than the instructions!\n  public static matchEndpoints(routingScope: RoutingScope, instructions: RoutingInstruction[], alreadyMatched: RoutingInstruction[], disregardViewports: boolean = false): IMatchEndpointsResult {\n    const matchedInstructions: RoutingInstruction[] = [];\n\n    // Get all the routing scopes owned by this scope\n    // TODO: Investigate if Infinity needs to be a timestamp\n    const ownedScopes = routingScope.getOwnedRoutingScopes(Infinity);\n\n    // Get a shallow copy of all available endpoints\n    const endpoints = ownedScopes.map(scope => scope.endpoint);\n    const availableEndpoints = endpoints\n      .filter(endpoint => endpoint !== null\n        && !alreadyMatched.some(found => endpoint === found.endpoint.instance && !found.cancelled && !found.isClear(routingScope.router))\n      ) as (Viewport | ViewportScope)[];\n\n    const routingInstructions = new Collection<RoutingInstruction>(...instructions.slice());\n    let instruction: RoutingInstruction | null = null;\n\n    // First, match instructions with already known viewport scopes...\n    // Removes entries from routingInstructions collection and availableEndpoints, adds entries to matchedInstructions\n    // and sets viewport/viewport scope and scope in actual RoutingInstruction\n    // Pass in `false` to `doesntNeedViewportDescribed` even though it doesn't really apply for ViewportScope\n    EndpointMatcher.matchKnownEndpoints(\n      routingScope.router,\n      'ViewportScope',\n      routingInstructions,\n      availableEndpoints,\n      matchedInstructions,\n      false,\n    );\n\n    // ...and instructions with already known viewports (unless we're disregarding already known viewports when matching).\n    if (!disregardViewports) {\n      // Removes entries from routingInstructions collection and availableEndpoints, adds entries to matchedInstructions\n      // and sets viewport/viewport scope and scope in actual RoutingInstruction\n      // Pass in `false` to `doesntNeedViewportDescribed` since we can't know for sure whether viewport is necessary or not\n      EndpointMatcher.matchKnownEndpoints(\n        routingScope.router,\n        'Viewport',\n        routingInstructions,\n        availableEndpoints,\n        matchedInstructions,\n        false,\n      );\n    }\n\n    // Then match viewport scopes that accepts the component (name) as segment.\n    // Removes entries from routingInstructions collection and availableEndpoints, adds entries to matchedInstructions\n    // and sets viewport scope and scope in actual RoutingInstruction\n    EndpointMatcher.matchViewportScopeSegment(\n      routingScope.router,\n      routingScope,\n      routingInstructions,\n      availableEndpoints,\n      matchedInstructions,\n    );\n\n    // All instructions not yet matched need viewport described in some way unless\n    // specifically specified as not needing it (parameter to `foundEndpoint`)\n    while ((instruction = routingInstructions.next()) !== null) {\n      instruction.needsEndpointDescribed = true;\n    }\n\n    // Match viewports with configuration (for example `used-by` attribute) that matches instruction components.\n    // Removes entries from routingInstructions collection and availableEndpoints, adds entries to matchedInstructions\n    // and sets viewport scope and scope in actual RoutingInstruction\n    EndpointMatcher.matchViewportConfiguration(\n      routingInstructions,\n      availableEndpoints,\n      matchedInstructions,\n    );\n\n    // Next in line is specified viewport (but not if we're disregarding viewports)\n    if (!disregardViewports) {\n      // Removes entries from routingInstructions collection and availableEndpoints, adds entries to matchedInstructions\n      // and sets viewport scope and scope in actual RoutingInstruction.\n      // Pass in `false` to `doesntNeedViewportDescribed` since we can't know for sure whether viewport is necessary or not\n      EndpointMatcher.matchSpecifiedViewport(\n        routingInstructions,\n        availableEndpoints,\n        matchedInstructions,\n        false,\n      );\n    }\n\n    // Finally, only one available and accepting viewport remaining?\n    // Removes entries from routingInstructions collection and availableEndpoints, adds entries to matchedInstructions\n    // and sets viewport scope and scope in actual RoutingInstruction\n    EndpointMatcher.matchLastViewport(\n      routingInstructions,\n      availableEndpoints,\n      matchedInstructions,\n    );\n\n    // If we're ignoring viewports, we now match them anyway\n    if (disregardViewports) {\n      // Removes entries from routingInstructions collection and availableEndpoints, adds entries to matchedInstructions\n      // and sets viewport scope and scope in actual RoutingInstruction.\n      // Pass in `false` to `doesntNeedViewportDescribed` since we do need the viewport if we got here\n      EndpointMatcher.matchSpecifiedViewport(\n        routingInstructions,\n        availableEndpoints,\n        matchedInstructions,\n        false,\n      );\n    }\n\n    return {\n      matchedInstructions,\n      remainingInstructions: [...routingInstructions],\n    };\n  }\n\n  private static matchKnownEndpoints(\n    router: IRouter,\n    type: string,\n    routingInstructions: Collection<RoutingInstruction>,\n    availableEndpoints: (Viewport | ViewportScope)[],\n    matchedInstructions: RoutingInstruction[],\n    doesntNeedViewportDescribed: boolean = false,\n  ): void {\n    let instruction: RoutingInstruction | null;\n    while ((instruction = routingInstructions.next()) !== null) {\n      if (\n        // The endpoint is already known and it's not an add instruction...\n        instruction.endpoint.instance !== null && !instruction.isAdd(router) &&\n        // ...(and of the type we're currently checking)...\n        instruction.endpoint.endpointType === type\n      ) {\n        // ...match the endpoint, updating the instruction!, and set the scope\n        // for the next scope instructions (\"children\") to the endpoint's scope...\n        EndpointMatcher.matchEndpoint(\n          instruction,\n          instruction.endpoint.instance as Viewport | ViewportScope,\n          doesntNeedViewportDescribed,\n        );\n        // ...add the matched instruction as a matched instruction...\n        matchedInstructions.push(instruction);\n        // ...remove the endpoint as available...\n        arrayRemove(availableEndpoints, available => available === instruction!.endpoint.instance);\n        // ...and finally delete the routing instructions to prevent further processing of it.\n        routingInstructions.removeCurrent();\n      }\n    }\n  }\n\n  private static matchViewportScopeSegment(\n    router: IRouter,\n    routingScope: RoutingScope,\n    routingInstructions: Collection<RoutingInstruction>,\n    availableEndpoints: (Viewport | ViewportScope)[],\n    matchedInstructions: RoutingInstruction[],\n  ): void {\n    let instruction: RoutingInstruction | null;\n\n    while ((instruction = routingInstructions.next()) !== null) {\n      for (let endpoint of availableEndpoints) {\n        if (!(endpoint instanceof ViewportScope)) {\n          continue;\n        }\n        // Check if viewport scope accepts (wants) the path/route segment\n        if (endpoint.acceptSegment(instruction.component.name!)) {\n          // If the viewport scope is a list of viewport scopes...\n          if (Array.isArray(endpoint.source)) { // TODO(alpha): Remove this functionality temporarily for alpha\n            // ...see if there's any already existing list entry that's available...\n            let available = availableEndpoints.find(available => available instanceof ViewportScope && available.name === endpoint.name);\n            // ...otherwise create one (adding it to the list) and...\n            if (available === void 0 || instruction.isAdd(router)) {\n              const item = endpoint.addSourceItem();\n              available = routingScope.getOwnedScopes()\n                .filter(scope => scope.isViewportScope)\n                .map(scope => scope.endpoint as ViewportScope)\n                .find(viewportScope => viewportScope.sourceItem === item)!;\n            }\n            // ...use the available one as endpoint.\n            endpoint = available;\n          }\n          // Match the instruction with the endpoint and add its next scope instructions (\"children\")\n          // to be processed in the call to `matchEndpoints` for the next scope.\n          // Parameter `doesntNeedViewportDescribed` is set to false since described\n          // viewports isn applicable on viewport scopes.\n          EndpointMatcher.matchEndpoint(instruction, endpoint, false);\n          // Add the matched instruction to the result\n          matchedInstructions.push(instruction);\n          // Remove the endpoint from available endpoints\n          arrayRemove(availableEndpoints, available => available === instruction!.endpoint.instance);\n          // Remove the matched instruction from the currently processed instruction\n          routingInstructions.removeCurrent();\n          break;\n        }\n      }\n    }\n  }\n\n  private static matchViewportConfiguration(\n    routingInstructions: Collection<RoutingInstruction>,\n    availableEndpoints: (Viewport | ViewportScope)[],\n    matchedInstructions: RoutingInstruction[],\n  ): void {\n    let instruction: RoutingInstruction | null;\n    while ((instruction = routingInstructions.next()) !== null) {\n      for (const endpoint of availableEndpoints) {\n        if (!(endpoint instanceof Viewport)) {\n          continue;\n        }\n        // Check if a viewport has \"ownership\"/is the only target of a component\n        if (endpoint?.wantComponent(instruction.component.name!)) {\n          // Match the instruction with the endpoint and add its next scope instructions (\"children\")\n          // to be processed in the call to `matchEndpoints` for the next scope.\n          // Parameter `doesntNeedViewportDescribed` is set to true since it's the\n          // configuration on the viewport that matches the instruction.\n          EndpointMatcher.matchEndpoint(instruction, endpoint, true);\n          // Add the matched instruction to the result\n          matchedInstructions.push(instruction);\n          // Remove the endpoint from available endpoints\n          arrayRemove(availableEndpoints, available => available === instruction!.endpoint.instance);\n          // Remove the matched instruction from the currently processed instruction\n          routingInstructions.removeCurrent();\n          break;\n        }\n      }\n    }\n  }\n\n  private static matchSpecifiedViewport(\n    routingInstructions: Collection<RoutingInstruction>,\n    availableEndpoints: (Viewport | ViewportScope)[],\n    matchedInstructions: RoutingInstruction[],\n    disregardViewports: boolean,\n  ): void {\n    let instruction: RoutingInstruction | null;\n\n    while ((instruction = routingInstructions.next()) !== null) {\n      let viewport = instruction.endpoint.instance as Viewport;\n      // If instruction don't have a viewport instance...\n      if (viewport == null) {\n        const name = instruction.endpoint.name;\n        // ...but a viewport name...\n        if ((name?.length ?? 0) === 0) {\n          continue;\n        }\n        // TODO(alpha): No longer pre-creating viewports here. Evaluate!\n        // const newScope = instruction.ownsScope;\n        // ...look through all available endpoints...\n        for (const endpoint of availableEndpoints) {\n          if (!(endpoint instanceof Viewport)) {\n            continue;\n          }\n          // ...and use the one with the matching name.\n          if (name === endpoint.name) {\n            viewport = endpoint;\n            break;\n          }\n          // TODO(alpha): No longer pre-creating viewports here. Evaluate!\n          // routingScope.addViewport(name!, null, { scope: newScope, forceDescription: true });\n          // availableViewports[name!] = routingScope.getEnabledViewports(ownedScopes)[name!];\n        }\n      }\n      // Check if the matching viewport accepts this component.\n      if (viewport?.acceptComponent(instruction.component.name!)) {\n        // Match the instruction with the endpoint and add its next scope instructions (\"children\")\n        // to be processed in the call to `matchEndpoints` for the next scope.\n        // Parameter `doesntNeedViewportDescribed` is set to `disregardViewports` since the time of\n        // invocation and whether viewport is part of that decides if it's needed.\n        EndpointMatcher.matchEndpoint(instruction, viewport, disregardViewports);\n        // Add the matched instruction to the result\n        matchedInstructions.push(instruction);\n        // Remove the endpoint from available endpoints\n        arrayRemove(availableEndpoints, available => available === instruction!.endpoint.instance);\n        // Remove the matched instruction from the currently processed instruction\n        routingInstructions.removeCurrent();\n      }\n    }\n  }\n\n  private static matchLastViewport(\n    routingInstructions: Collection<RoutingInstruction>,\n    availableEndpoints: (Viewport | ViewportScope)[],\n    matchedInstructions: RoutingInstruction[],\n  ): void {\n    let instruction: RoutingInstruction | null;\n\n    while ((instruction = routingInstructions.next()) !== null) {\n      // All remaining available viewports...\n      const availableViewports: Viewport[] = [];\n      for (const endpoint of availableEndpoints) {\n        if (!(endpoint instanceof Viewport)) {\n          continue;\n        }\n        // ...that accepts the instruction.\n        if (endpoint.acceptComponent(instruction.component.name!)) {\n          availableViewports.push(endpoint);\n        }\n      }\n      if (availableViewports.length === 1) {\n        const viewport = availableViewports[0];\n        // Match the instruction with the endpoint and add its next scope instructions (\"children\")\n        // to be processed in the call to `matchEndpoints` for the next scope.\n        // Parameter `doesntNeedViewportDescribed` is set to `true` since the viewport is the only\n        // available option.\n        EndpointMatcher.matchEndpoint(instruction, viewport, true);\n        // Add the matched instruction to the result\n        matchedInstructions.push(instruction);\n        // Remove the endpoint from available endpoints\n        arrayRemove(availableEndpoints, available => available === instruction!.endpoint.instance);\n        // Remove the matched instruction from the currently processed instruction\n        routingInstructions.removeCurrent();\n      }\n    }\n  }\n\n  private static matchEndpoint(instruction: RoutingInstruction, endpoint: Viewport | ViewportScope, doesntNeedViewportDescribed: boolean): void {\n    instruction.endpoint.set(endpoint);\n    if (doesntNeedViewportDescribed) {\n      instruction.needsEndpointDescribed = false;\n    }\n    // Get all the next scope instructions...\n    if (instruction.hasNextScopeInstructions) {\n      instruction.nextScopeInstructions!.forEach(next => {\n        if (next.scope === null) {\n          // ...and set the endpoint's routing scope as their scope\n          next.scope = endpoint instanceof Viewport ? endpoint.scope : endpoint.scope.scope;\n        }\n      });\n    }\n  }\n}\n", "/* eslint-disable prefer-template */\nimport { NavigationCoordinator } from './navigation-coordinator';\nimport { IViewportScopeOptions, ViewportScope } from './endpoints/viewport-scope';\nimport { CustomElement, ICustomElementController, ICustomElementViewModel } from '@aurelia/runtime-html';\nimport { FoundRoute } from './found-route';\nimport { IRouter } from './router';\nimport { RoutingInstruction } from './instructions/routing-instruction';\nimport { Viewport } from './endpoints/viewport';\nimport { IViewportOptions } from './endpoints/viewport-options';\nimport { IConfigurableRoute, RouteRecognizer } from './route-recognizer';\nimport { Runner, Step } from './utilities/runner';\nimport { IRoute, Route } from './route';\nimport { Endpoint, EndpointTypeName, IConnectedCustomElement } from './endpoints/endpoint';\nimport { EndpointMatcher } from './endpoint-matcher';\nimport { EndpointContent, Router } from './index';\nimport { IContainer } from '@aurelia/kernel';\nimport { arrayUnique } from './utilities/utils';\nimport { Parameters } from './instructions/instruction-parameters';\nimport { Separators } from './router-options';\n\nexport type TransitionAction = 'skip' | 'reload' | 'swap' | '';\n\n/**\n * The router uses routing scopes to organize all endpoints (viewports and viewport\n * scopes) into two hierarchical structures. Each routing scope belongs to a parent/child\n * hierarchy, that follows the DOM and is used when routing scopes are added and removed,\n * and an owner/owning hierarchy that's used when finding endpoints. Every routing scope\n * has a routing scope that owns it (except the root) and can in turn have several\n * routing scopes that it owns. A routing scope always has a connected endpoint content\n * and an endpoint content always has a connected routing scope.\n *\n * Every navigtion/load instruction that the router processes is first tied to a\n * routing scope, either a specified scope or the root scope. That routing scope is\n * then asked to\n * 1a) find routes (and their routing instructions) in the load instruction based on\n * the endpoint and its content (configured routes), and/or\n * 1b) find (direct) routing instructions in the load instruction.\n *\n * After that, the routing scope is used to\n * 2) match each of its routing instructions to an endpoint (viewport or viewport scope), and\n * 3) set the scope of the instruction to the next routing scopes (\"children\") and pass\n * the instructions on for matching in their new routing scopes.\n *\n * Once (component) transitions start in endpoints, the routing scopes assist by\n * 4) propagating routing hooks vertically through the hierarchy and disabling and\n * enabling endpoint contents and their routing data (routes) during transitions.\n *\n * Finally, when a navigation is complete, the routing scopes helps\n * 5) structure all existing routing instructions into a description of the complete\n * state of all the current endpoints and their contents.\n *\n * The hierarchy of the owner/owning routing scopes often follows the parent/child DOM\n * hierarchy, but it's not a necessity; it's possible to have routing scopes that doesn't\n * create their own \"owning capable scope\", and thus placing all their \"children\" under the\n * same \"parent\" as themselves or for a routing scope to hoist itself up or down in the\n * hierarchy and, for example, place itself as a \"child\" to a DOM sibling endpoint.\n * (Scope self-hoisting will not be available for early-on alpha.)\n */\n\nexport class RoutingScope {\n  /** @internal */\n  private static lastId = 0;\n\n  public id = ++RoutingScope.lastId;\n\n  /**\n   * The parent of the routing scope (parent/child hierarchy)\n   */\n  public parent: RoutingScope | null = null;\n  /**\n   * The children of the routing scope (parent/child hierarchy)\n   */\n  public children: RoutingScope[] = [];\n\n  public readonly router: IRouter;\n  /**\n   * Whether the routing scope has a scope and can own other scopes\n   */\n  public readonly hasScope: boolean;\n\n  /**\n   * The routing scope that owns this routing scope (owner/owning hierarchy)\n   */\n  public owningScope: RoutingScope | null;\n\n  /**\n   * The endpoint content the routing scope is connected to\n   */\n  public endpointContent: EndpointContent;\n\n  public constructor(\n    router: IRouter,\n    /**\n     * Whether the routing scope has a scope and can own other scopes\n     */\n    hasScope: boolean,\n\n    /**\n     * The routing scope that owns this routing scope (owner/owning hierarchy)\n     */\n    owningScope: RoutingScope | null,\n\n    /**\n     * The endpoint content the routing scope is connected to\n     */\n    endpointContent: EndpointContent,\n  ) {\n    this.router = router;\n    this.hasScope = hasScope;\n    this.owningScope = owningScope ?? this;\n    this.endpointContent = endpointContent;\n  }\n\n  public static for(\n    origin: Element | ICustomElementViewModel | Viewport | ViewportScope | RoutingScope | ICustomElementController | IContainer | null,\n    instruction?: string\n  ): { scope: RoutingScope | null; instruction: string | undefined } {\n\n    if (origin == null) {\n      return { scope: null, instruction };\n    }\n    if (origin instanceof RoutingScope || origin instanceof Viewport || origin instanceof ViewportScope) {\n      return { scope: origin.scope, instruction };\n    }\n    // return this.getClosestScope(origin) || this.rootScope!.scope;\n    let container: IContainer | null | undefined;\n\n    // res is a private prop of IContainer impl\n    // TODO: should use a different way to detect if something is a container\n    // or move this to the bottom if this else-if\n    if ('res' in origin) {\n      container = origin as IContainer;\n    } else {\n      if ('container' in origin) {\n        container = origin.container;\n      } else if ('$controller' in origin) {\n        container = origin.$controller!.container;\n      } else {\n        const controller = CustomElement.for(origin as Node, { searchParents: true });\n        container = controller?.container;\n      }\n    }\n    if (container == null) {\n      if (__DEV__) {\n        // eslint-disable-next-line no-console\n        console.warn(\"RoutingScope failed to find a container for provided origin\", origin);\n      }\n      return { scope: null, instruction };\n    }\n    const closestEndpoint = (container.has(Router.closestEndpointKey, true)\n      ? container.get(Router.closestEndpointKey)\n      : null) as Endpoint | null;\n\n    let scope = closestEndpoint?.scope ?? null;\n\n    if (scope === null || instruction === undefined) {\n      const safeInstruction = instruction ?? '';\n      return { scope, instruction: safeInstruction.startsWith('/') ? safeInstruction.slice(1) : instruction };\n    }\n\n    // Instruction specifies from root scope\n    if (instruction.startsWith('/')) {\n      return { scope: null, instruction: instruction.slice(1) };\n    }\n    // Instruction specifies scope traversals\n    while (instruction.startsWith('.')) {\n      // The same as no scope modification\n      if (instruction.startsWith('./')) {\n        instruction = instruction.slice(2);\n      } else if (instruction.startsWith('../')) { // Traverse upwards\n        scope = scope.parent ?? scope;\n        instruction = instruction.slice(3);\n      } else { // Bad traverse instruction\n        break;\n      }\n    }\n    // Testing without this since it seems to be removed\n    // if (scope?.path != null) {\n    //   instruction = `${scope.path}/${instruction}`;\n    //   scope = null; // scope.root;\n    // }\n    return { scope, instruction };\n  }\n\n  /**\n   * The routing scope children to this scope are added to. If this routing\n   * scope has scope, this scope property equals this scope itself. If it\n   * doesn't have scope this property equals the owning scope. Using this\n   * ensures that routing scopes that don't have a their own scope aren't\n   * part of the owner/owning hierarchy.\n   */\n  public get scope(): RoutingScope {\n    return this.hasScope ? this : this.owningScope!.scope;\n  }\n  public get endpoint(): Endpoint {\n    return this.endpointContent.endpoint;\n  }\n  public get isViewport(): boolean {\n    return this.endpoint instanceof Viewport;\n  }\n  public get isViewportScope(): boolean {\n    return this.endpoint instanceof ViewportScope;\n  }\n\n  public get type(): string {\n    return this.isViewport ? 'Viewport' : 'ViewportScope';\n  }\n\n  public get enabled(): boolean {\n    return this.endpointContent.isActive;\n  }\n\n  public get passThroughScope(): boolean {\n    return this.isViewportScope && (this.endpoint as ViewportScope).passThroughScope;\n  }\n\n  public get pathname(): string {\n    return `${this.owningScope !== this ? this.owningScope!.pathname : ''}/${this.endpoint.name}`;\n  }\n\n  public get path(): string {\n    const parentPath = this.parent?.path ?? '';\n    const path = this.routingInstruction?.stringify(this.router, { endpointContext: true }, true) ?? '';\n    const sep = this.routingInstruction ? Separators.for(this.router).scope : '';\n    return `${parentPath}${path}${sep}`;\n  }\n\n  public toString(recurse = false): string {\n    return `${this.owningScope !== this ? this.owningScope!.toString() : ''}/${!this.enabled ? '(' : ''}${this.endpoint.toString()}#${this.id}${!this.enabled ? ')' : ''}` +\n      `${recurse ? `\\n` + this.children.map(child => child.toString(true)).join('') : ''}`;\n  }\n\n  public toStringOwning(recurse = false): string {\n    return `${this.owningScope !== this ? this.owningScope!.toString() : ''}/${!this.enabled ? '(' : ''}${this.endpoint.toString()}#${this.id}${!this.enabled ? ')' : ''}` +\n      `${recurse ? `\\n` + this.ownedScopes.map(child => child.toStringOwning(true)).join('') : ''}`;\n  }\n\n  public get enabledChildren(): RoutingScope[] {\n    return this.children.filter(scope => scope.enabled);\n  }\n  public get hoistedChildren(): RoutingScope[] {\n    const scopes = this.enabledChildren;\n    while (scopes.some(scope => scope.passThroughScope)) {\n      for (const scope of scopes.slice()) {\n        if (scope.passThroughScope) {\n          const index = scopes.indexOf(scope);\n          scopes.splice(index, 1, ...scope.enabledChildren);\n        }\n      }\n    }\n    return scopes;\n  }\n  public get ownedScopes(): RoutingScope[] {\n    return this.getOwnedScopes();\n  }\n\n  public get routingInstruction(): RoutingInstruction | null {\n    if (this.endpoint.isViewportScope) {\n      return (this.endpoint as ViewportScope).instruction;\n    }\n    if (this.isViewport) {\n      return (this.endpoint as Viewport).activeContent.instruction;\n    }\n    return null;\n  }\n\n  public getOwnedScopes(includeDisabled: boolean = false): RoutingScope[] {\n    const scopes = this.allScopes(includeDisabled).filter(scope => scope.owningScope === this);\n    // Hoist children to pass through scopes\n    for (const scope of scopes.slice()) {\n      if (scope.passThroughScope) {\n        const index = scopes.indexOf(scope);\n        scopes.splice(index, 1, ...scope.getOwnedScopes());\n      }\n    }\n    return scopes;\n  }\n\n  public findInstructions(instructions: RoutingInstruction[], useDirectRouting: boolean, useConfiguredRoutes: boolean): FoundRoute {\n    const router = this.router;\n    let route = new FoundRoute();\n\n    if (useConfiguredRoutes && !RoutingInstruction.containsSiblings(router, instructions)) {\n      let clearInstructions = instructions.filter(instruction => instruction.isClear(router) || instruction.isClearAll(router));\n      const nonClearInstructions = instructions.filter(instruction => !instruction.isClear(router) && !instruction.isClearAll(router));\n\n      // As long as the sibling constraint (above) is in, this will only be at most one instruction\n      if (nonClearInstructions.length > 0) {\n        for (const instruction of nonClearInstructions) {\n          const idOrPath = typeof instruction.route === 'string'\n            ? instruction.route\n            : instruction.unparsed ?? RoutingInstruction.stringify(router, [instruction]);\n          const foundRoute = this.findMatchingRoute(idOrPath, instruction.parameters.parametersRecord ?? {});\n          if (foundRoute.foundConfiguration) {\n            route = foundRoute!;\n            route.instructions = [...clearInstructions, ...route.instructions];\n            clearInstructions = [];\n          } else if (useDirectRouting) {\n            route.instructions = [...clearInstructions, ...route.instructions, instruction];\n            clearInstructions = [];\n            route.remaining = RoutingInstruction.stringify(router, instruction.nextScopeInstructions ?? []);\n          } else {\n            throw new Error(`No route found for: ${RoutingInstruction.stringify(router, instructions)}!`);\n          }\n        }\n      } else {\n        route.instructions = [...clearInstructions];\n      }\n    } else if (useDirectRouting) {\n      route.instructions.push(...instructions);\n    } else {\n      throw new Error(`No way to process sibling viewport routes with direct routing disabled: ${RoutingInstruction.stringify(router, instructions)}!`);\n    }\n\n    // Remove empty instructions so that default can be used\n    route.instructions = route.instructions.filter(instr => instr.component.name !== '');\n\n    for (const instruction of route.instructions) {\n      if (instruction.scope === null) {\n        instruction.scope = this;\n      }\n    }\n\n    return route;\n  }\n\n  // Note: This can't change state other than the instructions!\n  /**\n   * Match the instructions to available endpoints within, and with the help of, their scope.\n   *\n   * @param instructions - The instructions to matched\n   * @param alreadyFound - The already found matches\n   * @param disregardViewports - Whether viewports should be ignored when matching\n   */\n  public matchEndpoints(instructions: RoutingInstruction[], alreadyFound: RoutingInstruction[], disregardViewports: boolean = false): { matchedInstructions: RoutingInstruction[]; remainingInstructions: RoutingInstruction[] } {\n    const allMatchedInstructions: RoutingInstruction[] = [];\n    const scopeInstructions = instructions.filter(instruction => (instruction.scope ?? this) === this);\n    const allRemainingInstructions = instructions.filter(instruction => (instruction.scope ?? this) !== this);\n\n    const { matchedInstructions, remainingInstructions } = EndpointMatcher.matchEndpoints(this, scopeInstructions, alreadyFound, disregardViewports);\n    allMatchedInstructions.push(...matchedInstructions);\n    allRemainingInstructions.push(...remainingInstructions);\n\n    return { matchedInstructions: allMatchedInstructions, remainingInstructions: allRemainingInstructions };\n  }\n\n  public addEndpoint(type: EndpointTypeName, name: string, connectedCE: IConnectedCustomElement | null, options: IViewportOptions | IViewportScopeOptions = {}): Viewport | ViewportScope {\n    let endpoint: Endpoint | null = this.getOwnedScopes()\n      .find(scope => scope.type === type &&\n        scope.endpoint.name === name)?.endpoint ?? null;\n\n    // Each endpoint element has its own Endpoint\n    if (connectedCE != null && endpoint?.connectedCE != null && endpoint.connectedCE !== connectedCE) {\n      endpoint = this.getOwnedScopes(true)\n        .find(scope => scope.type === type &&\n          scope.endpoint.name === name &&\n          scope.endpoint.connectedCE === connectedCE)?.endpoint\n        ?? null;\n    }\n\n    if (endpoint == null) {\n      endpoint = type === 'Viewport'\n        ? new Viewport(this.router, name, connectedCE, this.scope, !!(options as IViewportOptions).scope, options)\n        : new ViewportScope(this.router, name, connectedCE, this.scope, true, null, options);\n      this.addChild(endpoint.connectedScope);\n    }\n    if (connectedCE != null) {\n      endpoint.setConnectedCE(connectedCE, options);\n    }\n    return endpoint as Viewport | ViewportScope;\n  }\n\n  public removeEndpoint(step: Step | null, endpoint: Endpoint, connectedCE: IConnectedCustomElement | null): boolean {\n    if (((connectedCE ?? null) !== null) || endpoint.removeEndpoint(step, connectedCE)) {\n      this.removeChild(endpoint.connectedScope);\n      return true;\n    }\n    return false;\n  }\n\n  public addChild(scope: RoutingScope): void {\n    if (!this.children.some(vp => vp === scope)) {\n      if (scope.parent !== null) {\n        scope.parent.removeChild(scope);\n      }\n      this.children.push(scope);\n      scope.parent = this;\n    }\n  }\n  public removeChild(scope: RoutingScope): void {\n    const index = this.children.indexOf(scope);\n    if (index >= 0) {\n      this.children.splice(index, 1);\n      scope.parent = null;\n    }\n  }\n\n  public allScopes(includeDisabled: boolean = false): RoutingScope[] {\n    const scopes: RoutingScope[] = includeDisabled ? this.children.slice() : this.enabledChildren;\n    for (const scope of scopes.slice()) {\n      scopes.push(...scope.allScopes(includeDisabled));\n    }\n    return scopes;\n  }\n\n  public reparentRoutingInstructions(): RoutingInstruction[] | null {\n    const scopes = this.hoistedChildren\n      .filter(scope => scope.routingInstruction !== null && scope.routingInstruction.component.name);\n    if (!scopes.length) {\n      return null;\n    }\n    for (const scope of scopes) {\n      const childInstructions = scope.reparentRoutingInstructions();\n      scope.routingInstruction!.nextScopeInstructions =\n        childInstructions !== null && childInstructions.length > 0 ? childInstructions : null;\n    }\n    return scopes.map(scope => scope.routingInstruction!);\n  }\n\n  public getChildren(timestamp: number): RoutingScope[] {\n    const contents = this.children\n      .map(scope => scope.endpoint.getTimeContent(timestamp))\n      .filter(content => content !== null) as EndpointContent[];\n    return contents.map(content => content.connectedScope);\n  }\n\n  public getAllRoutingScopes(timestamp: number): RoutingScope[] {\n    const scopes = this.getChildren(timestamp);\n    for (const scope of scopes.slice()) {\n      scopes.push(...scope.getAllRoutingScopes(timestamp));\n    }\n    return scopes;\n  }\n\n  public getOwnedRoutingScopes(timestamp: number): RoutingScope[] {\n    const scopes = this.getAllRoutingScopes(timestamp)\n      .filter(scope => scope.owningScope === this);\n    // Hoist children to pass through scopes\n    for (const scope of scopes.slice()) {\n      if (scope.passThroughScope) {\n        const passThrough = scopes.indexOf(scope);\n        scopes.splice(passThrough, 1, ...scope.getOwnedRoutingScopes(timestamp));\n      }\n    }\n    return arrayUnique(scopes);\n  }\n\n  public getRoutingInstructions(timestamp: number): RoutingInstruction[] | null {\n    const contents = arrayUnique(\n      this.getOwnedRoutingScopes(timestamp) // hoistedChildren\n        .map(scope => scope.endpoint)\n    )\n      .map(endpoint => endpoint.getTimeContent(timestamp))\n      .filter(content => content !== null) as EndpointContent[];\n    const instructions = [];\n\n    for (const content of contents) {\n      const instruction = content.instruction.clone(true, false, false);\n      if ((instruction.component.name ?? '') !== '') {\n        instruction.nextScopeInstructions = content.connectedScope.getRoutingInstructions(timestamp);\n        instructions.push(instruction);\n      }\n    }\n    return instructions;\n  }\n\n  public canUnload(coordinator: NavigationCoordinator, step: Step<boolean> | null): boolean | Promise<boolean> {\n    return Runner.run(step,\n      (stepParallel: Step<boolean>) => {\n        return Runner.runParallel(stepParallel,\n          ...this.children.map(child => child.endpoint !== null\n            ? (childStep: Step<boolean>) => child.endpoint.canUnload(coordinator, childStep)\n            : (childStep: Step<boolean>) => child.canUnload(coordinator, childStep)\n          ));\n      },\n      (step: Step<boolean>) => (step.previousValue as boolean[]).every(result => result ?? true)) as boolean | Promise<boolean>;\n  }\n\n  public unload(coordinator: NavigationCoordinator, step: Step<void> | null): Step<void> {\n    return Runner.runParallel(step,\n      ...this.children.map(child => child.endpoint !== null\n        ? (childStep: Step<void>) => child.endpoint.unload(coordinator, childStep)\n        : (childStep: Step<void>) => child.unload(coordinator, childStep)\n      )) as Step<void>;\n  }\n\n  public matchScope(instructions: RoutingInstruction[], deep = false): RoutingInstruction[] {\n    const matching: RoutingInstruction[] = [];\n\n    for (const instruction of instructions) {\n      if (instruction.scope === this) {\n        matching.push(instruction);\n      } else if (deep && instruction.hasNextScopeInstructions) {\n        matching.push(...this.matchScope(instruction.nextScopeInstructions!, deep));\n      }\n    }\n    return matching;\n  }\n\n  public findMatchingRoute(path: string, parameters: Parameters): FoundRoute {\n    let found: FoundRoute = new FoundRoute();\n    if (this.isViewportScope && !this.passThroughScope) {\n      found = this.findMatchingRouteInRoutes(path, this.endpoint.getRoutes(), parameters);\n    } else if (this.isViewport) {\n      found = this.findMatchingRouteInRoutes(path, this.endpoint.getRoutes(), parameters);\n    } else {\n      for (const child of this.enabledChildren) {\n        found = child.findMatchingRoute(path, parameters);\n        if (found.foundConfiguration) {\n          break;\n        }\n      }\n    }\n\n    if (found.foundConfiguration) {\n      return found;\n    }\n\n    if (this.parent != null) {\n      return this.parent.findMatchingRoute(path, parameters);\n    }\n\n    return found;\n  }\n\n  private findMatchingRouteInRoutes(path: string, routes: Route[], parameters: Parameters): FoundRoute {\n    const found = new FoundRoute();\n    if (routes.length === 0) {\n      return found;\n    }\n\n    routes = routes.map(route => this.ensureProperRoute(route));\n\n    const cRoutes: IConfigurableRoute[] = [];\n    for (const route of routes) {\n      const paths = (Array.isArray(route.path) ? route.path : [route.path]);\n      for (const path of paths) {\n        cRoutes.push({\n          ...route,\n          path,\n          handler: route,\n        });\n        if (path !== '') {\n          cRoutes.push({\n            ...route,\n            path: `${path}/*remainingPath`,\n            handler: route,\n          });\n        }\n      }\n    }\n\n    if (path.startsWith('/') || path.startsWith('+')) {\n      path = path.slice(1);\n    }\n\n    const idRoute = routes.find(route => route.id === path);\n    let result = { params: {}, endpoint: {} } as any;\n    if (idRoute != null) {\n      result.endpoint = { route: { handler: idRoute } };\n      path = Array.isArray(idRoute.path) ? idRoute.path[0] : idRoute.path;\n      const segments = path.split('/').map(segment => {\n        if (segment.startsWith(':')) {\n          const name = segment.slice(1).replace(/\\?$/, '');\n          const param = parameters[name];\n          result.params[name] = param;\n          return param;\n        } else {\n          return segment;\n        }\n      });\n      path = segments.join('/');\n    } else {\n      const recognizer = new RouteRecognizer();\n\n      recognizer.add(cRoutes);\n      result = recognizer.recognize(path);\n    }\n    if (result != null) {\n      found.match = result.endpoint.route.handler;\n      found.matching = path;\n      const $params = { ...result.params };\n      if ($params.remainingPath != null) {\n        found.remaining = $params.remainingPath;\n        Reflect.deleteProperty($params, 'remainingPath');\n        found.matching = found.matching.slice(0, found.matching.indexOf(found.remaining));\n      }\n      found.params = $params;\n      if (found.match?.redirectTo != null) {\n        let redirectedTo = found.match?.redirectTo;\n        if ((found.remaining ?? '').length > 0) {\n          redirectedTo += `/${found.remaining}`;\n        }\n        return this.findMatchingRouteInRoutes(redirectedTo, routes, parameters);\n      }\n    }\n    if (found.foundConfiguration) {\n      // clone it so config doesn't get modified\n      found.instructions = RoutingInstruction.clone(found.match!.instructions as RoutingInstruction[], false, true);\n      const instructions = found.instructions.slice();\n      while (instructions.length > 0) {\n        const instruction = instructions.shift()!;\n        instruction.parameters.addParameters(found.params);\n        instruction.route = found;\n        if (instruction.hasNextScopeInstructions) {\n          instructions.unshift(...instruction.nextScopeInstructions!);\n        }\n      }\n      if (found.instructions.length > 0) {\n        found.instructions[0].routeStart = true;\n      }\n\n      const remaining = RoutingInstruction.parse(this.router, found.remaining);\n      if (remaining.length > 0) {\n        let lastInstruction = found.instructions[0];\n        while (lastInstruction.hasNextScopeInstructions) {\n          lastInstruction = lastInstruction.nextScopeInstructions![0];\n        }\n        lastInstruction.nextScopeInstructions = remaining;\n      }\n    }\n    return found;\n  }\n\n  private ensureProperRoute(route: IRoute): Route {\n    if (route.id === void 0) {\n      route.id = Array.isArray(route.path) ? route.path.join(',') : route.path;\n    }\n    if (route.instructions === void 0) {\n      route.instructions = [{\n        component: route.component!,\n        viewport: route.viewport,\n        parameters: route.parameters,\n        children: route.children,\n      }];\n    }\n    if (route.redirectTo === null) {\n      route.instructions = RoutingInstruction.from(this.router, route.instructions!);\n    }\n    return route as Route;\n  }\n}\n", "/**\n *\n * NOTE: This file is still WIP and will go through at least one more iteration of refactoring, commenting and clean up!\n * In its current state, it is NOT a good source for learning about the inner workings and design of the router.\n *\n */\nimport { ITask } from '@aurelia/platform';\nimport { IPlatform } from '@aurelia/runtime-html';\n\n/**\n * @internal - Shouldn't be used directly\n */\nexport interface IQueueableItem<T> {\n  execute: ((task: QueueTask<IQueueableItem<T>>) => void | Promise<void>);\n}\n/**\n * @internal - Shouldn't be used directly\n */\nexport type QueueableFunction = ((task: QueueTask<void>) => void | Promise<void>);\n\n/**\n * @internal - Shouldn't be used directly\n */\nexport class QueueTask<T> {\n  public done: boolean = false;\n  private readonly promise: Promise<boolean | void>;\n\n  public resolve!: ((value?: boolean | PromiseLike<boolean>) => void);\n  public reject!: ((value?: unknown) => void);\n\n  public constructor(\n    private readonly taskQueue: TaskQueue<T>,\n    public item: IQueueableItem<T> | QueueableFunction,\n    public cost = 0,\n  ) {\n    this.promise = new Promise<boolean | void>((resolve, reject) => {\n      this.resolve = () => {\n        this.taskQueue.resolve(this, resolve);\n      };\n      this.reject = (reason: unknown) => {\n        this.taskQueue.reject(this, reject, reason);\n      };\n    });\n  }\n\n  public async execute(): Promise<void> {\n    if ('execute' in this.item) {\n      await this.item.execute(this);\n    } else {\n      await this.item(this);\n    }\n  }\n  public wait(): Promise<boolean | void> {\n    return this.promise;\n  }\n}\n\nexport interface ITaskQueueOptions {\n  platform: IPlatform;\n  allowedExecutionCostWithinTick: number;\n}\n\n/**\n * A first-in-first-out task queue that only processes the next queued item\n * when the current one has been resolved or rejected. If a callback function\n * is specified, it receives the queued items as tasks one at a time. If no\n * callback is specified, the tasks themselves are either executed (if a\n * function) or the execute method in them are run. The executed function\n * should resolve or reject the task when processing is done.\n * Enqueued items' tasks can be awaited. Enqueued items can specify an\n * (arbitrary) execution cost and the queue can be set up (started) to\n * only process a specific amount of execution cost per RAF/tick.\n *\n * @internal - Shouldn't be used directly.\n */\nexport class TaskQueue<T> {\n  public get isActive(): boolean {\n    return this.task !== null;\n  }\n  public readonly pending: QueueTask<T>[] = [];\n  public processing: QueueTask<T> | null = null;\n  public allowedExecutionCostWithinTick: number | null = null;\n  public currentExecutionCostInCurrentTick: number = 0;\n  private platform: IPlatform | null = null;\n  private task: ITask | null = null;\n\n  public constructor(\n    private readonly callback?: (task: QueueTask<T>) => void\n  ) { }\n\n  public get length(): number {\n    return this.pending.length;\n  }\n\n  public start(options: ITaskQueueOptions): void {\n    this.platform = options.platform;\n    this.allowedExecutionCostWithinTick = options.allowedExecutionCostWithinTick;\n    this.task = this.platform.domQueue.queueTask(this.dequeue, { persistent: true });\n  }\n  public stop(): void {\n    this.task!.cancel();\n    this.task = null;\n    this.allowedExecutionCostWithinTick = null;\n    this.clear();\n  }\n\n  public enqueue(item: IQueueableItem<T> | QueueableFunction, cost?: number): QueueTask<T>;\n  public enqueue(items: (IQueueableItem<T> | QueueableFunction)[], cost?: number): QueueTask<T>[];\n  public enqueue(items: (IQueueableItem<T> | QueueableFunction)[], costs?: number[]): QueueTask<T>[];\n  public enqueue(task: QueueTask<T>): QueueTask<T>;\n  public enqueue(tasks: QueueTask<T>[]): QueueTask<T>[];\n  public enqueue(itemOrItems: IQueueableItem<T> | QueueableFunction | (IQueueableItem<T> | QueueableFunction)[] | QueueTask<T> | QueueTask<T>[], costOrCosts?: number | number[]): QueueTask<T> | QueueTask<T>[] {\n    const list: boolean = Array.isArray(itemOrItems);\n    const items: (IQueueableItem<T> | QueueTask<T>)[] = (list ? itemOrItems : [itemOrItems]) as (IQueueableItem<T> | QueueTask<T>)[];\n    const costs: number[] = items\n      .map((value: IQueueableItem<T> | QueueTask<T>, index: number): number | undefined => !Array.isArray(costOrCosts) ? costOrCosts : costOrCosts[index])\n      .map((value: number | undefined): number => value !== undefined ? value : 1);\n    const tasks: QueueTask<T>[] = [];\n    for (const item of items) {\n      tasks.push(item instanceof QueueTask\n        ? item\n        : this.createQueueTask(item, costs.shift())); // TODO: Get cancellable in as well\n    }\n    this.pending.push(...tasks);\n    this.dequeue();\n    return list ? tasks : tasks[0];\n  }\n\n  public createQueueTask(item: IQueueableItem<T> | QueueableFunction, cost?: number): QueueTask<T> {\n    return new QueueTask(this, item, cost);\n  }\n\n  public dequeue = (delta?: number): void => {\n    if (this.processing !== null) {\n      return;\n    }\n    if (delta !== undefined) {\n      this.currentExecutionCostInCurrentTick = 0;\n    }\n    if (this.pending.length === 0) {\n      return;\n    }\n    if (this.allowedExecutionCostWithinTick !== null && delta === undefined && this.currentExecutionCostInCurrentTick + (this.pending[0].cost || 0) > this.allowedExecutionCostWithinTick) {\n      return;\n    }\n    this.processing = this.pending.shift() || null;\n    if (this.processing) {\n      this.currentExecutionCostInCurrentTick += this.processing.cost ?? 0;\n      if (this.callback !== void 0) {\n        this.callback(this.processing);\n      } else {\n        // Don't need to await this since next task won't be dequeued until\n        // executed function is resolved\n        this.processing.execute().catch(error => { throw error; });\n      }\n    }\n  };\n\n  public clear(): void {\n    this.pending.length = 0;\n  }\n\n  /**\n   * @internal\n   */\n  public resolve(_task: QueueTask<T>, resolve: ((value: void | boolean | PromiseLike<void> | PromiseLike<boolean>) => void)): void {\n    resolve();\n    this.processing = null;\n    this.dequeue();\n  }\n  /**\n   * @internal\n   */\n  public reject(_task: QueueTask<T>, reject: ((value: unknown) => void), reason: unknown): void {\n    reject(reason);\n    this.processing = null;\n    this.dequeue();\n  }\n}\n", "import { EventAggregator, IEventAggregator, resolve } from '@aurelia/kernel';\nimport { IWindow, IHistory, ILocation, IPlatform } from '@aurelia/runtime-html';\nimport { INavigatorState, INavigatorStore, INavigatorViewer, INavigatorViewerOptions } from './navigator';\nimport { QueueTask, TaskQueue } from './utilities/task-queue';\nimport { ErrorNames, createMappedError } from './errors';\n\n/**\n * @internal\n */\nexport interface IBrowserViewerStoreOptions extends INavigatorViewerOptions {\n  /**\n   * Whether the hash part of the Location URL should be used for state. If false,\n   * the Location pathname will be used instead (sometimes referred to as \"popstate\").\n   */\n  useUrlFragmentHash?: boolean;\n}\n\n/**\n * Viewer and store layers on top of the browser. The viewer part is for getting\n * and setting a state (location) indicator and the store part is for storing\n * and retrieving historical states (locations). In the browser, the Location\n * is the viewer and the History API provides the store.\n *\n * All mutating actions towards the viewer and store are added as awaitable tasks\n * in a queue.\n *\n * Events are fired when the current state (location) changes, either through\n * direct change (manually altering the Location) or movement to a historical\n * state.\n *\n * All interaction with the browser's Location and History is performed through\n * these layers.\n *\n * @internal\n */\nexport class BrowserViewerStore implements INavigatorStore, INavigatorViewer, EventListenerObject {\n  /**\n   * Limit the number of executed actions within the same RAF (due to browser limitation).\n   */\n  public allowedExecutionCostWithinTick: number = 2;\n\n  /**\n   * State changes that have been triggered but not yet processed.\n   */\n  private readonly pendingCalls: TaskQueue<IAction> = new TaskQueue<IAction>();\n\n  /**\n   * Whether the BrowserViewerStore is started or not.\n   */\n  private isActive: boolean = false;\n\n  private options: IBrowserViewerStoreOptions = {\n    useUrlFragmentHash: true,\n  };\n\n  /**\n   * A \"forwarded state\" that's used to decide whether the browser's popstate\n   * event should fire a change state event or not. Used by 'go' method and\n   * its 'suppressEvent' option.\n   */\n  private forwardedState: IForwardedState = { eventTask: null, suppressPopstate: false };\n\n  private readonly platform: IPlatform = resolve(IPlatform);\n  private readonly window: IWindow = resolve(IWindow);\n  private readonly history: IHistory = resolve(IHistory);\n  private readonly location: ILocation = resolve(ILocation);\n  private readonly ea: EventAggregator = resolve(IEventAggregator);\n\n  public start(options: IBrowserViewerStoreOptions): void {\n    if (this.isActive) {\n      throw createMappedError(ErrorNames.browser_viewer_store_already_started);\n    }\n    this.isActive = true;\n    if (options.useUrlFragmentHash != void 0) {\n      this.options.useUrlFragmentHash = options.useUrlFragmentHash;\n    }\n    this.pendingCalls.start({ platform: this.platform, allowedExecutionCostWithinTick: this.allowedExecutionCostWithinTick });\n    this.window.addEventListener('popstate', this);\n  }\n\n  public stop(): void {\n    if (!this.isActive) {\n      throw createMappedError(ErrorNames.browser_viewer_store_not_started);\n    }\n    this.window.removeEventListener('popstate', this);\n    this.pendingCalls.stop();\n    this.options = { useUrlFragmentHash: true };\n    this.isActive = false;\n  }\n\n  public get length(): number {\n    return this.history.length;\n  }\n\n  /**\n   * The stored state for the current state/location.\n   */\n  public get state(): Record<string, unknown> {\n    return this.history.state as Record<string, unknown>;\n  }\n\n  /**\n   * Get the viewer's (browser Location) current state/location (URL).\n   */\n  public get viewerState(): NavigatorViewerState {\n    const { pathname, search, hash } = this.location;\n    const instruction = (this.options.useUrlFragmentHash ?? false)\n      ? hash.slice(1)\n      : `${pathname}${search}`;\n    const fragment = (this.options.useUrlFragmentHash ?? false)\n      ? (hash.slice(1).includes('#') ? hash.slice(hash.slice(1).indexOf('#', 1)) : '')\n      : hash.slice(1);\n    return new NavigatorViewerState(\n      pathname,\n      search.slice(1),\n      fragment,\n      instruction,\n    );\n  }\n\n  /**\n   * Enqueue an awaitable 'go' task that navigates delta amount of steps\n   * back or forward in the states history.\n   *\n   * @param delta - The amount of steps, positive or negative, to move in the states history\n   * @param suppressEvent - If true, no state change event is fired when the go task is executed\n   */\n  public async go(delta: number, suppressEvent: boolean = false): Promise<boolean | void> {\n    const doneTask: QueueTask<IAction> = this.pendingCalls.createQueueTask((task: QueueTask<IAction>) => task.resolve(), 1);\n\n    this.pendingCalls.enqueue([\n      (task: QueueTask<IAction>) => {\n        const eventTask: QueueTask<IAction> = doneTask;\n        const suppressPopstate: boolean = suppressEvent;\n\n        // Set the \"forwarded state\" that decides whether the browser's popstate event\n        // should fire a change state event or not\n        this.forwardState({ eventTask, suppressPopstate });\n        task.resolve();\n      },\n      (task: QueueTask<IAction>) => {\n        const history: History = this.history;\n        const steps: number = delta;\n\n        history.go(steps);\n        task.resolve();\n      },\n    ], [0, 1]);\n\n    return doneTask.wait();\n  }\n\n  /**\n   * Enqueue an awaitable 'push state' task that pushes a state after the current\n   * historical state. Any pre-existing historical states after the current are\n   * discarded before the push.\n   *\n   * @param state - The state to push\n   */\n  public async pushNavigatorState(state: INavigatorState): Promise<boolean | void> {\n    const { title, path } = state.navigations[state.navigationIndex];\n    const fragment = this.options.useUrlFragmentHash ? '#/' : '';\n\n    return this.pendingCalls.enqueue(\n      (task: QueueTask<IAction>) => {\n        const history: History = this.history;\n        const data: INavigatorState = state;\n        const titleOrEmpty: string = title || '';\n        const url: string = `${fragment}${path}`;\n\n        try {\n          history.pushState(data, titleOrEmpty, url);\n          this.setTitle(titleOrEmpty);\n        } catch (err) {\n          const clean = this.tryCleanState(data, 'push', err as Error);\n          history.pushState(clean, titleOrEmpty, url);\n          this.setTitle(titleOrEmpty);\n        }\n        task.resolve();\n      }, 1).wait();\n  }\n\n  /**\n   * Enqueue an awaitable 'replace state' task that replace the current historical\n   * state with the provided  state.\n   *\n   * @param state - The state to replace with\n   */\n  public async replaceNavigatorState(state: INavigatorState, title?: string, path?: string): Promise<boolean | void> {\n    // const { title, path } = state.currentEntry;\n    const lastNavigation = state.navigations[state.navigationIndex];\n    title ??= lastNavigation.title;\n    path ??= lastNavigation.path;\n    const fragment = this.options.useUrlFragmentHash ? '#/' : '';\n\n    return this.pendingCalls.enqueue(\n      (task: QueueTask<IAction>) => {\n        const history: History = this.history;\n        const data: INavigatorState = state;\n        const titleOrEmpty: string = title || '';\n        const url: string = `${fragment}${path}`;\n\n        try {\n          history.replaceState(data, titleOrEmpty, url);\n          this.setTitle(titleOrEmpty);\n        } catch (err) {\n          const clean = this.tryCleanState(data, 'replace', err as Error);\n          history.replaceState(clean, titleOrEmpty, url);\n          this.setTitle(titleOrEmpty);\n        }\n        task.resolve();\n      }, 1).wait();\n  }\n\n  /**\n   * Enqueue an awaitable 'pop state' task that pops the last of the historical states.\n   */\n  public async popNavigatorState(): Promise<boolean | void> {\n    const doneTask: QueueTask<IAction> = this.pendingCalls.createQueueTask((task: QueueTask<IAction>) => task.resolve(), 1);\n\n    this.pendingCalls.enqueue(\n      async (task: QueueTask<IAction>): Promise<void> => {\n        const eventTask: QueueTask<IAction> = doneTask;\n\n        await this.popState(eventTask);\n        task.resolve();\n      }, 1);\n    return doneTask.wait();\n  }\n\n  public setTitle(title: string): void {\n    this.window.document.title = title;\n  }\n\n  /**\n   * Handle the browsers PopStateEvent\n   *\n   * @param event - The browser's PopStateEvent\n   */\n  public handleEvent(e: Event): void {\n    this.handlePopStateEvent(e as PopStateEvent);\n  }\n\n  /**\n   * Enqueue an awaitable 'pop state' task when the viewer's state (browser's\n   * Location) changes.\n   *\n   * @param event - The browser's PopStateEvent\n   */\n  private handlePopStateEvent(event: PopStateEvent): void {\n    const { eventTask, suppressPopstate } = this.forwardedState;\n    this.forwardedState = { eventTask: null, suppressPopstate: false };\n\n    this.pendingCalls.enqueue(\n      async (task: QueueTask<IAction>) => {\n        if (!suppressPopstate) {\n          this.notifySubscribers(event);\n        }\n        if (eventTask !== null) {\n          await eventTask.execute();\n        }\n        task.resolve();\n      }, 1);\n  }\n\n  /**\n   * Notifies subscribers that the state has changed\n   *\n   * @param ev - The browser's popstate event\n   */\n  private notifySubscribers(ev: PopStateEvent): void {\n    this.ea.publish(\n      NavigatorStateChangeEvent.eventName,\n      NavigatorStateChangeEvent.create(this.viewerState, ev, this.history.state as INavigatorState)\n    );\n  }\n\n  /**\n   * Pop the last historical state by re-pushing the second to last\n   * historical state (since browser History doesn't have a popState).\n   *\n   * @param doneTask - Task to execute once pop is done\n   */\n  private async popState(doneTask: QueueTask<IAction>): Promise<void> {\n    await this.go(-1, true);\n    const state = this.history.state as INavigatorState;\n    // TODO: Fix browser forward bug after pop on first entry\n    const lastNavigation = state?.navigations?.[state?.navigationIndex ?? 0];\n    if (lastNavigation != null && !lastNavigation.firstEntry) {\n      await this.go(-1, true);\n      await this.pushNavigatorState(state);\n    }\n    await doneTask.execute();\n  }\n\n  /**\n   * Set the \"forwarded state\" that decides whether the browser's popstate event\n   * should fire a change state event or not.\n   *\n   * @param state - The forwarded state\n   */\n  private forwardState(state: IForwardedState): void {\n    this.forwardedState = state;\n  }\n\n  /**\n   * Tries to clean up the state for pushing or replacing to browser History.\n   *\n   * @param data - The state to attempt to clean\n   * @param type - The type of action, push or replace, that failed\n   * @param originalError - The origial error when trying to push or replace\n   */\n  private tryCleanState(data: unknown, type: 'push' | 'replace', originalError: Error): unknown {\n    try {\n      return JSON.parse(JSON.stringify(data));\n    } catch (err) {\n      throw createMappedError(ErrorNames.browser_viewer_store_state_serialization_failed, type, err, originalError);\n    }\n  }\n}\n\n/**\n * The state used when communicating with the navigator viewer.\n */\n/**\n * @internal\n */\nexport class NavigatorViewerState {\n  public constructor(\n    /**\n     * The URL (Location) path\n     */\n    public path: string,\n\n    /**\n     * The URL (Location) query\n     */\n    public query: string,\n\n    /**\n     * The URL (Location) hash\n     */\n    public hash: string,\n\n    /**\n     * The navigation instruction\n     */\n    public instruction: string,\n  ) { }\n}\n\n/**\n * @internal\n */\ninterface IForwardedState {\n  eventTask: QueueTask<IAction> | null;\n  suppressPopstate: boolean;\n}\n\n/**\n * @internal\n */\ninterface IAction {\n  execute(task: QueueTask<IAction>, resolve?: ((value?: void | boolean | PromiseLike<void> | PromiseLike<boolean>) => void) | null | undefined, suppressEvent?: boolean): void;\n}\n\nexport class NavigatorStateChangeEvent {\n  public static eventName = 'au:router:navigation-state-change';\n\n  public constructor(\n    public readonly eventName: string,\n    public readonly viewerState: NavigatorViewerState,\n    public readonly event: PopStateEvent,\n    public readonly state: INavigatorState,\n  ) { }\n  public static create(\n    viewerState: NavigatorViewerState,\n    ev: PopStateEvent,\n    navigatorState: INavigatorState,\n  ): NavigatorStateChangeEvent {\n    return new NavigatorStateChangeEvent(\n      NavigatorStateChangeEvent.eventName,\n      viewerState,\n      ev,\n      navigatorState);\n  }\n}\n", "import { IRouter } from './router';\nimport { Navigation } from './navigation';\nimport { Endpoint, IEndpoint } from './endpoints/endpoint';\nimport { OpenPromise } from './utilities/open-promise';\nimport { RoutingInstruction } from './instructions/routing-instruction';\nimport { arrayAddUnique, arrayRemove } from './utilities/utils';\nimport { Route, RoutingHook, RoutingScope, Step } from './index';\nimport { EndpointMatcher } from './endpoint-matcher';\n\n/**\n * The navigation coordinator coordinates navigation between endpoints/entities\n * and their navigation states. The coordinator keeps the endpoints synchronized\n * for the configured synchronization states, meaning that no endpoint can proceed\n * past a sync state until all endpoints have reached it. The coordinator also\n * provides synchronization on endpoint level which is used to make sure parent\n * hooks are done before child hooks start.\n *\n * Each endpoint that's involved in a navigation is added to the coordinator's\n * entities and report each completed navigation state to the coordinator\n * during the transition. Before an endpoint starts a new navigation step\n * it asks the coordinator whether it can proceed or should wait. The\n * coordinator instructs continuation if the endpoint's current step isn't\n * being synchronized or if all other endpoints have reached that state. If\n * one or more endpoints have been instructed to wait, they are instructed\n * to continue once all endpoints have reached the state they're waiting on.\n */\n\n/**\n * The different navigation states each endpoint passes through (regardless\n * of whether they have hooks or not).\n * - **guardedUnload**: fulfilled when canUnload (if any) has been called\n * - **guardedLoad**: fulfilled when canLoad (if any) has been called\n * - **guarded**: fulfilled when check hooks canUnload and canLoad (if any) have been called\n * - **unloaded**: fulfilled when unloading (if any) has been called\n * - **loaded**: fulfilled when loading (if any) has been called\n * - **routed**: fulfilled when initial routing hooks (if any) have been called\n * - **bound**: fulfilled when bind has been called\n * - **swap**:\n * - **completed**: fulfilled when everything is done\n */\nexport type NavigationState =\n  | 'guardedUnload'\n  | 'guardedLoad'\n  | 'guarded'\n  | 'unloaded'\n  | 'loaded'\n  | 'routed'\n  | 'bound'\n  | 'swapped'\n  | 'completed'\n  ;\n\n/**\n * The entity used to keep track of the endpoint and its states.\n */\nclass Entity {\n  /**\n   * Whether the entity's transition has started.\n   */\n  public running: boolean = false;\n  /**\n   * The navigation states the entity has reached.\n   */\n  public states: Map<NavigationState, OpenPromise | null> = new Map<NavigationState, OpenPromise | null>();\n  /**\n   * The navigation states the entity has checked (and therefore reached).\n   */\n  public checkedStates: NavigationState[] = [];\n\n  /**\n   * The navigation state the entity is currently syncing/waiting on.\n   */\n  public syncingState: NavigationState | null = null;\n  /**\n   * The (open) promise to resolve when the entity has reached its sync state.\n   */\n  public syncPromise: OpenPromise | null = null;\n\n  /**\n   * The Runner step that's controlling the transition in the entity.\n   */\n  public step: Step<void> | null = null;\n\n  public constructor(\n    /**\n     * The endpoint for the entity\n     */\n    public endpoint: IEndpoint\n  ) { }\n\n  /**\n   * Whether the entity has reached a specific state.\n   *\n   * @param state - The state to check\n   */\n  public hasReachedState(state: NavigationState): boolean {\n    return this.states.has(state) && this.states.get(state) === null;\n  }\n}\n\nexport class NavigationCoordinatorOptions {\n  /**\n   * The navigation states the coordinator synchronized entities on.\n   */\n  public syncStates: NavigationState[];\n\n  public constructor(input: Partial<NavigationCoordinatorOptions>) {\n    this.syncStates = input.syncStates ?? [];\n  }\n}\n\nexport class NavigationCoordinator {\n  public instructions: RoutingInstruction[] = [];\n  public matchedInstructions: RoutingInstruction[] = [];\n  public processedInstructions: RoutingInstruction[] = [];\n  public changedEndpoints: IEndpoint[] = [];\n\n  /**\n   * Whether the coordinator is running/has started entity transitions.\n   */\n  public running = false;\n\n  /**\n   * Whether the coordinator's run is completed.\n   */\n  public completed = false;\n\n  /**\n   * Whether the coordinator's run is cancelled.\n   */\n  public cancelled = false;\n\n  /**\n   * Whether the coordinator has got all endpoints added.\n   */\n  public hasAllEndpoints = false;\n\n  /**\n   * Instructions that should be appended to the navigation\n   */\n  public appendedInstructions: RoutingInstruction[] = [];\n\n  /**\n   * Whether the coordinator is closed for new appended instructions.\n   */\n  public closed = false;\n\n  /**\n   * The entities the coordinator is coordinating.\n   */\n  public readonly entities: Entity[] = [];\n\n  /**\n   * The sync states the coordinator is coordinating.\n   */\n  private readonly syncStates: Map<NavigationState, OpenPromise> = new Map<NavigationState, OpenPromise>();\n\n  /**\n   * The sync states that's been checked (by any entity).\n   */\n  private readonly checkedSyncStates: Set<NavigationState> = new Set();\n\n  public constructor(\n    private readonly router: IRouter,\n\n    /**\n     * The navigation that created the coordinator.\n     */\n    public readonly navigation: Navigation,\n  ) { }\n\n  /**\n   * Create a navigation coordinator.\n   *\n   * @param router - The router\n   * @param navigation - The navigation that creates the coordinator\n   * @param options - The navigation coordinator options\n   */\n  public static create(router: IRouter, navigation: Navigation, options: NavigationCoordinatorOptions): NavigationCoordinator {\n    const coordinator = new NavigationCoordinator(router, navigation);\n\n    // TODO: Set flow options from router\n    options.syncStates.forEach((state: NavigationState) => coordinator.addSyncState(state));\n\n    return coordinator;\n  }\n\n  /**\n   * Append instructions to the current process.\n   *\n   * @param instructions - The instructions to append\n   */\n  public appendInstructions(instructions: RoutingInstruction[]): void {\n    this.instructions.push(...instructions);\n    this.manageDefaults();\n  }\n\n  /**\n   * Remove instructions from the current process.\n   *\n   * @param instructions - The instructions to remove\n   */\n  public removeInstructions(instructions: RoutingInstruction[]): void {\n    this.instructions = this.instructions.filter(instr => !instructions.includes(instr));\n    this.matchedInstructions = this.matchedInstructions.filter(instr => !instructions.includes(instr));\n  }\n\n  private manageDefaults(): void {\n    const router = this.router;\n\n    // Process non-defaults first\n    this.instructions = [...this.instructions.filter(instr => !instr.default), ...this.instructions.filter(instr => instr.default)];\n\n    // Make sure all appended instructions have the correct scope\n    this.instructions.forEach(instruction => {\n      if (instruction.scope == null) {\n        instruction.scope = this.navigation.scope ?? this.router.rootScope?.scope ?? null;\n      }\n    });\n\n    const instructions = this.instructions.filter(instr => !instr.isClear(router));\n\n    while (instructions.length > 0) {\n      const instruction = instructions.shift() as RoutingInstruction;\n\n      // Already processed an instruction for this endpoint\n      const foundProcessed = this.processedInstructions.some(instr => !instr.isClear(router) && !instr.cancelled && instr.sameEndpoint(instruction, true));\n      // An already matched (but not processed) instruction for this endpoint\n      const existingMatched = this.matchedInstructions.find(instr => !instr.isClear(router) && instr.sameEndpoint(instruction, true));\n      // An already existing (but not matched or processed) instruction for this endpoint\n      const existingInstruction = this.instructions.find(instr => !instr.isClear(router) && instr.sameEndpoint(instruction, true) && instr !== instruction);\n\n      // If it's a default instruction that's already got a non-default in some way, remove it\n      if (instruction.default &&\n        (foundProcessed ||\n          (existingMatched !== void 0 && !existingMatched.default) ||\n          (existingInstruction !== void 0 && !existingInstruction.default))) {\n        arrayRemove(this.instructions, value => value === instruction);\n        continue;\n      }\n      // There's already a matched instruction, but it's default (or appended instruction isn't) so it should be removed\n      if (existingMatched !== void 0) {\n        arrayRemove(this.matchedInstructions, value => value === existingMatched);\n        continue;\n      }\n      // There's already an existing instruction, but it's default (or appended instruction isn't) so it should be removed\n      if (existingInstruction !== void 0) {\n        arrayRemove(this.instructions, value => value === existingInstruction);\n      }\n    }\n  }\n\n  /**\n   * Process the appended instructions, moving them to matched or remaining.\n   */\n  public async processInstructions(): Promise<IEndpoint[]> {\n    const changedEndpoints: IEndpoint[] = [];\n    let guard = 100;\n    while (this.instructions.length > 0) {\n      if (!guard--) { // Guard against endless loop\n        console.error('processInstructions endless loop', this.navigation, this.instructions);\n        throw new Error('Endless loop');\n      }\n      // Process non-defaults first (by separating and adding back)\n      this.instructions = [...this.instructions.filter(instr => !instr.default), ...this.instructions.filter(instr => instr.default)];\n\n      const scope = this.instructions[0].scope!;\n      if (scope == null) {\n        throw new Error('No scope for instruction');\n      }\n      // eslint-disable-next-line no-await-in-loop\n      changedEndpoints.push(...await this.processInstructionsForScope(scope));\n    }\n    return changedEndpoints;\n  }\n\n  public async processInstructionsForScope(scope: RoutingScope): Promise<IEndpoint[]> {\n    const router = this.router;\n    const options = router.configuration.options;\n\n    // Get all endpoints affected by any clear all routing instructions and then remove those\n    // routing instructions.\n    const clearEndpoints = this.getClearAllEndpoints(scope);\n\n    // If there are instructions for this scope that aren't part of an already found configured route...\n    const nonRouteInstructions = this.getInstructionsForScope(scope).filter(instr => !(instr.route instanceof Route));\n    if (nonRouteInstructions.length > 0) {\n      // ...find the routing instructions for them. The result will be either that there's a configured\n      // route (which in turn contains routing instructions) or a list of routing instructions\n      // TODO(return): This needs to be updated\n      const foundRoute = scope.findInstructions(nonRouteInstructions, options.useDirectRouting, options.useConfiguredRoutes);\n\n      // Make sure we got routing instructions...\n      if (nonRouteInstructions.some(instr => !instr.component.none || instr.route != null)\n        && !foundRoute.foundConfiguration\n        && !foundRoute.foundInstructions) {\n        // ...call unknownRoute hook if we didn't...\n        // TODO: Add unknownRoute hook here and put possible result in instructions\n        throw this.createUnknownRouteError(nonRouteInstructions);\n      }\n      // ...and replace the non-route instructions with the found routing instructions.\n      this.instructions.splice(this.instructions.indexOf(nonRouteInstructions[0]), nonRouteInstructions.length, ...foundRoute.instructions);\n      // // ...and use any already found and the newly found routing instructions.\n\n    }\n\n    // If there are any unresolved components (functions or promises), resolve into components\n    const unresolvedPromise = RoutingInstruction.resolve(this.getInstructionsForScope(scope));\n    if (unresolvedPromise instanceof Promise) {\n      await unresolvedPromise;\n    }\n\n    // Make sure \"add all\" instructions have the correct name and scope\n    for (const addInstruction of this.getInstructionsForScope(scope).filter(instr => instr.isAddAll(router))) {\n      addInstruction.endpoint.set(addInstruction.scope!.endpoint.name);\n      addInstruction.scope = addInstruction.scope!.owningScope!;\n    }\n\n    let guard = 100;\n    do {\n      // Match the instructions to available endpoints within, and with the help of, their scope\n      // TODO(return): This needs to be updated\n      this.matchEndpoints(scope);\n\n      if (!guard--) { // Guard against endless loop\n        router.unresolvedInstructionsError(this.navigation, this.instructions);\n      }\n      const changedEndpoints: IEndpoint[] = [];\n\n      // Get all the endpoints of matched instructions...\n      const matchedEndpoints = this.matchedInstructions.map(instr => instr.endpoint.instance);\n      // ...and create and add clear instructions for all endpoints that\n      // aren't already in an instruction.\n      this.matchedInstructions.push(...clearEndpoints\n        .filter(endpoint => !matchedEndpoints.includes(endpoint))\n        .map(endpoint => RoutingInstruction.createClear(router, endpoint)));\n\n      // TODO: Review whether this await poses a problem (it's currently necessary for new viewports to load)\n      // eslint-disable-next-line no-await-in-loop\n      const hooked = await RoutingHook.invokeBeforeNavigation(this.matchedInstructions, this.navigation);\n      if (hooked === false) {\n        router.cancelNavigation(this.navigation, this);\n        return [];\n      } else if (hooked !== true && hooked !== this.matchedInstructions) {\n        // TODO(return): Do a full findInstructions again with a new FoundRoute so that this\n        // hook can return other values as well\n        this.matchedInstructions = hooked;\n      }\n\n      for (const matchedInstruction of this.matchedInstructions) {\n        const endpoint = matchedInstruction.endpoint.instance;\n        if (endpoint !== null) {\n          // Set endpoint path to the configured route path so that it knows it's part\n          // of a configured route.\n          // Inform endpoint of new content and retrieve the action it'll take\n          const action = endpoint.setNextContent(matchedInstruction, this.navigation);\n          if (action !== 'skip') {\n            // Add endpoint to changed endpoints this iteration and to the coordinator's purview\n            changedEndpoints.push(endpoint);\n            this.addEndpoint(endpoint);\n          }\n          // We're doing something, so don't clear this endpoint...\n          const dontClear = [endpoint];\n          if (action === 'swap') {\n            // ...and none of it's _current_ children if we're swapping them out.\n            dontClear.push(...endpoint.getContent().connectedScope.allScopes(true).map(scope => scope.endpoint));\n          }\n          // Exclude the endpoints to not clear from the ones to be cleared...\n          arrayRemove(clearEndpoints, clear => dontClear.includes(clear));\n          // ...as well as already matched clear instructions (but not itself).\n          arrayRemove(this.matchedInstructions, matched => matched !== matchedInstruction\n            && matched.isClear(router) && dontClear.includes(matched.endpoint.instance!));\n          // TODO: Does the below ever happen?! Parent is never in clearEndpoints, right?\n          // And also exclude the routing instruction's parent viewport scope...\n          if (!matchedInstruction.isClear(router) && matchedInstruction.scope?.parent?.isViewportScope) {\n            // ...from clears...\n            arrayRemove(clearEndpoints, clear => clear === matchedInstruction.scope!.parent!.endpoint);\n            // ...and already matched clears.\n            arrayRemove(this.matchedInstructions, matched => matched !== matchedInstruction\n              && matched.isClear(router) && matched.endpoint.instance === matchedInstruction.scope!.parent!.endpoint);\n          }\n\n          // If the instruction has a next scope instructions, add them to the instructions\n          // to be processed next...\n          if (matchedInstruction.hasNextScopeInstructions) {\n            this.instructions.push(...matchedInstruction.nextScopeInstructions!);\n            // ...and if the endpoint has been changed/swapped, move the next scope instructions\n            // into the new endpoint content scope and clear the endpoint instance.\n            if (action !== 'skip') {\n              for (const nextScopeInstruction of matchedInstruction.nextScopeInstructions!) {\n                nextScopeInstruction.scope = endpoint.scope;\n                nextScopeInstruction.endpoint.instance = null;\n              }\n            }\n          } else {\n            // If there are no next scope instructions the endpoint's scope (its children)\n            // needs to be cleared\n            clearEndpoints.push(...(matchedInstruction.endpoint.instance as Endpoint).scope.children.map(s => s.endpoint));\n          }\n        }\n      }\n\n      // In order to make sure all relevant canUnload are run on the first run iteration\n      // we only run once all (top) instructions are doing something/there are no skip\n      // action instructions.\n      // If all first iteration instructions now do something the transitions can start\n      const skipping = this.matchedInstructions.filter(instr => instr.endpoint.instance?.transitionAction === 'skip');\n      const skippingWithMore = skipping.filter(instr => instr.hasNextScopeInstructions);\n      if (skipping.length === 0 || (skippingWithMore.length === 0)) { // TODO: !!!!!!  && !foundRoute.hasRemaining)) {\n        // If navigation is unrestricted (no other syncing done than on canUnload) we can\n        // instruct endpoints to transition\n        if (!router.isRestrictedNavigation) {\n          this.finalEndpoint();\n        }\n        this.run();\n\n        // Wait for (\"blocking\") canUnload to finish\n        if (this.hasAllEndpoints) {\n          const guardedUnload = this.waitForSyncState('guardedUnload');\n          if (guardedUnload instanceof Promise) {\n            // eslint-disable-next-line no-await-in-loop\n            await guardedUnload;\n          }\n        }\n      }\n\n      // If, for whatever reason, this navigation got cancelled, stop processing\n      if (this.cancelled) {\n        router.cancelNavigation(this.navigation, this);\n        return [];\n      }\n\n      // Add this iteration's changed endpoints (inside the loop) to the total of all\n      // updated endpoints (outside the loop)\n      arrayAddUnique(this.changedEndpoints, changedEndpoints);\n\n      // Make sure these endpoints in these instructions stays unavailable\n      this.processedInstructions.push(...this.matchedInstructions.splice(0));\n\n      // If this isn't a restricted (\"static\") navigation everything will run as soon as possible\n      // and then we need to wait for new viewports to be loaded before continuing here (but of\n      // course only if we're running)\n      // TODO: Use a better solution here (by checking and waiting for relevant viewports)\n      if (!router.isRestrictedNavigation &&\n        (this.matchedInstructions.length > 0 || this.instructions.length > 0) && this.running) {\n        const waitForSwapped = this.waitForSyncState('swapped');\n        if (waitForSwapped instanceof Promise) {\n          // eslint-disable-next-line no-await-in-loop\n          await waitForSwapped;\n        }\n      }\n\n      this.instructions.push(...clearEndpoints.map(endpoint => RoutingInstruction.createClear(router, endpoint)));\n\n      // If there are any unresolved components (functions or promises) to be appended, resolve them\n      const unresolvedPromise = RoutingInstruction.resolve(this.matchedInstructions);\n      if (unresolvedPromise instanceof Promise) {\n        // eslint-disable-next-line no-await-in-loop\n        await unresolvedPromise;\n      }\n\n      // Remove cancelled endpoints from changed endpoints (last instruction is cancelled)\n      this.changedEndpoints = this.changedEndpoints.filter(endpoint => !([...this.processedInstructions]\n        .reverse()\n        .find(instruction => instruction.endpoint.instance === endpoint)\n        ?.cancelled ?? false)\n      );\n    } while (this.matchedInstructions.length > 0 || this.getInstructionsForScope(scope).length > 0);\n\n    return this.changedEndpoints;\n  }\n\n  /**\n   * Get all instructions for a specific scope\n   */\n  public getInstructionsForScope(scope: RoutingScope): RoutingInstruction[] {\n    // Make sure instruction defaults are removed if there are non-defaults\n    this.manageDefaults();\n\n    // Always process all non-default instructions first\n    const instructions = this.instructions.filter(instr => instr.scope === scope && !instr.default);\n    if (instructions.length > 0) {\n      return instructions;\n    }\n\n    // If there are no non-default instructions, process all default instructions\n    return this.instructions.filter(instr => instr.scope === scope);\n  }\n\n  /**\n   * Ensure that there's a clear all instruction present in instructions for a scope.\n   */\n  public ensureClearStateInstruction(scope: RoutingScope): void {\n    const router = this.router;\n    if (!this.instructions.some(instr => instr.scope === scope && instr.isClearAll(router))) {\n      const clearAll = RoutingInstruction.create(RoutingInstruction.clear(router)) as RoutingInstruction;\n      clearAll.scope = scope;\n      this.instructions.unshift(clearAll);\n    }\n  }\n\n  /**\n   * Match the instructions to available endpoints within, and with the help of, their scope.\n   *\n   * @param scope - The scope to match the instructions within\n   * @param instructions - The instructions to matched\n   * @param alreadyFound - The already found matches\n   * @param disregardViewports - Whether viewports should be ignored when matching\n   */\n  public matchEndpoints(scope: RoutingScope, disregardViewports: boolean = false): void {\n    const scopeInstructions = this.getInstructionsForScope(scope);\n\n    const matchedInstructions = EndpointMatcher.matchEndpoints(\n      scope,\n      scopeInstructions,\n      [...this.processedInstructions, ...this.matchedInstructions],\n      disregardViewports\n    ).matchedInstructions;\n\n    this.matchedInstructions.push(...matchedInstructions);\n    this.instructions = this.instructions.filter(instr => !matchedInstructions.includes(instr));\n  }\n\n  /**\n   * Run the navigation coordination, transitioning all entities/endpoints\n   */\n  public run(): void {\n    if (!this.running) {\n      this.running = true;\n      for (const entity of this.entities) {\n        if (!entity.running) {\n          entity.running = true;\n          entity.endpoint.transition(this);\n        }\n      }\n    }\n  }\n\n  /**\n   * Add a navigation state to be synchronized.\n   *\n   * @param state - The state to add\n   */\n  public addSyncState(state: NavigationState): void {\n    const openPromise = new OpenPromise(`addSyncState: ${state}`);\n    this.syncStates.set(state, openPromise);\n  }\n\n  /**\n   * Add an endpoint to be synchronized.\n   *\n   * @param endpoint - The endpoint to add\n   */\n  public addEndpoint(endpoint: IEndpoint): Entity {\n    const entity = new Entity(endpoint);\n    this.entities.push(entity);\n    // A new entity might invalidate earlier reached states, so reset\n    this.recheckSyncStates();\n\n    if (this.running) {\n      // If we're running transitions, start the transition\n      entity.endpoint.transition(this);\n    }\n    return entity;\n  }\n\n  /**\n   * Remove an endpoint from synchronization.\n   *\n   * @param endpoint - The endpoint to remove\n   */\n  public removeEndpoint(endpoint: IEndpoint): void {\n    const endpoints = this.entities.map(e => e.endpoint) as (IEndpoint & { parentViewport?: IEndpoint | null })[];\n    const removes = [endpoint];\n    let children = [endpoint];\n    // Recursively find all children of the endpoint\n    while (children.length > 0) {\n      children = endpoints.filter(e => e?.parentViewport != null && children.includes(e.parentViewport));\n      removes.push(...children);\n    }\n\n    // Remove the entities for the endpoint and all its children\n    for (const remove of removes) {\n      // Find the entity...\n      const entity = this.entities.find(e => e.endpoint === remove);\n      if (entity !== void 0) {\n        // ...and remove it.\n        arrayRemove(this.entities, ent => ent === entity);\n      }\n    }\n    // Removing an entity might take us further along the overall process, so check ALL states\n    this.checkSyncState();\n  }\n\n  /**\n   * Set the Runner step controlling the transition for an endpoint.\n   *\n   * @param endpoint - The endpoint that gets the step set\n   * @param step - The step that's controlling the transition\n   */\n  public setEndpointStep(endpoint: IEndpoint, step: Step<void>): void {\n    // Find the entity for the endpoint...\n    let entity = this.entities.find(e => e.endpoint === endpoint);\n    if (entity === void 0) {\n      // ...adding it if it doesn't exist.\n      entity = this.addEndpoint(endpoint);\n    }\n    entity.step = step;\n  }\n\n  /**\n   * Get the Runner step controlling the transition for an endpoint.\n   *\n   * @param endpoint - The endpoint to get the step for\n   */\n  public getEndpointStep(endpoint: IEndpoint): Step<void> | null {\n    // Find the entity for the endpoint...\n    const entity = this.entities.find(e => e.endpoint === endpoint);\n    return entity?.step ?? null;\n  }\n\n  /**\n   * Add a (reached) navigation state for an endpoint.\n   *\n   * @param endpoint - The endpoint that's reached a state\n   * @param state - The state that's been reached\n   */\n  public addEndpointState(endpoint: IEndpoint, state: NavigationState): void {\n    // Find the entity for the endpoint...\n    let entity = this.entities.find(e => e.endpoint === endpoint);\n    if (entity === void 0) {\n      // ...adding it if it doesn't exist.\n      entity = this.addEndpoint(endpoint);\n    }\n    // Something is waiting for this specific entity/endpoint to reach the state...\n    const openPromise = entity.states.get(state);\n    if (openPromise instanceof OpenPromise) {\n      // ...so resolve it.\n      openPromise.resolve();\n    }\n    entity.states.set(state, null);\n    // Check if this was the last entity/endpoint needed to resolve the state\n    this.checkSyncState(state);\n  }\n\n  /**\n   * Wait for a navigation state to be reached. If endpoint is specified, it\n   * will be marked as waiting for the state notified when it is reached (if\n   * waiting is necessary).\n   *\n   * @param state - The state to wait for\n   * @param endpoint - The specific endpoint to wait for\n   */\n  public waitForSyncState(state: NavigationState, endpoint: IEndpoint | null = null): void | Promise<void> {\n    if (this.entities.length === 0) {\n      return;\n    }\n\n    // Get the promise, if any, indicating that we're synchronizing this state...\n    const openPromise = this.syncStates.get(state);\n    if (openPromise === void 0) {\n      // ...and return void (nothing to wait for) if it's not synchronized.\n      return;\n    }\n\n    // If a specified endpoing is waiting for a state...\n    if (endpoint !== null) {\n      const entity = this.entities.find(e => e.endpoint === endpoint);\n      // ...and it's got an entity without existing promise (and the state\n      // is still pending)...\n      if (entity?.syncPromise === null && openPromise.isPending) {\n        // ...mark the entity as waiting for the state.\n        entity.syncingState = state;\n        entity.syncPromise = new OpenPromise(`waitForSyncState: ${state}`);\n        // Also add the state as checked for the entity...\n        entity.checkedStates.push(state);\n        // ...and over all.\n        this.checkedSyncStates.add(state);\n        Promise.resolve().then(() => {\n          // Check if this has resolved anything waiting\n          this.checkSyncState(state);\n        }).catch(err => { throw err; });\n        // Return the promise to await\n        return entity.syncPromise.promise;\n      }\n    }\n\n    // Return the promise to await if it's still pending\n    return openPromise.isPending ? openPromise.promise : void 0;\n  }\n\n  /**\n   * Wait (if necessary) for an endpoint to reach a specific state.\n   *\n   * @param endpoint - The endpoint to wait for\n   * @param state - The state to wait for\n   */\n  public waitForEndpointState(endpoint: IEndpoint, state: NavigationState): void | Promise<void> {\n    if (!this.syncStates.has(state)) {\n      return;\n    }\n\n    // Find the entity...\n    let entity = this.entities.find(e => e.endpoint === endpoint);\n    // ...adding it if it doesn't exist.\n    if (entity == null) {\n      entity = this.addEndpoint(endpoint);\n    }\n\n    // If we've already reached, return (no wait)\n    if (entity.hasReachedState(state)) {\n      return;\n    }\n\n    // Get open promise...\n    let openPromise = entity.states.get(state);\n    // ...creating a new one if necessary.\n    if (openPromise == null) {\n      openPromise = new OpenPromise(`waitForEndpointState: ${state}`);\n      entity.states.set(state, openPromise);\n    }\n\n    // Return the promise to await\n    return openPromise.promise;\n  }\n\n  /**\n   * Notify that all endpoints has been added to the coordinator.\n   */\n  public finalEndpoint(): void {\n    this.hasAllEndpoints = true;\n\n    // Check all synchronized states to see which has been reached\n    this.syncStates.forEach((_promise: OpenPromise, state: NavigationState) => this.checkSyncState(state));\n  }\n\n  /**\n   * Finalize the navigation, calling finalizeContentChange in all endpoints.\n   */\n  public finalize(): void {\n    this.entities.forEach(entity => entity.endpoint.finalizeContentChange(this, null));\n    this.completed = true;\n    this.navigation.completed = true;\n    this.syncStates.clear();\n  }\n\n  /**\n   * Cancel the navigation, calling cancelContentChange in all endpoints and\n   * cancelling the navigation itself.\n   */\n  public cancel(): void {\n    this.cancelled = true;\n    this.instructions = [];\n    this.matchedInstructions = [];\n    // TODO: Take care of disabling viewports when cancelling and stateful!\n    this.entities.forEach(entity => {\n      const abort = entity.endpoint.cancelContentChange(this);\n      if (abort instanceof Promise) {\n        abort.catch(error => { throw error; });\n      }\n    });\n    // TODO: Review this since it probably should happen in turn\n    this.router.navigator.cancel(this.navigation)\n      .then(() => {\n        this.navigation.process?.resolve(false);\n      })\n      .catch(error => { throw error; });\n    this.completed = true;\n    this.navigation.completed = true;\n    // Resolve awaiting processes\n    [...this.syncStates.values()].forEach(promise => {\n      if (promise.isPending) {\n        promise.resolve();\n      }\n    });\n    this.syncStates.clear();\n  }\n\n  /**\n   * Check if a navigation state has been reached, notifying waiting\n   * endpoints if so.\n   *\n   * @param state - The state to check\n   */\n  private checkSyncState(state?: NavigationState): void {\n    if (state === void 0) {\n      // Check all synchronized states to see which has been reached\n      this.syncStates.forEach((_promise: OpenPromise, state: NavigationState) => this.checkSyncState(state));\n      return;\n    }\n    // Get the promise, if any, indicating that we're synchronizing this state...\n    const openPromise = this.syncStates.get(state);\n    if (openPromise === void 0) {\n      // ...and return void (nothing to wait for) if it's not synchronized.\n      return;\n    }\n    // States aren't reached until all endpoints have been added (but the\n    // router can tell the coordinator that all endpoints have been added\n    // even though they haven't, to get the states reached)\n    if (this.hasAllEndpoints &&\n      openPromise.isPending &&\n      // Check that this state has been done by all state entities and if so resolve the promise\n      this.entities.every(ent => ent.hasReachedState(state)) &&\n      // Check that this state has been checked (reached) by all state entities and if so resolve the promise\n      (!this.checkedSyncStates.has(state) || this.entities.every(ent => ent.checkedStates.includes(state)))\n    ) {\n      for (const entity of this.entities) {\n        if (entity.syncingState === state) {\n          entity.syncPromise?.resolve();\n          entity.syncPromise = null;\n          entity.syncingState = null;\n        }\n      }\n      openPromise.resolve();\n    }\n  }\n\n  /**\n   * Re-check the sync states (since a new endpoint has been added) and add\n   * now unresolved ones back.\n   */\n  private recheckSyncStates(): void {\n    this.syncStates.forEach((promise: OpenPromise, state: NavigationState) => {\n      if (!promise.isPending && !this.entities.every(ent => ent.hasReachedState(state))) {\n        this.addSyncState(state);\n      }\n    });\n  }\n\n  /**\n   * Get all endpoints affected by any clear all routing instructions and then remove those\n   * routing instructions.\n   *\n   * @param instructions - The instructions to process\n   */\n  private getClearAllEndpoints(scope: RoutingScope): Endpoint[] {\n    const router = this.router;\n    let clearEndpoints: Endpoint[] = [];\n\n    // If there's any clear all routing instruction...\n    if (this.instructions.some(instr => (instr.scope ?? scope) === scope && instr.isClearAll(router))) {\n      // ...get all the endpoints to be cleared...\n      clearEndpoints = scope.enabledChildren  // TODO(alpha): Verify the need for rootScope check below\n        .filter(sc => !sc.endpoint.isEmpty) // && sc !== this.router.rootScope?.connectedScope)\n        .map(sc => sc.endpoint);\n      // ...and remove the clear all instructions\n      this.instructions = this.instructions.filter(instr => !((instr.scope ?? scope) === scope && instr.isClearAll(router)));\n    }\n    return clearEndpoints;\n  }\n\n  /**\n   * Deal with/throw an unknown route error.\n   *\n   * @param instructions - The failing instructions\n   */\n  private createUnknownRouteError(instructions: RoutingInstruction[]) {\n    const options = this.router.configuration.options;\n    const route = RoutingInstruction.stringify(this.router, instructions);\n    // TODO: Add missing/unknown route handling\n    if (instructions[0].route != null) {\n      if (!options.useConfiguredRoutes) {\n        return new Error(`Can not match '${route}' since the router is configured to not use configured routes.`);\n      } else {\n        return new Error(`No matching configured route found for '${route}'.`);\n      }\n    } else if (options.useConfiguredRoutes && options.useDirectRouting) {\n      return new Error(`No matching configured route or component found for '${route}'.`);\n    } else if (options.useConfiguredRoutes) {\n      return new Error(`No matching configured route found for '${route}'.`);\n    } else {\n      return new Error(`No matching route/component found for '${route}'.`);\n    }\n  }\n}\n", "/**\n *\n * NOTE: This file is still WIP and will go through at least one more iteration of refactoring, commenting and clean up!\n * In its current state, it is NOT a good source for learning about the inner workings and design of the router.\n *\n */\nimport { ComponentAppellation, IComponentAndOrViewportOrNothing, RouteableComponentType } from './interfaces';\nimport { RoutingInstruction } from './instructions/routing-instruction';\nimport { Navigation } from './navigation';\nimport { Viewport } from './endpoints/viewport';\nimport { InstructionComponent } from './instructions/instruction-component';\nimport { InstructionEndpoint } from './instructions/instruction-endpoint';\n\n/**\n * Public API\n */\nexport type RoutingHookType = 'beforeNavigation' | 'transformFromUrl' | 'transformToUrl' | 'transformTitle';\n/**\n * Public API\n */\nexport type BeforeNavigationHookFunction = (routingInstructions: RoutingInstruction[], navigationInstruction: Navigation) => Promise<boolean | RoutingInstruction[]>;\n/**\n * Public API\n */\nexport type TransformFromUrlHookFunction = (url: string, navigationInstruction: Navigation) => Promise<string | RoutingInstruction[]>;\n/**\n * Public API\n */\nexport type TransformToUrlHookFunction = (state: string | RoutingInstruction[], navigationInstruction: Navigation) => Promise<string | RoutingInstruction[]>;\n/**\n * Public API\n */\nexport type TransformTitleHookFunction = (title: string | RoutingInstruction[], navigationInstruction: Navigation) => Promise<string | RoutingInstruction[]>;\n\n/**\n * @internal\n */\nexport type RoutingHookFunction = BeforeNavigationHookFunction | TransformFromUrlHookFunction | TransformToUrlHookFunction | TransformTitleHookFunction;\n/**\n * @internal\n */\nexport type RoutingHookParameter = string | RoutingInstruction[];\n/**\n * @internal\n */\nexport type RoutingHookResult = boolean | string | RoutingInstruction[];\n\nexport type RoutingHookTarget = ComponentAppellation | IComponentAndOrViewportOrNothing;\n\n/**\n * Public API\n */\nexport type RoutingHookIdentity = number;\n\n/**\n * Public API\n */\nexport interface IRoutingHookOptions {\n  /**\n   * What event/when to hook. Defaults to BeforeNavigation\n   */\n  type?: RoutingHookType;\n  /**\n   * What to hook. If omitted, everything is included\n   */\n  include?: RoutingHookTarget[];\n  /**\n   * What not to hook. If omitted, nothing is excluded\n   */\n  exclude?: RoutingHookTarget[];\n}\n\n/**\n * Public API\n */\nexport interface IRoutingHookDefinition {\n  hook: RoutingHookFunction;\n  options: IRoutingHookOptions;\n}\n\n/**\n * @internal - Shouldn't be used directly\n */\nexport class RoutingHook {\n  public static hooks: Record<RoutingHookType, RoutingHook[]> = {\n    beforeNavigation: [],\n    transformFromUrl: [],\n    transformToUrl: [],\n    transformTitle: [],\n  };\n\n  private static lastIdentity: number = 0;\n\n  public type: RoutingHookType = 'beforeNavigation';\n  public includeTargets: Target[] = [];\n  public excludeTargets: Target[] = [];\n\n  public constructor(\n    public hook: RoutingHookFunction,\n    options: IRoutingHookOptions,\n    public id: RoutingHookIdentity\n  ) {\n    if (options.type !== void 0) {\n      this.type = options.type;\n    }\n\n    for (const target of options.include ?? []) {\n      this.includeTargets.push(new Target(target));\n    }\n    for (const target of options.exclude ?? []) {\n      this.excludeTargets.push(new Target(target));\n    }\n  }\n\n  public static add(beforeNavigationHookFunction: BeforeNavigationHookFunction, options?: IRoutingHookOptions): RoutingHookIdentity;\n  public static add(transformFromUrlHookFunction: TransformFromUrlHookFunction, options?: IRoutingHookOptions): RoutingHookIdentity;\n  public static add(transformToUrlHookFunction: TransformToUrlHookFunction, options?: IRoutingHookOptions): RoutingHookIdentity;\n  public static add(transformTitleHookFunction: TransformTitleHookFunction, options?: IRoutingHookOptions): RoutingHookIdentity;\n  public static add(hookFunction: RoutingHookFunction, options?: IRoutingHookOptions): RoutingHookIdentity;\n  public static add(hookFunction: RoutingHookFunction, options?: IRoutingHookOptions): RoutingHookIdentity {\n    const hook = new RoutingHook(hookFunction, options ?? {}, ++this.lastIdentity);\n\n    this.hooks[hook.type].push(hook);\n\n    return this.lastIdentity;\n  }\n\n  public static remove(id: RoutingHookIdentity): void {\n    for (const type in this.hooks) {\n      if (Object.prototype.hasOwnProperty.call(this.hooks, type)) {\n        const index = this.hooks[type as RoutingHookType].findIndex(hook => hook.id === id);\n        if (index >= 0) {\n          this.hooks[type as RoutingHookType].splice(index, 1);\n        }\n      }\n    }\n  }\n\n  public static removeAll(): void {\n    for (const type in this.hooks) {\n      this.hooks[type as RoutingHookType] = [];\n    }\n  }\n\n  public static async invokeBeforeNavigation(routingInstructions: RoutingInstruction[], navigationInstruction: Navigation): Promise<boolean | RoutingInstruction[]> {\n    return this.invoke('beforeNavigation', navigationInstruction, routingInstructions) as Promise<boolean | RoutingInstruction[]>;\n  }\n  public static async invokeTransformFromUrl(url: string, navigationInstruction: Navigation): Promise<string | RoutingInstruction[]> {\n    return this.invoke('transformFromUrl', navigationInstruction, url) as Promise<string | RoutingInstruction[]>;\n  }\n  public static async invokeTransformToUrl(state: string | RoutingInstruction[], navigationInstruction: Navigation): Promise<string | RoutingInstruction[]> {\n    return this.invoke('transformToUrl', navigationInstruction, state) as Promise<string | RoutingInstruction[]>;\n  }\n  public static async invokeTransformTitle(title: string | RoutingInstruction[], navigationInstruction: Navigation): Promise<string | RoutingInstruction[]> {\n    return this.invoke('transformTitle', navigationInstruction, title) as Promise<string | RoutingInstruction[]>;\n  }\n\n  public static async invoke(type: RoutingHookType, navigationInstruction: Navigation, arg: RoutingHookParameter): Promise<RoutingHookResult> {\n    let outcome: RoutingHookResult = arg;\n    for (const hook of this.hooks[type]) {\n      if (!hook.wantsMatch || hook.matches(arg)) {\n        outcome = await hook.invoke(navigationInstruction, arg);\n        if (typeof outcome === 'boolean') {\n          if (!outcome) {\n            return false;\n          }\n        } else {\n          arg = outcome;\n        }\n      }\n    }\n    return outcome;\n  }\n\n  public get wantsMatch(): boolean {\n    return this.includeTargets.length > 0 || this.excludeTargets.length > 0;\n  }\n\n  public matches(routingInstructions: RoutingHookParameter): boolean {\n    if (this.includeTargets.length && !this.includeTargets.some(target => target.matches(routingInstructions as RoutingInstruction[]))) {\n      return false;\n    }\n    if (this.excludeTargets.length && this.excludeTargets.some(target => target.matches(routingInstructions as RoutingInstruction[]))) {\n      return false;\n    }\n    return true;\n  }\n\n  public invoke(navigationInstruction: Navigation, arg: RoutingHookParameter): Promise<RoutingHookResult> {\n    // TODO: Fix the type here\n    return this.hook(arg as any, navigationInstruction);\n  }\n}\n\nclass Target {\n  public componentType: RouteableComponentType | null = null;\n  public componentName: string | null = null;\n  public viewport: Viewport | null = null;\n  public viewportName: string | null = null;\n\n  public constructor(target: RoutingHookTarget) {\n    if (typeof target === 'string') {\n      this.componentName = target;\n    } else if (InstructionComponent.isType(target as RouteableComponentType)) {\n      this.componentType = target as RouteableComponentType;\n      this.componentName = InstructionComponent.getName(target as RouteableComponentType);\n    } else {\n      const cvTarget = target as IComponentAndOrViewportOrNothing;\n      if (cvTarget.component != null) {\n        this.componentType = InstructionComponent.isType(cvTarget.component)\n          ? InstructionComponent.getType(cvTarget.component)\n          : null;\n        this.componentName = InstructionComponent.getName(cvTarget.component);\n      }\n      if (cvTarget.viewport != null) {\n        this.viewport = InstructionEndpoint.isInstance(cvTarget.viewport) ? cvTarget.viewport : null;\n        this.viewportName = InstructionEndpoint.getName(cvTarget.viewport);\n      }\n    }\n  }\n\n  public matches(routingInstructions: RoutingInstruction[]): boolean {\n    const instructions = routingInstructions.slice();\n    if (!instructions.length) {\n      // instructions.push(new RoutingInstruction(''));\n      instructions.push(RoutingInstruction.create('') as RoutingInstruction);\n    }\n    for (const instruction of instructions) {\n      if ((this.componentName !== null && this.componentName === instruction.component.name) ||\n        (this.componentType !== null && this.componentType === instruction.component.type) ||\n        (this.viewportName !== null && this.viewportName === instruction.endpoint.name) ||\n        (this.viewport !== null && this.viewport === instruction.endpoint.instance)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n", "import { TitleOptions } from './router-options';\nimport { RoutingInstruction } from './instructions/routing-instruction';\nimport { Navigation } from './navigation';\nimport { RoutingHook } from './routing-hook';\n\nexport class Title {\n  public static async getTitle(instructions: RoutingInstruction[], navigation: Navigation, titleOptions: TitleOptions): Promise<string | null> {\n    // First invoke with viewport instructions\n    let title: string | RoutingInstruction[] = await RoutingHook.invokeTransformTitle(instructions, navigation);\n    if (typeof title !== 'string') {\n      // Hook didn't return a title, so run title logic\n      const componentTitles = Title.stringifyTitles(title, navigation, titleOptions);\n\n      title = titleOptions.appTitle;\n      title = title.replace(/\\${componentTitles}/g, componentTitles);\n      title = title.replace(/\\${appTitleSeparator}/g,\n        componentTitles !== '' ? titleOptions.appTitleSeparator : '');\n    }\n    // Invoke again with complete string\n    title = await RoutingHook.invokeTransformTitle(title, navigation);\n\n    return title as string;\n  }\n\n  private static stringifyTitles(instructions: RoutingInstruction[], navigation: Navigation, titleOptions: TitleOptions): string {\n    const titles = instructions\n      .map(instruction => Title.stringifyTitle(instruction, navigation, titleOptions))\n      .filter(instruction => (instruction?.length ?? 0) > 0);\n\n    return titles.join(' + ');\n  }\n\n  private static stringifyTitle(instruction: RoutingInstruction, navigation: Navigation, titleOptions: TitleOptions): string {\n    const nextInstructions: RoutingInstruction[] | null = instruction.nextScopeInstructions;\n    let stringified = Title.resolveTitle(instruction, navigation, titleOptions);\n    if (Array.isArray(nextInstructions) && nextInstructions.length > 0) {\n      let nextStringified: string = Title.stringifyTitles(nextInstructions, navigation, titleOptions);\n      if (nextStringified.length > 0) {\n        if (nextInstructions.length !== 1) { // TODO: This should really also check that the instructions have value\n          nextStringified = `[ ${nextStringified} ]`;\n        }\n        if (stringified.length > 0) {\n          stringified = titleOptions.componentTitleOrder === 'top-down'\n            ? stringified + titleOptions.componentTitleSeparator + nextStringified\n            : nextStringified + titleOptions.componentTitleSeparator + stringified;\n        } else {\n          stringified = nextStringified;\n        }\n      }\n    }\n    return stringified;\n  }\n\n  private static resolveTitle(instruction: RoutingInstruction, navigation: Navigation, titleOptions: TitleOptions): string {\n    let title = instruction.getTitle(navigation);\n    if (titleOptions.transformTitle != null) {\n      title = titleOptions.transformTitle(title, instruction, navigation);\n    }\n    return title;\n  }\n}\n", "/* eslint-disable prefer-template */\n/**\n *\n * NOTE: This file is still WIP and will go through at least one more iteration of refactoring, commenting and clean up!\n * In its current state, it is NOT a good source for learning about the inner workings and design of the router.\n *\n */\nimport { DI, IContainer, Registration, IEventAggregator, IDisposable, Protocol, ILogger, resolve } from '@aurelia/kernel';\nimport { CustomElementType, ICustomElementViewModel, IAppRoot, ICustomElementController } from '@aurelia/runtime-html';\nimport { LoadInstruction } from './interfaces';\nimport { Navigator, NavigatorNavigateEvent } from './navigator';\nimport { arrayUnique } from './utilities/utils';\nimport { Viewport } from './endpoints/viewport';\nimport { IViewportOptions } from './endpoints/viewport-options';\nimport { RoutingInstruction } from './instructions/routing-instruction';\nimport { RoutingScope } from './routing-scope';\nimport { ViewportScope } from './endpoints/viewport-scope';\nimport { BrowserViewerStore, NavigatorStateChangeEvent } from './browser-viewer-store';\nimport { Navigation } from './navigation';\nimport { Endpoint, EndpointTypeName, IConnectedCustomElement } from './endpoints/endpoint';\nimport { NavigationCoordinator } from './navigation-coordinator';\nimport { Runner, Step } from './utilities/runner';\nimport { Title } from './title';\nimport { RoutingHook } from './routing-hook';\nimport { IRouterConfiguration } from './index';\nimport { ErrorNames, createMappedError } from './errors';\nimport { Separators } from './router-options';\n\n/**\n * The router is the \"main entry point\" into routing. Its primary responsibilities are\n * - provide configuration api\n * - provide api for adding and finding endpoints (viewport and viewport scope)\n * - provide api for connecting endpoint custom elements to endpoints\n * - provide navigation/load api and inform the navigator about navigation/load instructions\n * - provide informational api regarding ongoing navigation\n * - receive a navigation (instruction) from the navigator and process it\n * - invoke routing hooks when appropriate\n *\n * All navigations roughly follows the same flow:\n * 1) A user action (link click, browser navigation, api call) results in a set of\n * LoadInstructions to the Router, prepared by the corresponding handler (LinkHandler,\n * BrowserViewerStore and Router respectively).\n * 2) The Router enriches the LoadInstruction(s) into a Navigation that's sent to the Navigator.\n * 3) The Navigator enriches the Navigation further, queues it and sends it to the Router for\n * processing.\n * 4) The Router turns, with help from the RoutingScopes, the Navigation into a set of\n * RoutingInstructions.\n * 5) The RoutingInstructions are then, again with the help of the RoutingScopes, matched\n * to the appropriate Endpoints.\n * 6) The Endpoints are informed of their RoutingInstructions.\n * 7) If one of the Endpoints disapprove of their RoutingInstructions (based on the state of\n * their current content, authorization and so on) the Navigation is cancelled.\n * 8) If the Navigation is approved, the Endpoints are instructed to perform their transitions.\n * 9) Once all transitions are completed, the Router informs the Navigatior about the success\n * and the new, complete state.\n * 10) The Navigator saves the new state in the right place (if any) in history and informs\n * the BrowserViewerStore about the new current state.\n * 11) The BrowserViewerStore sends the new state to the browser's Viewer (browser Location url\n * and title) and Store (browser History).\n */\n\n/**\n * Options for loading new routing instructions.\n */\nexport interface ILoadOptions {\n  /**\n   * The title to use for this load\n   */\n  title?: string;\n\n  /**\n   * The query string to use/set with this load\n   */\n  query?: string;\n\n  /**\n   * The fragment to use/set with this load\n   */\n  fragment?: string;\n\n  /**\n   * The parameters to use for this load. If specified and no `query` is\n   * specified, `query` will be created and set based on this.\n   */\n  parameters?: string | Record<string, unknown>;\n\n  /**\n   * Data that's passed along (untouched) with the navigation\n   */\n  data?: Record<string, unknown>;\n\n  /**\n   * Whether the navigation should replace the current one in navigation\n   * (and browser) history. Default: false\n   */\n  replace?: boolean;\n\n  /**\n   * Whether the instructions should be appended to a navigation coordinator,\n   * the coordinator of the current navigation in progress (if any). If no\n   * current navigation is in progress, the instructions will be treated as\n   * a new navigation. Default: false\n   */\n  append?: boolean | NavigationCoordinator;\n\n  /**\n   * The origin of the navigation. Will also be used as context if no\n   * context is specified.\n   */\n  origin?: ICustomElementViewModel | Element;\n\n  /**\n   * The (starting) context of the navigation. If no context is specified,\n   * origin, if specified, will be used instead.\n   */\n  context?: ICustomElementViewModel | Element | Node | ICustomElementController;\n\n  /**\n   * Modifies that (starting) scope, based on `context`, by either going up\n   * `../` or to root `/`.\n   */\n  scopeModifier?: string;\n\n  /**\n   * Whether the browser (url, history navigation) is the cause of the\n   * navigation.\n   *\n   * @internal\n   */\n  fromBrowser?: boolean;\n  /**\n   * Whether the navigation should replace the current one in navigation\n   * (and browser) history. If true, overrides `replace`. Default: false\n   *\n   * @internal\n   */\n  replacing?: boolean;\n}\n\nexport const IRouter = /*@__PURE__*/DI.createInterface<IRouter>('IRouter', x => x.singleton(Router));\nexport interface IRouter extends Router { }\n\nexport class Router implements IRouter {\n\n  public static readonly closestEndpointKey = Protocol.annotation.keyFor('closest-endpoint');\n\n  /**\n   * The root viewport scope.\n   */\n  public rootScope: ViewportScope | null = null;\n\n  /**\n   * The active navigation.\n   */\n  public activeNavigation!: Navigation;\n\n  /**\n   * The active routing instructions.\n   */\n  public activeComponents: RoutingInstruction[] = [];\n\n  /**\n   * Instructions that are appended between navigations and should be appended\n   * to next navigation. (This occurs during startup, when there's no navigation\n   * to append viewport default instructions to.)\n   */\n  public appendedInstructions: RoutingInstruction[] = [];\n\n  /**\n   * Whether the router is active/started\n   */\n  public isActive: boolean = false;\n\n  /**\n   * The currently active coordinators (navigations)\n   */\n  private readonly coordinators: NavigationCoordinator[] = [];\n\n  /**\n   * Whether the first load has happened\n   */\n  private loadedFirst: boolean = false;\n\n  /** @internal */\n  private _navigatorStateChangeEventSubscription!: IDisposable;\n  /** @internal */\n  private _navigatorNavigateEventSubscription!: IDisposable;\n\n  /**\n   * Is processing navigation\n   *\n   * @internal\n   */\n  private _isProcessingNav: boolean = false;\n  /**\n   * Pending navigation\n   *\n   * @internal\n   */\n  private _pendingNavigation?: NavigatorNavigateEvent;\n  /** @internal */\n  private readonly _logger = resolve(ILogger);\n\n  /**\n   * @internal\n   */\n  public readonly container = resolve(IContainer);\n  private readonly ea = resolve(IEventAggregator);\n\n  /**\n   * The navigator that manages navigation queue and history\n   *\n   * @internal\n   */\n  public navigator = resolve(Navigator);\n\n  /**\n   * The viewer (browser) that displays url, navigation buttons\n   */\n  public viewer = resolve(BrowserViewerStore);\n\n  /**\n   * The store (browser) that stores navigations\n   */\n  public store = resolve(BrowserViewerStore);\n\n  /**\n   * The router configuration\n   */\n  public configuration = resolve(IRouterConfiguration);\n\n  /**\n   * Whether the router is currently navigating.\n   */\n  public get isNavigating(): boolean {\n    return this.coordinators.length > 0;\n  }\n\n  /**\n   * Whether the router has a navigation that's open for more\n   * instructions to be appended.\n   */\n  public get hasOpenNavigation(): boolean {\n    return this.coordinators.filter(coordinator => !coordinator.closed).length > 0;\n  }\n\n  /**\n   * Whether navigations are restricted/synchronized beyond the minimum.\n   */\n  public get isRestrictedNavigation(): boolean {\n    const syncStates = this.configuration.options.navigationSyncStates;\n    return syncStates.includes('guardedLoad') ||\n      syncStates.includes('unloaded') ||\n      syncStates.includes('loaded') ||\n      syncStates.includes('guarded') ||\n      syncStates.includes('routed');\n  }\n\n  /**\n   * Whether navigation history is stateful\n   *\n   * @internal\n   */\n  public get statefulHistory(): boolean {\n    return this.configuration.options.statefulHistoryLength !== void 0 && this.configuration.options.statefulHistoryLength > 0;\n  }\n\n  /**\n   * Start the router, activing the event listeners.\n   */\n  public start(): void {\n    if (this.isActive) {\n      throw createMappedError(ErrorNames.router_started);\n    }\n    this.isActive = true;\n\n    const root = this.container.get(IAppRoot);\n    // root.config.component shouldn't be used in the end. Metadata will probably eliminate it\n    this.rootScope = new ViewportScope(this, 'rootScope', root.controller.viewModel as IConnectedCustomElement, null, true, root.config.component as CustomElementType);\n\n    const options = this.configuration.options;\n    // If base path isn't configured...\n    if (options.basePath === null) {\n      // ...get it from baseURI (base element href)\n      const url = new URL(root.host.baseURI);\n      options.basePath = url.pathname;\n    }\n    // Base path shouldn't end with '/' (to differentiate absolutes from relative)\n    if (options.basePath.endsWith('/')) {\n      options.basePath = options.basePath.slice(0, -1);\n    }\n\n    this.navigator.start({\n      store: this.store,\n      viewer: this.viewer,\n      statefulHistoryLength: this.configuration.options.statefulHistoryLength,\n    });\n\n    this._navigatorStateChangeEventSubscription = this.ea.subscribe(NavigatorStateChangeEvent.eventName, this.handleNavigatorStateChangeEvent);\n    this._navigatorNavigateEventSubscription = this.ea.subscribe(NavigatorNavigateEvent.eventName, this.handleNavigatorNavigateEvent);\n    this.viewer.start({ useUrlFragmentHash: this.configuration.options.useUrlFragmentHash });\n\n    this.ea.publish(RouterStartEvent.eventName, RouterStartEvent.create());\n  }\n\n  /**\n   * Stop the router.\n   */\n  public stop(): void {\n    if (!this.isActive) {\n      throw createMappedError(ErrorNames.router_not_started);\n    }\n    this.ea.publish(RouterStopEvent.eventName, RouterStopEvent.create());\n    this.navigator.stop();\n    this.viewer.stop();\n\n    this._navigatorStateChangeEventSubscription.dispose();\n    this._navigatorNavigateEventSubscription.dispose();\n  }\n\n  /**\n   * Perform the initial load, using the current url.\n   *\n   * @internal\n   */\n  public async initialLoad(): Promise<boolean | void> {\n    const { instruction, hash } = this.viewer.viewerState;\n    const result = this.load(\n      instruction,\n      {\n        fragment: hash,\n        replacing: true,\n        fromBrowser: false\n      });\n    this.loadedFirst = true;\n    return result;\n  }\n\n  /**\n   * Handle the navigator's navigate event.\n   *\n   * @param event - The event to handle\n   *\n   * @internal\n   */\n  private readonly handleNavigatorNavigateEvent = (event: NavigatorNavigateEvent): void => {\n    void this._doHandleNavigatorNavigateEvent(event);\n  };\n\n  /** @internal */\n  private async _doHandleNavigatorNavigateEvent(event: NavigatorNavigateEvent): Promise<void> {\n    // TODO: Fix the fast-switch multiple navigations issue without this throttle\n    if (this._isProcessingNav) {\n      // We prevent multiple navigation at the same time, but we store the last navigation requested.\n      if (this._pendingNavigation) {\n        // This pending navigation is cancelled\n        this._pendingNavigation.navigation.process?.resolve(false);\n      }\n      this._pendingNavigation = event;\n      return;\n    }\n    this._isProcessingNav = true;\n\n    try {\n      await this.processNavigation(event.navigation);\n    } catch (error) {\n      event.navigation.process?.reject(error);\n    } finally {\n      this._isProcessingNav = false;\n    }\n\n    if (this._pendingNavigation) {\n      const pending = this._pendingNavigation;\n      this._pendingNavigation = undefined;\n      await this._doHandleNavigatorNavigateEvent(pending);\n    }\n  }\n\n  /**\n   * Is processing navigation\n   *\n   * @internal\n   */\n  public get isProcessingNav(): boolean {\n    return this._isProcessingNav || this._pendingNavigation != null;\n  }\n\n  /**\n   * Handle the navigator's state change event.\n   *\n   * @param event - The event to handle\n   *\n   * @internal\n   */\n  private readonly handleNavigatorStateChangeEvent = (event: NavigatorStateChangeEvent): void => {\n    // It's already a proper navigation (browser history or cache), go\n    // directly to navigate\n    if (event.state?.navigationIndex != null) {\n      const entry = Navigation.create(event.state.navigations[event.state.navigationIndex]);\n      entry.instruction = event.viewerState.instruction;\n      entry.fromBrowser = true;\n      this.navigator.navigate(entry).catch(error => { throw error; });\n    } else {\n      this.load(\n        event.viewerState.instruction,\n        { fromBrowser: true }\n      ).catch(error => { throw error; });\n    }\n  };\n\n  /**\n   * Processes the route/instructions in a (queued) navigation.\n   *\n   * @param evNavigation - The navigation to process\n   *\n   * @internal\n   */\n  public processNavigation = async (navigation: Navigation): Promise<void> => {\n    // To avoid race condition double triggering at refresh\n    this.loadedFirst = true;\n\n    const options = this.configuration.options;\n\n    // Get and initialize a navigation coordinator that will keep track of all endpoint's progresses\n    // and make sure they're in sync when they are supposed to be (no `canLoad` before all `canUnload`\n    // and so on).\n    const coordinator = NavigationCoordinator.create(this, navigation, { syncStates: this.configuration.options.navigationSyncStates });\n    this.coordinators.push(coordinator);\n\n    // If there are instructions appended between/before any navigation,\n    // append them to this navigation. (This happens with viewport defaults\n    // during startup.)\n    coordinator.appendInstructions(this.appendedInstructions.splice(0));\n\n    this.ea.publish(RouterNavigationStartEvent.eventName, RouterNavigationStartEvent.create(navigation));\n\n    // Invoke the transformFromUrl hook if it exists\n    let transformedInstruction;\n    // If we're using full state instruction, use that...\n    if (navigation.useFullStateInstruction) {\n      // ...and extract query and fragment from it\n      transformedInstruction = navigation.fullStateInstruction;\n      let options: ILoadOptions = {};\n      ({ instructions: transformedInstruction, options } = this._extractFragmentAndQuery(transformedInstruction, options) as { instructions: string; options: ILoadOptions });\n      navigation.fragment = options.fragment ?? navigation.fragment;\n      navigation.query = options.query ?? navigation.query;\n      navigation.parameters = (options.parameters as Record<string, unknown>) ?? navigation.parameters;\n    } else {\n      // If we're not using full state instruction, transform the instruction, invoking\n      // the transformFromUrl hook if it exists\n      transformedInstruction = typeof navigation.instruction === 'string'\n        ? await RoutingHook.invokeTransformFromUrl(navigation.instruction, coordinator.navigation)\n        : navigation.instruction;\n    }\n\n    // If app uses a base path remove it if present (unless we're using fragment hash)\n    const basePath = options.basePath;\n    if (basePath !== null &&\n      typeof transformedInstruction === 'string' && transformedInstruction.startsWith(basePath) &&\n      !options.useUrlFragmentHash) {\n      transformedInstruction = transformedInstruction.slice(basePath.length);\n    }\n\n    // TODO: Review this\n    if (transformedInstruction === '/') {\n      transformedInstruction = '';\n    }\n\n    if (typeof transformedInstruction === 'string') {\n      if (transformedInstruction === '') {\n        transformedInstruction = [new RoutingInstruction('')]; // Make sure empty route is also processed\n        transformedInstruction[0].default = true;\n      } else if (transformedInstruction === '-') {\n        transformedInstruction = [new RoutingInstruction('-'), new RoutingInstruction('')]; // Make sure clean all plus empty route is also processed\n        transformedInstruction[1].default = true;\n      } else {\n        transformedInstruction = RoutingInstruction.parse(this, transformedInstruction);\n      }\n    }\n\n    // The instruction should have a scope so use rootScope if it doesn't\n    navigation.scope ??= this.rootScope!.scope;\n\n    // TODO(return): Only use navigation.scope for string and instructions without their own scope\n\n    coordinator.appendInstructions(transformedInstruction);\n\n    // If router options defaults to navigations being complete state navigation (containing the\n    // complete set of routing instructions rather than just the ones that change), ensure\n    // that there's an instruction to clear all non-specified viewports in all the scopes of\n    // the top instructions. With viewports left and right containing components Alpha and Beta\n    // respectively, doing 'gamma@left' as a complete state navigation would load Gamma in left and\n    // unload Beta in right. In a partial navigation, Gamme would still be loaded but right would\n    // be left as is.\n    if (options.completeStateNavigations) {\n      arrayUnique(transformedInstruction, false)\n        .map(instr => instr.scope!)\n        .forEach(scope => coordinator.ensureClearStateInstruction(scope));\n    }\n\n    let guard = 100;\n    do {\n      if (!guard--) { // Guard against endless loop\n        this.unresolvedInstructionsError(navigation, coordinator.instructions);\n      }\n      // eslint-disable-next-line no-await-in-loop\n      await coordinator.processInstructions();\n    } while (coordinator.instructions.length > 0);\n\n    // TODO: Look into adding everything above as well\n    return Runner.run('processNavigation',\n      () => {\n        // console.log('### processNavigation DONE', coordinator.navigation.instruction, coordinator.navigation, coordinator);\n        coordinator.closed = true;\n        coordinator.finalEndpoint();\n        return coordinator.waitForSyncState('completed');\n      },\n      () => {\n        coordinator.finalize();\n        return this.updateNavigation(navigation);\n      },\n      () => {\n        // Remove history entry if no history endpoint updated\n        if (navigation.navigation.new && !navigation.navigation.first && !navigation.repeating && coordinator.changedEndpoints.every(endpoint => endpoint.options.noHistory)) {\n          navigation.untracked = true;\n        }\n        // TODO: Review this when adding noHistory back\n        // return this.navigator.finalize(navigation, this.coordinators.length === 1);\n      },\n      async () => {\n        while (this.coordinators.length > 0 && this.coordinators[0].completed) {\n          const coord = this.coordinators.shift() as NavigationCoordinator;\n\n          // await this.updateNavigation(coord.navigation);\n          // eslint-disable-next-line no-await-in-loop\n          await this.navigator.finalize(coord.navigation, false /* this.coordinators.length === 0 */);\n\n          this.ea.publish(RouterNavigationCompleteEvent.eventName, RouterNavigationCompleteEvent.create(coord.navigation));\n          this.ea.publish(RouterNavigationEndEvent.eventName, RouterNavigationEndEvent.create(coord.navigation));\n\n          coord.navigation.process?.resolve(true);\n        }\n      },\n\n    ) as void | Promise<void>;\n  };\n\n  /**\n   * Get a named endpoint of a specific type.\n   *\n   * @param type - The type of endpoint to get\n   * @param name - The name of the endpoint to get\n   */\n  public getEndpoint(type: EndpointTypeName, name: string): Endpoint | null {\n    return this.allEndpoints(type).find(endpoint => endpoint.name === name) ?? null;\n  }\n\n  /**\n   * Get all endpoints of a specific type.\n   *\n   * @param type - The type of the endpoints to get\n   * @param includeDisabled - Whether disabled/non-active endpoints should be included\n   * @param includeReplaced - Whether replaced endpoints should be included\n   */\n  public allEndpoints(type: EndpointTypeName | null, includeDisabled: boolean = false): Viewport[] {\n    return this.rootScope!.scope\n      .allScopes(includeDisabled)\n      .filter(scope => type === null || scope.type === type)\n      .map(scope => scope.endpoint) as Viewport[];\n  }\n  /**\n   * Public API (not yet implemented)\n   */\n  public addEndpoint(_type: EndpointTypeName, ..._args: unknown[]): unknown {\n    throw createMappedError(ErrorNames.method_not_implemented, 'addEndPoint');\n  }\n\n  /**\n   * Connect an endpoint custom element to an endpoint. Called from the custom\n   * elements of endopints.\n   *\n   * @param endpoint - An already connected endpoint\n   * @param type - The type of the endpoint\n   * @param connectedCE - The endpoint custom element\n   * @param name - The name of the endpoint\n   * @param options - The custom element options\n   *\n   * @internal\n   */\n  public connectEndpoint(endpoint: Viewport | ViewportScope | null, type: EndpointTypeName, connectedCE: IConnectedCustomElement, name: string, options?: IViewportOptions): Viewport | ViewportScope {\n    const container = connectedCE.container;\n    const closestEndpoint: Endpoint = container.has(Router.closestEndpointKey, true)\n      ? container.get<Endpoint>(Router.closestEndpointKey)\n      : this.rootScope!;\n    const parentScope = closestEndpoint.connectedScope;\n\n    if (endpoint === null) {\n      endpoint = parentScope.addEndpoint(type, name, connectedCE, options);\n      Registration.instance(Router.closestEndpointKey, endpoint).register(container);\n    }\n    return endpoint;\n  }\n\n  /**\n   * Disconnect an custom element endpoint from an endpoint. Called from the\n   * custom elements of endpoints.\n   *\n   * @param step - The previous step in this transition Run\n   * @param endpoint - The endpoint to disconnect from\n   * @param connectedCE - The custom element to disconnect\n   */\n  public disconnectEndpoint(step: Step | null, endpoint: Viewport | ViewportScope, connectedCE: IConnectedCustomElement): void {\n    if (!endpoint.connectedScope.parent!.removeEndpoint(step, endpoint, connectedCE)) {\n      throw createMappedError(ErrorNames.router_remove_endpoint_failure, endpoint.name);\n    }\n  }\n\n  /**\n   * Load navigation instructions.\n   *\n   * @param instructions - The instructions to load\n   * @param options - The options to use when loading the instructions\n   */\n  public async load(instructions: LoadInstruction | LoadInstruction[], options?: ILoadOptions): Promise<boolean | void> {\n    ({ instructions, options } = this._extractFragmentAndQuery(instructions, options ?? {}));\n\n    let scope: RoutingScope | null = null;\n    ({ instructions, scope } = this.applyLoadOptions(instructions, options));\n\n    const append = options.append ?? false;\n    if (append !== false) {\n      if (append instanceof NavigationCoordinator) {\n        if (!append.closed) {\n          instructions = RoutingInstruction.from(this, instructions);\n          this.appendInstructions(instructions as RoutingInstruction[], scope, append);\n          // Can't return current navigation promise since it can lead to deadlock in load\n          return Promise.resolve();\n        }\n      } else {\n        if (!this.loadedFirst || this.hasOpenNavigation) {\n          instructions = RoutingInstruction.from(this, instructions);\n          this.appendInstructions(instructions as RoutingInstruction[], scope);\n          // Can't return current navigation promise since it can lead to deadlock in load\n          return Promise.resolve();\n        }\n      }\n    }\n\n    const entry = Navigation.create({\n      instruction: instructions as RoutingInstruction[],\n      fullStateInstruction: '',\n      scope: scope,\n      title: options.title,\n      data: options.data,\n      query: options.query,\n      fragment: options.fragment,\n      parameters: options.parameters as Record<string, unknown>,\n      replacing: (options.replacing ?? false) || options.replace,\n      repeating: (options.append ?? false) !== false,\n      fromBrowser: options.fromBrowser ?? false,\n      origin: options.origin,\n      completed: false,\n    });\n    return this.navigator.navigate(entry);\n  }\n\n  /**\n   * Apply the load options on the instructions.\n   *\n   * @param loadInstructions - The instructions to load\n   * @param options - The load options to apply when loading the instructions\n   * @param keepString - Whether the load instructions should remain as a string (if it's a string)\n   *\n   */\n  public applyLoadOptions(loadInstructions: LoadInstruction | LoadInstruction[], options: ILoadOptions, keepString = true): { instructions: string | RoutingInstruction[]; scope: RoutingScope | null } {\n    options = options ?? {};\n    if ('origin' in options && !('context' in options)) {\n      options.context = options.origin;\n    }\n\n    const { scope, instruction } = RoutingScope.for(options.context ?? null, typeof loadInstructions === 'string' ? loadInstructions : undefined);\n    if (typeof loadInstructions === 'string') {\n      if (!keepString) {\n        loadInstructions = RoutingInstruction.from(this, instruction as string);\n        for (const loadInstruction of loadInstructions as RoutingInstruction[]) {\n          if (loadInstruction.scope === null) {\n            loadInstruction.scope = scope;\n          }\n        }\n      } else {\n        loadInstructions = instruction as string;\n      }\n    } else {\n      loadInstructions = RoutingInstruction.from(this, loadInstructions);\n      for (const loadInstruction of loadInstructions as RoutingInstruction[]) {\n        if (loadInstruction.scope === null) {\n          loadInstruction.scope = scope;\n        }\n      }\n    }\n\n    return {\n      instructions: loadInstructions as string | RoutingInstruction[],\n      scope,\n    };\n  }\n\n  /**\n   * Refresh/reload the current navigation\n   */\n  public refresh(): Promise<boolean | void> {\n    return this.navigator.refresh();\n  }\n\n  /**\n   * Go one step back in navigation history.\n   */\n  public back(): Promise<boolean | void> {\n    return this.navigator.go(-1);\n  }\n\n  /**\n   * Go one step forward in navigation history.\n   */\n  public forward(): Promise<boolean | void> {\n    return this.navigator.go(1);\n  }\n\n  /**\n   * Go a specified amount of steps back or forward in navigation history.\n   *\n   * @param delta - The amount of steps to go. A positive number goes\n   * forward, a negative goes backwards.\n   */\n  public go(delta: number): Promise<boolean | void> {\n    return this.navigator.go(delta);\n  }\n\n  /**\n   * Check whether a set of instructions are active. All instructions need\n   * to be active for the condition to be true.\n   *\n   * @param instructions - The instructions to check\n   * @param options - The load options to apply to the instructions to check\n   */\n  public checkActive(instructions: LoadInstruction | LoadInstruction[], options?: ILoadOptions): boolean {\n    // TODO: Look into allowing strings/routes as well\n    if (typeof instructions === 'string') {\n      throw createMappedError(ErrorNames.router_check_activate_string_error, instructions);\n    }\n    options = options ?? {};\n\n    // Make sure we have proper routing instructions\n    ({ instructions } = this.applyLoadOptions(instructions, options));\n    // If no scope is set, use the root scope\n    (instructions as RoutingInstruction[]).forEach((instruction: RoutingInstruction) => instruction.scope ??= this.rootScope!.scope);\n\n    // Get all unique involved scopes.\n    const scopes = arrayUnique((instructions as RoutingInstruction[]).map(instruction => instruction.scope));\n\n    // Go through all the scopes and for each scope...\n    for (const scope of scopes as RoutingScope[]) {\n      // ...get the matching (top/entry level) instructions...\n      const scopeInstructions = scope.matchScope(instructions as RoutingInstruction[], false);\n      // ...and active instructions (on any level) and...\n      const scopeActives = scope.matchScope(this.activeComponents, true);\n\n      // ...if any instruction, including next scope instructions, isn't found...\n      if (!RoutingInstruction.contains(this, scopeActives, scopeInstructions, true)) {\n        // ...the instructions are not considered active.\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Deal with/throw an unresolved instructions error.\n   *\n   * @param navigation - The failed navigation\n   * @param instructions - The unresovled instructions\n   */\n  public unresolvedInstructionsError(navigation: Navigation, instructions: RoutingInstruction[]): void {\n    this.ea.publish(RouterNavigationErrorEvent.eventName, RouterNavigationErrorEvent.create(navigation));\n    this.ea.publish(RouterNavigationEndEvent.eventName, RouterNavigationEndEvent.create(navigation));\n    throw createUnresolvedinstructionsError(instructions, this._logger);\n  }\n\n  /**\n   * Cancel a navigation (without it being an error).\n   *\n   * @param navigation - The navigation to cancel\n   * @param coordinator - The coordinator for the navigation\n   */\n  public cancelNavigation(navigation: Navigation, coordinator: NavigationCoordinator): void {\n    coordinator.cancel();\n    this.ea.publish(RouterNavigationCancelEvent.eventName, RouterNavigationCancelEvent.create(navigation));\n    this.ea.publish(RouterNavigationEndEvent.eventName, RouterNavigationEndEvent.create(navigation));\n  }\n\n  /**\n   * Append instructions to the current navigation.\n   *\n   * @param instructions - The instructions to append\n   * @param scope - The scope of the instructions\n   */\n  public appendInstructions(instructions: RoutingInstruction[], scope: RoutingScope | null = null, coordinator: NavigationCoordinator | null = null): void {\n    if (scope === null) {\n      scope = this.rootScope!.scope;\n    }\n    for (const instruction of instructions) {\n      if (instruction.scope === null) {\n        instruction.scope = scope;\n      }\n    }\n    if (coordinator === null) {\n      for (let i = this.coordinators.length - 1; i >= 0; i--) {\n        if (!this.coordinators[i].closed) {\n          coordinator = this.coordinators[i];\n          break;\n        }\n      }\n    }\n    if (coordinator === null) {\n      // If we haven't loaded the first instruction, the append is from\n      // viewport defaults so we add them to router's appendInstructions\n      // so they are added to the first navigation.\n      if (!this.loadedFirst) {\n        this.appendedInstructions.push(...instructions);\n      } else {\n        throw createMappedError(ErrorNames.router_failed_appending_routing_instructions);\n      }\n    }\n    coordinator?.appendInstructions(instructions);\n  }\n\n  /**\n   * Update the navigation with full state, url, query string and title. The\n   * appropriate hooks are called. The `activeComponents` are also set.\n   *\n   * @param navigation - The navigation to update\n   */\n  private async updateNavigation(navigation: Navigation): Promise<void> {\n    // Make sure instructions added not from root scope are properly parented\n    // up to root scope\n    (this.rootScope as ViewportScope).scope.reparentRoutingInstructions();\n\n    const instructions = (this.rootScope as ViewportScope).scope.getRoutingInstructions(navigation.timestamp) as RoutingInstruction[];\n\n    // The following makes sure right viewport/viewport scopes are set and update\n    // whether viewport name is necessary or not\n    let { matchedInstructions } = this.rootScope!.scope.matchEndpoints(instructions, [], true);\n    let guard = 100;\n    while (matchedInstructions.length > 0) {\n      // Guard against endless loop\n      if (guard-- === 0) {\n        throw createMappedError(ErrorNames.router_failed_finding_viewport_when_updating_viewer_path);\n      }\n      matchedInstructions = matchedInstructions.map(instruction => {\n        const { matchedInstructions } = instruction.endpoint.instance!.scope.matchEndpoints(instruction.nextScopeInstructions ?? [], [], true);\n        return matchedInstructions;\n      }).flat();\n    }\n\n    if (navigation.timestamp >= (this.activeNavigation?.timestamp ?? 0)) {\n      this.activeNavigation = navigation;\n      this.activeComponents = instructions;\n    }\n\n    // const fullViewportStates: RoutingInstruction[] = [];\n    // // Handle default / root page, because \"-\" + \"\" = \"-\" (so just a \"clear\")\n    // const targetRoute = instructions.length === 1 ? instructions[0].route : null;\n    // if (!(targetRoute != null && ((typeof targetRoute === 'string' && targetRoute === '') || ((targetRoute as FoundRoute).matching === '')))) {\n    //   fullViewportStates.push(RoutingInstruction.create(RoutingInstruction.clear(this)) as RoutingInstruction);\n    // }\n\n    // fullViewportStates.push(...RoutingInstruction.clone(instructions, this.statefulHistory));\n    // navigation.fullStateInstruction = fullViewportStates;\n\n    // First invoke with viewport instructions (should it perhaps get full state?)\n    let state = await RoutingHook.invokeTransformToUrl(instructions, navigation);\n    if (typeof state !== 'string') {\n      // Convert to string if necessary\n      state = RoutingInstruction.stringify(this, state, { endpointContext: true });\n    }\n    // Invoke again with string\n    state = await RoutingHook.invokeTransformToUrl(state, navigation);\n\n    // Specified query has precedence over parameters\n    if (navigation.query == null && navigation.parameters != null) {\n      const search = new URLSearchParams();\n      for (let [key, values] of Object.entries(navigation.parameters)) {\n        key = encodeURIComponent(key);\n        if (!Array.isArray(values)) {\n          values = [values];\n        }\n        for (const value of values as string[]) {\n          search.append(key, encodeURIComponent(value));\n        }\n      }\n      navigation.query = search.toString();\n    }\n\n    // Add base path...\n    let basePath = `${this.configuration.options.basePath as string}/`;\n    // ...unless it's not set or we've got an absolute state/path (or we're using fragment hash)\n    if (basePath === null || (state !== '' && state[0] === '/') ||\n      this.configuration.options.useUrlFragmentHash) {\n      basePath = '';\n    }\n\n    const query = ((navigation.query?.length ?? 0) > 0 ? \"?\" + (navigation.query as string) : '');\n    const fragment = ((navigation.fragment?.length ?? 0) > 0 ? \"#\" + (navigation.fragment as string) : '');\n    navigation.path = basePath + (state as string) + query + fragment;\n\n    const path = navigation.path.slice(basePath.length);\n    navigation.fullStateInstruction = RoutingInstruction.clear(this) + (path.length > 0 ? Separators.for(this).sibling : '') + path;\n\n    if ((navigation.title ?? null) === null) {\n      const title = await Title.getTitle(instructions, navigation, this.configuration.options.title);\n      if (title !== null) {\n        // eslint-disable-next-line require-atomic-updates\n        navigation.title = title;\n      }\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Extract and setup the fragment and query from instructions or options.\n   *\n   * @param instructions - The string instructions to extract from\n   * @param options - The options containing the fragment and query\n   *\n   * TODO: Review query extraction; different pos for path and fragment\n   *\n   * @internal\n   */\n  private _extractFragmentAndQuery(instructions: LoadInstruction | LoadInstruction[], options: ILoadOptions): { instructions: LoadInstruction | LoadInstruction[]; options: ILoadOptions } {\n    options = { ...options };\n\n    // If instructions is a string and contains a fragment, extract it\n    if (typeof instructions === 'string' && options.fragment == null) {\n      const [path, fragment] = instructions.split('#');\n      instructions = path;\n      options.fragment = fragment;\n    }\n\n    // If instructions is a string and contains a query string, extract it\n    if (typeof instructions === 'string' && options.query == null) {\n      const [path, search] = instructions.split('?');\n      instructions = path;\n      options.query = search;\n    }\n    // If parameters is a string, it's really a query string so move it\n    if (typeof options.parameters === 'string' && options.query == null) {\n      options.query = options.parameters;\n      options.parameters = void 0;\n    }\n\n    if (typeof (options.query) === 'string' && options.query.length > 0) {\n      options.parameters ??= {};\n      const searchParams = new URLSearchParams(options.query);\n      searchParams.forEach((value: string, key: string) => {\n        key = decodeURIComponent(key);\n        value = decodeURIComponent(value);\n\n        if (key in (options.parameters as Record<string, unknown>)) {\n          if (!Array.isArray((options.parameters as Record<string, unknown>)[key])) {\n            (options.parameters as Record<string, unknown>)[key] = [(options.parameters as Record<string, unknown>)[key] as string];\n          }\n          ((options.parameters as Record<string, unknown>)[key] as string[]).push(value);\n        } else {\n          (options.parameters as Record<string, unknown>)[key] = value;\n        }\n      });\n    }\n\n    return { instructions, options };\n  }\n}\n\ninterface UnresolvedInstructionsError extends Error {\n  remainingInstructions: RoutingInstruction[];\n}\n\nfunction createUnresolvedinstructionsError(remainingInstructions: RoutingInstruction[], logger: ILogger): UnresolvedInstructionsError {\n  // TODO: Improve error message, including suggesting solutions\n  const error = createMappedError(ErrorNames.router_infinite_instruction, remainingInstructions.length) as Partial<UnresolvedInstructionsError>;\n  error.remainingInstructions = remainingInstructions;\n  logger.warn(error, error.remainingInstructions);\n  if (__DEV__) {\n    // eslint-disable-next-line no-console\n    console.log(error, error.remainingInstructions);\n  }\n  return error as UnresolvedInstructionsError;\n}\n\nexport class RouterEvent {\n  public constructor(\n    public readonly eventName: string,\n  ) { }\n}\nexport class RouterStartEvent extends RouterEvent {\n  public static eventName: 'au:router:router-start' = 'au:router:router-start';\n  public static create(): RouterStartEvent {\n    return new RouterStartEvent(this.eventName);\n  }\n}\nexport class RouterStopEvent extends RouterEvent {\n  public static eventName: 'au:router:router-stop' = 'au:router:router-stop';\n  public static create(): RouterStopEvent {\n    return new RouterStopEvent(this.eventName);\n  }\n}\n\nexport class RouterNavigationEvent {\n  public constructor(\n    public readonly eventName: string,\n    public readonly navigation: Navigation,\n  ) { }\n}\nexport class RouterNavigationStartEvent extends RouterNavigationEvent {\n  public static readonly eventName: 'au:router:navigation-start' = 'au:router:navigation-start';\n  public static create(navigation: Navigation): RouterNavigationStartEvent {\n    return new RouterNavigationStartEvent(this.eventName, navigation);\n  }\n}\nexport class RouterNavigationEndEvent extends RouterNavigationEvent {\n  public static readonly eventName: 'au:router:navigation-end' = 'au:router:navigation-end';\n  public static create(navigation: Navigation): RouterNavigationEndEvent {\n    return new RouterNavigationEndEvent(this.eventName, navigation);\n  }\n}\nexport class RouterNavigationCancelEvent extends RouterNavigationEvent {\n  public static readonly eventName: 'au:router:navigation-cancel' = 'au:router:navigation-cancel';\n  public static create(navigation: Navigation): RouterNavigationCancelEvent {\n    return new RouterNavigationCancelEvent(this.eventName, navigation);\n  }\n}\nexport class RouterNavigationCompleteEvent extends RouterNavigationEvent {\n  public static readonly eventName: 'au:router:navigation-complete' = 'au:router:navigation-complete';\n  public static create(navigation: Navigation): RouterNavigationCompleteEvent {\n    return new RouterNavigationCompleteEvent(this.eventName, navigation);\n  }\n}\nexport class RouterNavigationErrorEvent extends RouterNavigationEvent {\n  public static readonly eventName: 'au:router:navigation-error' = 'au:router:navigation-error';\n  public static create(navigation: Navigation): RouterNavigationErrorEvent {\n    return new RouterNavigationErrorEvent(this.eventName, navigation);\n  }\n}\n", "import { DI, resolve } from '@aurelia/kernel';\nimport { IWindow, CustomAttribute } from '@aurelia/runtime-html';\nimport { LoadCustomAttribute } from './load';\nimport { IRouter } from '../router';\n\nexport const ILinkHandler = /*@__PURE__*/DI.createInterface<ILinkHandler>('ILinkHandler', x => x.singleton(LinkHandler));\n\nexport interface ILinkHandler extends LinkHandler { }\n\n/**\n * Class responsible for handling interactions that should trigger navigation.\n */\nexport class LinkHandler implements EventListenerObject {\n  private readonly window = resolve(IWindow);\n  private readonly router = resolve(IRouter);\n\n  public handleEvent(e: Event): void {\n    this.handleClick(e as MouseEvent);\n  }\n\n  private handleClick(event: MouseEvent): void {\n    // Only process clean left click\n    if (event.button !== 0 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {\n      return;\n    }\n\n    const target = event.currentTarget as Element;\n\n    // Ignore links with the `external` attribute\n    if (target.hasAttribute('external')) {\n      return;\n    }\n\n    // Only process links into this window\n    const targetWindow = target.getAttribute('target') ?? '';\n    if (targetWindow.length > 0 && targetWindow !== this.window.name && targetWindow !== '_self') {\n      return;\n    }\n\n    const loadAttr = CustomAttribute.for(target, 'load');\n    const load = loadAttr !== void 0 ? (loadAttr.viewModel as LoadCustomAttribute).value as string : null;\n    const href = this.router.configuration.options.useHref && target.hasAttribute('href') ? target.getAttribute('href') : null;\n\n    // Ignore empty links\n    if ((load === null || load.length === 0) && (href === null || href.length === 0)) {\n      return;\n    }\n\n    // This link is for us, so prevent default behaviour\n    event.preventDefault();\n\n    let instruction = load ?? href ?? '';\n    if (typeof instruction === 'string' && instruction.startsWith('#')) {\n      instruction = instruction.slice(1);\n      // '#' === '/' === '#/'\n      // TODO: Investigate if this is still valid (don't think so)\n      if (!instruction.startsWith('/')) {\n        instruction = `/${instruction}`;\n      }\n    }\n    this.router.load(instruction, { origin: target }).catch(error => { throw error; });\n  }\n}\n", "import { Constructable, ResourceType } from '@aurelia/kernel';\nimport { IRoute, Route } from '../route';\n\nexport type RouteType<T extends Constructable = Constructable> = ResourceType<T, InstanceType<T>, IRoute>;\nexport type RouteDecorator = <T extends Constructable>(Type: T, context: ClassDecoratorContext) => T;\n\n/**\n * Associate a static route configuration with this type.\n *\n * @param config - The route config\n */\nexport function route(config: IRoute): RouteDecorator;\n/**\n * Associate a static route configuration with this type.\n *\n * @param path - The path to match against.\n *\n * (TODO: improve the formatting, better examples, etc)\n *\n * ```\n * &#64;route('home')\n * export class Home {}\n * ```\n *\n * ```\n * &#64;route(':id')\n * export class ProductDetail {}\n * ```\n */\nexport function route(path: string): RouteDecorator;\nexport function route(configOrPath?: IRoute | string): RouteDecorator {\n  return function (target, context) {\n    context.addInitializer(function (this) {\n      Route.configure(configOrPath, target);\n    });\n    return target;\n  };\n}\n", "import { ConsideredActiveCustomAttribute } from './considered-active';\nimport { IEventAggregator } from '@aurelia/kernel';\nimport { IRouter, RouterStartEvent } from '../router';\nimport { BindingMode, CustomAttribute, IHydratedController } from '@aurelia/runtime-html';\nimport { LoadInstruction } from '../interfaces';\nimport { RoutingInstruction } from '../instructions/routing-instruction';\n\n/**\n * Get either a provided value or the value of an html attribute,\n * depending on `useValue`. If `doExistCheck` is `true` the\n * existence of the html attribute is returned, regardless of\n * `useValue` (or `value`).\n *\n * @param name - Attribute name\n * @param value - The value that's used if `useValue` or if\n * the attribute doesn't exist on the element (so it's also default)\n * @param useValue - Whether the value should be used (unless check exists)\n * @param element - The element with the attributes\n * @param doExistCheck - Whether only the existence of the html attribute\n * should be checked and returned as a boolean\n */\nexport function getValueOrAttribute(name: string, value: string | boolean, useValue: boolean, element: HTMLElement, doExistCheck: boolean = false): string | boolean | undefined {\n  // If an attribute exist check is requested, Aurelia sets the value to \"\"\n  if (doExistCheck) {\n    return value === \"\";\n    // return element.hasAttribute(name);\n  }\n  if (useValue) {\n    return value;\n  }\n  const attribute = element.getAttribute(name) ?? '';\n  // If no or empty attribute, the provided value serves as default\n  return attribute.length > 0 ? attribute : value;\n}\n\n/**\n * Make it possible to wait for router start by subscribing to the\n * router start event and return a promise that's resolved when\n * the router start event fires.\n */\nexport function waitForRouterStart(router: IRouter, ea: IEventAggregator): void | Promise<void> {\n  if (router.isActive) {\n    return;\n  }\n  return new Promise((resolve) => {\n    const subscription = ea.subscribe(RouterStartEvent.eventName, () => {\n      resolve();\n      subscription.dispose();\n    });\n  });\n}\n\nexport function getConsideredActiveInstructions(router: IRouter, controller: IHydratedController, element: HTMLElement, value: unknown): RoutingInstruction[] {\n  let activeInstructions = (CustomAttribute\n    .for(element, 'considered-active')?.viewModel as ConsideredActiveCustomAttribute)?.value as LoadInstruction;\n  if (activeInstructions === void 0) {\n    activeInstructions = value as LoadInstruction;\n  }\n\n  const created = router.applyLoadOptions(activeInstructions, { context: controller });\n  const instructions = RoutingInstruction.from(router, created.instructions);\n  for (const instruction of instructions) {\n    if (instruction.scope === null) {\n      instruction.scope = created.scope;\n    }\n  }\n  return instructions;\n}\n\nexport function getLoadIndicator(element: HTMLElement): HTMLElement {\n  let indicator = element.parentElement;\n  while (indicator != null) {\n    if (indicator.tagName === 'AU-VIEWPORT') {\n      indicator = null;\n      break;\n    }\n    if (indicator.hasAttribute('load-active')) {\n      break;\n    }\n    indicator = indicator.parentElement;\n  }\n  indicator ??= element;\n  return indicator;\n}\n\n/** @internal */ export const bmToView = BindingMode.toView;\n", "import { IContainer, IEventAggregator, resolve } from '@aurelia/kernel';\nimport {\n  INode,\n  CustomElement,\n  ICompiledCustomElementController,\n  ICustomElementViewModel,\n  ICustomElementController,\n  IHydratedController,\n  IHydratedParentController,\n  ISyntheticView,\n} from '@aurelia/runtime-html';\nimport {\n  HydrateElementInstruction,\n  IInstruction,\n} from '@aurelia/template-compiler';\nimport { IRouter, NavigationFlags } from '../index';\nimport { Viewport } from '../endpoints/viewport';\nimport { IViewportOptions } from '../endpoints/viewport-options';\nimport { Runner, Step } from '../utilities/runner';\nimport { waitForRouterStart, getValueOrAttribute } from './utils';\nimport { arrayRemove } from '../utilities/utils';\nimport { OpenPromise } from '../utilities/open-promise';\nimport { FallbackAction } from '../router-options';\n\nconst ParentViewport = CustomElement.createInjectable<ViewportCustomElement>();\n\nexport class ViewportCustomElement implements ICustomElementViewModel {\n  /**\n   * The name of the viewport. Should be unique within the routing scope.\n   */\n  public name: string = 'default';\n\n  /**\n   * A list of components that is using the viewport. These components\n   * can only be loaded into this viewport and this viewport can't\n   * load any other components.\n   */\n  public usedBy: string = '';\n\n  /**\n   * The default component that's loaded if the viewport is created\n   * without having a component specified (in that navigation).\n   */\n  public default: string = '';\n\n  /**\n   * The component loaded if the viewport can't load the specified\n   * component. The component is passed as a parameter to the fallback.\n   */\n  public fallback: string = '';\n\n  /**\n   * Whether the fallback action is to load the fallback component in\n   * place of the unloadable component and continue with any child\n   * instructions or if the fallback is to be called and the processing\n   * of the children to be aborted.\n   */\n  public fallbackAction: FallbackAction | '' = '';\n\n  /**\n   * Indicates that the viewport has no scope.\n   */\n  public noScope: boolean = false;\n\n  /**\n   * Indicates that the viewport doesn't add a content link to\n   * the Location URL.\n   */\n  public noLink: boolean = false;\n\n  /**\n   * Indicates that the viewport doesn't add a title to the browser\n   * window title.\n   */\n  public noTitle: boolean = false;\n\n  /**\n   * Indicates that the viewport doesn't add history content to\n   * the History API.\n   */\n  public noHistory: boolean = false;\n\n  /**\n   * Whether the components of the viewport are stateful or not.\n   */\n  public stateful: boolean = false;\n\n  /**\n   * The connected Viewport.\n   */\n  public endpoint: Viewport | null = null;\n\n  /**\n   * The custom element controller.\n   */\n  public controller!: ICustomElementController;\n\n  /**\n   * Child viewports waiting to be connected.\n   */\n  public pendingChildren: ViewportCustomElement[] = [];\n\n  /**\n   * Promise to await while children are waiting to be connected.\n   */\n  public pendingPromise: OpenPromise | null = null;\n\n  /**\n   * Whether the viewport is bound or not.\n   */\n  private isBound: boolean = false;\n\n  private readonly router = resolve(IRouter);\n  public readonly element = resolve(INode) as HTMLElement;\n  public readonly container: IContainer = resolve(IContainer);\n  private readonly ea: IEventAggregator = resolve(IEventAggregator);\n  public readonly parentViewport = resolve(ParentViewport);\n  private readonly instruction = resolve(IInstruction) as HydrateElementInstruction;\n\n  public hydrated(controller: ICompiledCustomElementController): void | Promise<void> {\n    this.controller = controller as ICustomElementController;\n    // TODO: Below was here for a reason, investigate if no longer necessary\n    // this.container = controller.container;\n\n    // eslint-disable-next-line\n    const hasDefault = this.instruction.props.filter((instr: any) => instr.to === 'default').length > 0;\n    if (hasDefault && this.parentViewport != null) {\n      this.parentViewport.pendingChildren.push(this);\n      if (this.parentViewport.pendingPromise === null) {\n        this.parentViewport.pendingPromise = new OpenPromise(`hydrated: ViewportCustomElement`);\n      }\n    }\n\n    Runner.run<void>(null,\n      // The first viewport(s) might be hydrated before the router is started\n      () => waitForRouterStart(this.router, this.ea),\n      () => {\n        // Only call connect this early if we need to\n        if (this.router.isRestrictedNavigation) {\n          this.connect();\n        }\n      }\n    ) as void | Promise<void>;\n  }\n\n  public binding(initiator: IHydratedController, _parent: IHydratedParentController | null): void | Promise<void> {\n    this.isBound = true;\n    return Runner.run('binding',\n      // The first viewport(s) might be bound before the router is started\n      () => waitForRouterStart(this.router, this.ea),\n      () => {\n        // Prefer to connect here since we've got bound data in component\n        if (!this.router.isRestrictedNavigation) {\n          this.connect();\n        }\n      },\n      () => {\n        // TODO(post-alpha): Consider using an event instead (not a priority)\n        // If a content is waiting for us to be connected...\n        if (this.endpoint?.activeResolve != null) {\n          // ...resolve the promise\n          this.endpoint.activeResolve();\n          this.endpoint.activeResolve = null;\n        }\n      },\n      () => {\n        if (this.endpoint !== null && this.endpoint.getNextContent() === null) {\n          return (this.endpoint.activate(null, initiator, this.controller, /* true, */ void 0) as Step<void>)?.asValue as void | Promise<void>;\n          // TODO: Restore scroll state (in attaching/attached)\n        }\n      },\n    ) as void | Promise<void>;\n  }\n\n  public detaching(initiator: IHydratedController, parent: ISyntheticView | ICustomElementController | null): void | Promise<void> {\n    if (this.endpoint !== null) {\n      // TODO: Save scroll state before detach\n      this.isBound = false;\n      return this.endpoint.deactivate(null, initiator, parent);\n    }\n  }\n\n  public unbinding(_initiator: IHydratedController, _parent: ISyntheticView | ICustomElementController | null): void | Promise<void> {\n    if (this.endpoint !== null) {\n      // TODO: Don't unload when stateful, instead save to cache. Something like\n      // this.viewport.cacheContent();\n\n      // Disconnect doesn't destroy anything, just disconnects it\n      return this.disconnect(null);\n    }\n  }\n\n  public dispose(): void {\n    this.endpoint?.dispose();\n    this.endpoint = null;\n  }\n\n  /**\n   * Connect this custom element to a router endpoint (Viewport).\n   */\n  public connect(): void {\n    const { isBound, element } = this;\n    // Collect custom element options from either properties (if the custom\n    // element has been bound) or from html attributes (booleans are always\n    // set based on whether html attribute exists)\n    const name: string = getValueOrAttribute('name', this.name, isBound, element) as string;\n    const options: IViewportOptions = {};\n    // Endpoint property is `scope` but html attribute is `no-scope` so negate it\n    options.scope = !(getValueOrAttribute('no-scope', this.noScope, false, element, true) as boolean);\n    options.usedBy = getValueOrAttribute('used-by', this.usedBy, isBound, element) as string;\n    options.default = getValueOrAttribute('default', this.default, isBound, element) as string;\n    options.fallback = getValueOrAttribute('fallback', this.fallback, isBound, element) as string;\n    options.fallbackAction = getValueOrAttribute('fallback-action', this.fallbackAction, isBound, element) as FallbackAction;\n    options.noLink = getValueOrAttribute('no-link', this.noLink, isBound, element, true) as boolean;\n    options.noTitle = getValueOrAttribute('no-title', this.noTitle, isBound, element, true) as boolean;\n    options.noHistory = getValueOrAttribute('no-history', this.noHistory, isBound, element, true) as boolean;\n    options.stateful = getValueOrAttribute('stateful', this.stateful, isBound, element, true) as boolean;\n\n    Object\n      .keys(options)\n      .forEach(key => {\n        if (options[key as keyof typeof options] === undefined) {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete options[key as keyof typeof options];\n        }\n      });\n\n    this.endpoint = this.router.connectEndpoint(this.endpoint, 'Viewport', this, name, options) as Viewport;\n\n    const parentViewport = this.parentViewport;\n    if (parentViewport != null) {\n      arrayRemove(parentViewport.pendingChildren, child => child === this);\n      if (parentViewport.pendingChildren.length === 0 && parentViewport.pendingPromise !== null) {\n        parentViewport.pendingPromise.resolve();\n        parentViewport.pendingPromise = null;\n      }\n    }\n  }\n\n  /**\n   * Disconnect this custom element from its router endpoint (Viewport).\n   */\n  public disconnect(step: Step | null): void {\n    if (this.endpoint !== null) {\n      this.router.disconnectEndpoint(step, this.endpoint, this);\n    }\n  }\n\n  /**\n   * Set whether the viewport is currently active or not. Adds or removes\n   * activity classes to the custom element\n   *\n   * @param active - Whether the viewport is active or not\n   */\n  public setActivity(state: string | NavigationFlags, active: boolean): void {\n    const prefix = this.router.configuration.options.indicators.viewportNavigating;\n\n    if (typeof state === 'string') {\n      this.element.classList.toggle(state, active);\n    } else {\n      for (const key in state) {\n        this.element.classList.toggle(`${prefix}-${key}`, active && state[key as keyof (NavigationFlags)]);\n      }\n    }\n  }\n}\nCustomElement.define({\n  name: 'au-viewport',\n  injectable: ParentViewport,\n  bindables: ['name', 'usedBy', 'default', 'fallback', 'fallbackAction', 'noScope', 'noLink', 'noTitle', 'noHistory', 'stateful']\n}, ViewportCustomElement);\n", "/**\n *\n * NOTE: This file is still WIP and will go through at least one more iteration of refactoring, commenting and clean up!\n * In its current state, it is NOT a good source for learning about the inner workings and design of the router.\n *\n */\nimport {\n  INode,\n  CustomElement,\n  ICompiledCustomElementController,\n  ICustomElementViewModel,\n  ICustomElementController,\n  IController,\n  IHydratedController,\n  ISyntheticView,\n} from '@aurelia/runtime-html';\nimport { IContainer, Writable, resolve } from '@aurelia/kernel';\nimport { IRouter } from '../index';\nimport { ViewportScope, IViewportScopeOptions } from '../endpoints/viewport-scope';\n\nconst ParentViewportScope = CustomElement.createInjectable<ViewportScopeCustomElement>();\n\nexport class ViewportScopeCustomElement implements ICustomElementViewModel {\n  public name: string = 'default';\n  public catches: string = '';\n  public collection: boolean = false;\n  public source: unknown[] | null = null;\n  public viewportScope: ViewportScope | null = null;\n\n  public readonly $controller!: ICustomElementController<this>;\n\n  public controller!: ICustomElementController;\n\n  private isBound: boolean = false;\n\n  private readonly router = resolve(IRouter);\n  public readonly element = resolve(INode) as HTMLElement;\n  public container = resolve(IContainer);\n  private readonly parent = resolve(ParentViewportScope);\n  private readonly parentController = resolve(IController) as IHydratedController;\n\n  // Maybe this really should be here. Check with Binh.\n  // public create(\n  //   controller: IDryCustomElementController<this>,\n  //   parentContainer: IContainer,\n  //   definition: CustomElementDefinition,\n  //   parts: PartialCustomElementDefinitionParts | undefined,\n  // ): PartialCustomElementDefinition {\n  //   // TODO(fkleuver): describe this somewhere in the docs instead\n  //   // Under the condition that there is no `replace` attribute on this custom element's declaration,\n  //   // and this custom element is containerless, its content will be placed in a part named 'default'\n  //   // See packages/jit-html/src/template-binder.ts line 411 (`replace = 'default';`) for the logic that governs this.\n\n  //   // We could tidy this up into a formal api in the future. For now, there are two ways to do this:\n  //   // 1. inject the `@IInstruction` (IHydrateElementInstruction) and grab .parts['default'] from there, manually creating a view factory from that, etc.\n  //   // 2. what we're doing right here: grab the 'default' part from the create hook and return it as the definition, telling the render context to use that part to compile this element instead\n  //   // This effectively causes this element to render its declared content as if it was its own template.\n\n  //   // We do need to set `containerless` to true on the part definition so that the correct projector is used since parts default to non-containerless.\n  //   // Otherwise, the controller will try to do `appendChild` on a comment node when it has to do `insertBefore`.\n\n  //   // Also, in this particular scenario (specific to viewport-scope) we need to clone the part so as to prevent the resulting compiled definition\n  //   // from ever being cached. That's the only reason why we're spreading the part into a new object for `getOrCreate`. If we didn't clone the object, this specific element wouldn't work correctly.\n\n  //   const part = parts!['default'];\n  //   return CustomElementDefinition.getOrCreate({ ...part, containerless: true });\n  // }\n\n  public hydrated(controller: ICompiledCustomElementController): void {\n    this.controller = controller as ICustomElementController;\n  }\n  public bound(_initiator: IHydratedController, _parent: ISyntheticView | ICustomElementController | null): void {\n    this.isBound = true;\n\n    (this.$controller as Writable<ICustomElementController>).scope = this.parentController.scope!;\n\n    this.connect();\n    if (this.viewportScope !== null) {\n      this.viewportScope.binding();\n    }\n  }\n  public unbinding(_initiator: IHydratedController, _parent: ISyntheticView | ICustomElementController | null): void | Promise<void> {\n    if (this.viewportScope !== null) {\n      this.viewportScope.unbinding();\n    }\n    return Promise.resolve();\n  }\n\n  public connect(): void {\n    if (this.router.rootScope === null) {\n      return;\n    }\n    const name = this.getAttribute('name', this.name) as string;\n    const options: IViewportScopeOptions = {};\n    let value: string | boolean | undefined = this.getAttribute('catches', this.catches);\n    if (value !== void 0) {\n      options.catches = value as string;\n    }\n    value = this.getAttribute('collection', this.collection, true);\n    if (value !== void 0) {\n      options.collection = value as boolean;\n    }\n\n    // TODO: Needs to be bound? How to solve?\n    options.source = this.source ?? null;\n\n    this.viewportScope = this.router.connectEndpoint(this.viewportScope, 'ViewportScope', this, name, options) as ViewportScope;\n  }\n  public disconnect(): void {\n    if (this.viewportScope) {\n      this.router.disconnectEndpoint(null, this.viewportScope, this);\n    }\n    this.viewportScope = null;\n  }\n\n  private getAttribute(key: string, value: string | boolean, checkExists: boolean = false): string | boolean | undefined {\n    if (this.isBound) {\n      return value;\n    } else {\n      if (this.element.hasAttribute(key)) {\n        if (checkExists) {\n          return true;\n        } else {\n          value = this.element.getAttribute(key) as string;\n          if (value.length > 0) {\n            return value;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n}\nCustomElement.define({\n  name: 'au-viewport-scope',\n  template: '<template></template>',\n  containerless: false,\n  injectable: ParentViewportScope,\n  bindables: ['name', 'catches', 'collection', 'source'],\n}, ViewportScopeCustomElement);\n", "import { FoundRoute } from '../found-route';\nimport { IRoutingInstruction } from '../interfaces';\nimport { IDisposable, IEventAggregator, resolve } from '@aurelia/kernel';\nimport { INode, CustomAttribute, ICustomAttributeViewModel } from '@aurelia/runtime-html';\nimport { ILinkHandler } from './link-handler';\nimport { IRouter, RouterNavigationEndEvent } from '../router';\nimport { bmToView, getConsideredActiveInstructions, getLoadIndicator } from './utils';\nimport { Parameters } from '../instructions/instruction-parameters';\nimport { RoutingInstruction } from '../instructions/routing-instruction';\nimport { RoutingScope } from '../routing-scope';\nimport { IRoute } from '../route';\n\nexport class LoadCustomAttribute implements ICustomAttributeViewModel {\n  public value: unknown;\n  public component?: string;\n  public parameters?: Parameters;\n  public viewport?: string;\n\n  /*\n   * The id for a configured route\n   */\n  public id?: string;\n\n  /** @internal */ private _separateProperties = false;\n  private hasHref: boolean | null = null;\n\n  private routerNavigationSubscription!: IDisposable;\n\n  private readonly element = resolve(INode) as HTMLElement;\n  private readonly router = resolve(IRouter);\n  private readonly linkHandler = resolve(ILinkHandler);\n  private readonly ea = resolve(IEventAggregator);\n  private readonly activeClass = this.router.configuration.options.indicators.loadActive;\n\n  public binding(): void {\n    if (this.value == null) {\n      this._separateProperties = true;\n    }\n    this.element.addEventListener('click', this.linkHandler);\n    this.updateValue();\n    void this.updateActive();\n\n    this.routerNavigationSubscription = this.ea.subscribe(RouterNavigationEndEvent.eventName, this.navigationEndHandler);\n  }\n\n  public unbinding(): void {\n    this.element.removeEventListener('click', this.linkHandler);\n    this.routerNavigationSubscription.dispose();\n  }\n\n  public valueChanged(_newValue: unknown): void {\n    this.updateValue();\n    void this.updateActive();\n  }\n\n  private updateValue(): void {\n    if (this._separateProperties) {\n      this.value = {\n        component: this.component,\n        parameters: this.parameters,\n        viewport: this.viewport,\n        id: this.id,\n      };\n    }\n\n    if (this.hasHref === null) {\n      this.hasHref = this.element.hasAttribute('href');\n    }\n    if (!this.hasHref) {\n      let value = this.value as string;\n      if (typeof value !== 'string') {\n        const instruction = RoutingInstruction.from(this.router, value as IRoutingInstruction).shift() as RoutingInstruction;\n        const found = this._findRoute(value as IRoute);\n        if (found.foundConfiguration) {\n          instruction.route = found.matching;\n        }\n        value = RoutingInstruction.stringify(this.router, [instruction]);\n      }\n      const { scope, instruction } = RoutingScope.for(this.element, value);\n      const scopePath = scope?.path ?? '';\n      value = `${scopePath}${instruction ?? ''}`;\n      if (this.router.configuration.options.useUrlFragmentHash && !value.startsWith('#')) {\n        value = `#/${value}`;\n      }\n      this.element.setAttribute('href', value);\n    }\n  }\n  private readonly navigationEndHandler = (_navigation: RouterNavigationEndEvent): void => {\n    void this.updateActive();\n  };\n\n  private async updateActive(): Promise<void> {\n    const controller = CustomAttribute.for(this.element, 'load')!.parent!;\n    const routeValue = typeof this.value === 'string' ? { id: this.value, path: this.value } : this.value;\n    const found = this._findRoute(routeValue as IRoute);\n    const instructions = found.foundConfiguration\n      ? found.instructions\n      : getConsideredActiveInstructions(this.router, controller, this.element, this.value);\n    const element = getLoadIndicator(this.element);\n\n    element.classList.toggle(this.activeClass, this.router.checkActive(instructions, { context: controller }));\n  }\n\n  /** @internal */\n  private _findRoute(value: string | IRoute): FoundRoute {\n    if (typeof value === 'string') {\n      return new FoundRoute();\n    }\n    const scope = RoutingScope.for(this.element).scope ?? this.router.rootScope!.scope;\n    if (value.id != null) {\n      return scope.findMatchingRoute(value.id, value.parameters as Parameters ?? {});\n    }\n    const path = value.path as string;\n    if (path != null) {\n      return scope.findMatchingRoute(path, value.parameters as Parameters ?? {});\n    }\n    return new FoundRoute();\n  }\n}\nCustomAttribute.define({\n  name: 'load',\n  bindables: {\n    value: { mode: bmToView },\n    component: {},\n    parameters: {},\n    viewport: {},\n    id: {},\n  }\n}, LoadCustomAttribute);\n", "import { IDisposable, IEventAggregator, resolve } from '@aurelia/kernel';\nimport { INode, ICustomAttributeViewModel, ICustomAttributeController, CustomAttribute, CustomAttributeStaticAuDefinition } from '@aurelia/runtime-html';\nimport { IRouter, RouterNavigationEndEvent } from '../router';\nimport { LoadCustomAttribute } from '../index';\nimport { ILinkHandler } from './link-handler';\nimport { bmToView, getConsideredActiveInstructions, getLoadIndicator } from './utils';\n\nexport class HrefCustomAttribute implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: 'custom-attribute',\n    name: 'href',\n    noMultiBindings: true,\n    bindables: {\n      value: { mode: bmToView }\n    }\n  };\n\n  public value: string | undefined;\n\n  public readonly $controller!: ICustomAttributeController<this>;\n\n  private routerNavigationSubscription?: IDisposable;\n\n  private readonly element = resolve(INode) as HTMLElement;\n  private readonly router = resolve(IRouter);\n  private readonly linkHandler = resolve(ILinkHandler);\n  private readonly ea = resolve(IEventAggregator);\n  private readonly activeClass = this.router.configuration.options.indicators.loadActive;\n\n  public binding(): void {\n    if (this.router.configuration.options.useHref && !this.hasLoad() && !this.element.hasAttribute('external')) {\n      this.element.addEventListener('click', this.linkHandler);\n      this.routerNavigationSubscription = this.ea.subscribe(RouterNavigationEndEvent.eventName, this.navigationEndHandler);\n    }\n    this.updateValue();\n    this.updateActive();\n  }\n  public unbinding(): void {\n    this.element.removeEventListener('click', this.linkHandler);\n    this.routerNavigationSubscription?.dispose();\n  }\n\n  public valueChanged(): void {\n    this.updateValue();\n    this.updateActive();\n  }\n\n  private updateValue(): void {\n    this.element.setAttribute('href', this.value as string);\n  }\n\n  private readonly navigationEndHandler = (_navigation: RouterNavigationEndEvent): void => {\n    this.updateActive();\n  };\n\n  private updateActive(): void {\n    if (this.router.configuration.options.useHref && !this.hasLoad() && !this.element.hasAttribute('external')) {\n      const controller = CustomAttribute.for(this.element, 'href')!.parent!;\n      const instructions = getConsideredActiveInstructions(this.router, controller, this.element, this.value);\n      const element = getLoadIndicator(this.element);\n\n      element.classList.toggle(this.activeClass, this.router.checkActive(instructions, { context: controller }));\n    }\n  }\n\n  private hasLoad(): boolean {\n    const parent = this.$controller.parent!;\n    const siblings = parent.children;\n    return siblings?.some(c => c.vmKind === 'customAttribute' && c.viewModel instanceof LoadCustomAttribute) ?? false;\n  }\n}\n", "import { ICustomAttributeViewModel, CustomAttribute } from '@aurelia/runtime-html';\nimport { bmToView } from './utils';\n\nexport class ConsideredActiveCustomAttribute implements ICustomAttributeViewModel {\n  public value: unknown;\n}\nCustomAttribute.define({ name: 'considered-active', bindables: { value: { mode: bmToView } } }, ConsideredActiveCustomAttribute);\n", "import { DI, IContainer, IRegistry } from '@aurelia/kernel';\nimport { AppTask } from '@aurelia/runtime-html';\nimport { ViewportCustomElement } from './resources/viewport';\nimport { ViewportScopeCustomElement } from './resources/viewport-scope';\nimport { LoadCustomAttribute } from './resources/load';\nimport { HrefCustomAttribute } from './resources/href';\nimport { ConsideredActiveCustomAttribute } from './resources/considered-active';\nimport { IRouter, Router } from './router';\nimport { IRouterOptions, RouterOptions } from './router-options';\nimport { BeforeNavigationHookFunction, IRoutingHookOptions, RoutingHook, RoutingHookFunction, RoutingHookIdentity, TransformFromUrlHookFunction, TransformTitleHookFunction, TransformToUrlHookFunction } from './routing-hook';\n\nexport const IRouterConfiguration = /*@__PURE__*/DI.createInterface<IRouterConfiguration>('IRouterConfiguration', x => x.singleton(RouterConfiguration));\nexport interface IRouterConfiguration extends RouterConfiguration { }\n\nexport const RouterRegistration = IRouter as unknown as IRegistry;\n\n/**\n * Default runtime/environment-agnostic implementations for the following interfaces:\n * - `IRouter`\n */\nexport const DefaultComponents = [\n  RouterRegistration,\n];\n\nexport {\n  ViewportCustomElement,\n  ViewportScopeCustomElement,\n  LoadCustomAttribute,\n  HrefCustomAttribute,\n  ConsideredActiveCustomAttribute,\n};\n\nexport const ViewportCustomElementRegistration = ViewportCustomElement as unknown as IRegistry;\nexport const ViewportScopeCustomElementRegistration = ViewportScopeCustomElement as unknown as IRegistry;\nexport const LoadCustomAttributeRegistration = LoadCustomAttribute as unknown as IRegistry;\nexport const HrefCustomAttributeRegistration = HrefCustomAttribute as unknown as IRegistry;\nexport const ConsideredActiveCustomAttributeRegistration = ConsideredActiveCustomAttribute as unknown as IRegistry;\n\n/**\n * Default router resources:\n * - Custom Elements: `au-viewport`, `au-nav`\n * - Custom Attributes: `goto`, `load`, `href`\n */\nexport const DefaultResources: IRegistry[] = [\n  ViewportCustomElement as unknown as IRegistry,\n  ViewportScopeCustomElement as unknown as IRegistry,\n  LoadCustomAttribute as unknown as IRegistry,\n  HrefCustomAttribute as unknown as IRegistry,\n  ConsideredActiveCustomAttribute as unknown as IRegistry,\n];\n\n/**\n * A DI configuration object containing router resource registrations\n * and the router options API.\n */\nexport class RouterConfiguration {\n  // ONLY used during registration to support .customize. Transfered to\n  // instance property after that.\n  private static options = RouterOptions.create();\n\n  private static configurationCall: ((router: IRouter) => void) = (router: IRouter) => {\n    router.start();\n  };\n\n  /**\n   * The router options.\n   */\n  public options!: RouterOptions;\n\n  /**\n   * Register this configuration in a provided container and\n   * register app tasks for starting and stopping the router.\n   *\n   * @param container - The container to register in\n   */\n  public static register(container: IContainer): IContainer {\n    const _this = container.get(IRouterConfiguration);\n    // Transfer options (that's possibly modified through .customize)\n    _this.options = RouterConfiguration.options;\n    _this.options.setRouterConfiguration(_this);\n    // Reset defaults\n    RouterConfiguration.options = RouterOptions.create();\n\n    return container.register(\n      ...DefaultComponents,\n      ...DefaultResources,\n      AppTask.activating(IRouter, RouterConfiguration.configurationCall),\n      AppTask.activated(IRouter, (router: IRouter) => router.initialLoad() as Promise<void>),\n      AppTask.deactivated(IRouter, (router: IRouter) => router.stop()),\n    );\n  }\n\n  /**\n   * Make it possible to specify options to Router activation.\n   *\n   * @param config - Either a config object that's passed to router's\n   * start or a config function that's called instead of router's start.\n   */\n  public static customize(config?: IRouterOptions | ((router: IRouter) => void)): RouterConfiguration {\n    if (config === undefined) {\n      RouterConfiguration.options = RouterOptions.create();\n      RouterConfiguration.configurationCall = (router: IRouter) => {\n        router.start();\n      };\n    } else if (config instanceof Function) {\n      RouterConfiguration.configurationCall = config;\n    } else {\n      RouterConfiguration.options = RouterOptions.create();\n      RouterConfiguration.options.apply(config);\n    }\n    return RouterConfiguration as unknown as RouterConfiguration;\n  }\n\n  /**\n   * Create a new container with this configuration applied to it.\n   */\n  public static createContainer(): IContainer {\n    return this.register(DI.createContainer());\n  }\n\n  /**\n   * Get the router configuration for a context.\n   *\n   * @param context - The context to get the configuration for\n   */\n  public static for(context: IRouter | IContainer): RouterConfiguration {\n    if (context instanceof Router) {\n      return context.configuration;\n    }\n    return context.get(IRouterConfiguration);\n  }\n\n  /**\n   * Apply router options.\n   *\n   * @param options - The options to apply\n   * @param firstResetDefaults - Whether the default router options should\n   * be set before applying the specified options\n   */\n  public apply(options: IRouterOptions, firstResetDefaults: boolean = false): void {\n    if (firstResetDefaults) {\n      this.options = RouterOptions.create();\n    }\n    this.options.apply(options);\n  }\n\n  /**\n   * Add a routing hook.\n   *\n   * @param hookFunction - The hook callback function\n   * @param options - Options specifyinig hook type and filters\n   */\n  public addHook(beforeNavigationHookFunction: BeforeNavigationHookFunction, options?: IRoutingHookOptions): RoutingHookIdentity;\n  public addHook(transformFromUrlHookFunction: TransformFromUrlHookFunction, options?: IRoutingHookOptions): RoutingHookIdentity;\n  public addHook(transformToUrlHookFunction: TransformToUrlHookFunction, options?: IRoutingHookOptions): RoutingHookIdentity;\n  public addHook(transformTitleHookFunction: TransformTitleHookFunction, options?: IRoutingHookOptions): RoutingHookIdentity;\n  public addHook(hookFunction: RoutingHookFunction, options?: IRoutingHookOptions): RoutingHookIdentity;\n  public addHook(hookFunction: RoutingHookFunction, options?: IRoutingHookOptions): RoutingHookIdentity {\n    return RoutingHook.add(hookFunction, options);\n  }\n  /**\n   * Remove a routing hook.\n   *\n   * @param id - The id of the hook to remove (returned from the addHook call)\n   */\n  public removeHook(id: RoutingHookIdentity): void {\n    return RoutingHook.remove(id);\n  }\n  /**\n   * Remove all routing hooks.\n   */\n  public removeAllHooks(): void {\n    return RoutingHook.removeAll();\n  }\n\n  // TODO: This goes in here\n  // public addRoutes(routes: IRoute[], context?: ICustomElementViewModel | Element): IRoute[] {\n  //   // TODO: This should add to the context instead\n  //   // TODO: Add routes without context to rootScope content (which needs to be created)?\n  //   return [];\n  //   // const viewport = (context !== void 0 ? this.closestViewport(context) : this.rootScope) || this.rootScope as Viewport;\n  //   // return viewport.addRoutes(routes);\n  // }\n\n  // public removeRoutes(routes: IRoute[] | string[], context?: ICustomElementViewModel | Element): void {\n  //   // TODO: This should remove from the context instead\n  //   // const viewport = (context !== void 0 ? this.closestViewport(context) : this.rootScope) || this.rootScope as Viewport;\n  //   // return viewport.removeRoutes(routes);\n  // }\n}\n"],
  "mappings": "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",
  "names": ["route", "Endpoint", "index", "key", "resolve", "routes", "route", "_a", "instruction", "_b", "_d", "_c", "RouteRecognizer", "$RouteRecognizer", "ConfigurableRoute", "$ConfigurableRoute", "RecognizedRoute", "$RecognizedRoute", "$Endpoint", "available", "step", "path", "scope", "unresolvedPromise", "state", "options", "matchedInstructions"]
}
