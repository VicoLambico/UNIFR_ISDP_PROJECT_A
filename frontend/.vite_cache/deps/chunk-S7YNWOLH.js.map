{
  "version": 3,
  "sources": ["../../node_modules/@aurelia/metadata/src/index.ts", "../../node_modules/@aurelia/kernel/src/utilities.ts", "../../node_modules/@aurelia/kernel/src/errors.ts", "../../node_modules/@aurelia/kernel/src/functions.ts", "../../node_modules/@aurelia/kernel/src/di.registration.ts", "../../node_modules/@aurelia/kernel/src/resource.ts", "../../node_modules/@aurelia/kernel/src/di.container.ts", "../../node_modules/@aurelia/kernel/src/di.ts", "../../node_modules/@aurelia/kernel/src/platform.ts", "../../node_modules/@aurelia/kernel/src/di.resolvers.ts", "../../node_modules/node_modules/tslib/tslib.es6.js", "../../node_modules/@aurelia/kernel/src/logger.ts", "../../node_modules/@aurelia/kernel/src/module-loader.ts", "../../node_modules/@aurelia/kernel/src/eventaggregator.ts", "../../node_modules/@aurelia/expression-parser/src/ast.ts", "../../node_modules/@aurelia/expression-parser/src/utilities.ts", "../../node_modules/@aurelia/expression-parser/src/ast.visitor.ts", "../../node_modules/@aurelia/expression-parser/src/errors.ts", "../../node_modules/@aurelia/expression-parser/src/expression-parser.ts", "../../node_modules/@aurelia/platform/src/index.ts", "../../node_modules/node_modules/tslib/tslib.es6.js", "../../node_modules/@aurelia/runtime-html/src/binding/interfaces-bindings.ts", "../../node_modules/@aurelia/runtime-html/src/utilities-metadata.ts", "../../node_modules/@aurelia/runtime-html/src/utilities.ts", "../../node_modules/@aurelia/runtime-html/src/errors.ts", "../../node_modules/@aurelia/runtime-html/src/bindable.ts", "../../node_modules/@aurelia/runtime-html/src/utilities-di.ts", "../../node_modules/@aurelia/runtime-html/src/resources/resources-shared.ts", "../../node_modules/@aurelia/runtime-html/src/resources/binding-behavior.ts", "../../node_modules/@aurelia/runtime-html/src/resources/binding-behaviors/binding-mode.ts", "../../node_modules/@aurelia/runtime-html/src/resources/binding-behaviors/debounce.ts", "../../node_modules/@aurelia/runtime-html/src/signaler.ts", "../../node_modules/@aurelia/runtime-html/src/resources/binding-behaviors/signals.ts", "../../node_modules/@aurelia/runtime-html/src/resources/binding-behaviors/throttle.ts", "../../node_modules/@aurelia/runtime-html/src/app-task.ts", "../../node_modules/@aurelia/runtime-html/src/platform.ts", "../../node_modules/@aurelia/runtime-html/src/watch.ts", "../../node_modules/@aurelia/runtime-html/src/resources/custom-attribute.ts", "../../node_modules/@aurelia/runtime-html/src/templating/lifecycle-hooks.ts", "../../node_modules/@aurelia/runtime-html/src/resources/value-converter.ts", "../../node_modules/@aurelia/runtime-html/src/binding/binding-utils.ts", "../../node_modules/@aurelia/runtime-html/src/binding/attribute-binding.ts", "../../node_modules/@aurelia/runtime-html/src/binding/interpolation-binding.ts", "../../node_modules/@aurelia/runtime-html/src/binding/content-binding.ts", "../../node_modules/@aurelia/runtime-html/src/binding/let-binding.ts", "../../node_modules/@aurelia/runtime-html/src/binding/property-binding.ts", "../../node_modules/@aurelia/runtime-html/src/binding/ref-binding.ts", "../../node_modules/@aurelia/runtime-html/src/binding/listener-binding.ts", "../../node_modules/@aurelia/runtime-html/src/templating/view.ts", "../../node_modules/@aurelia/runtime-html/src/utilities-dom.ts", "../../node_modules/@aurelia/runtime-html/src/templating/controller.projection.ts", "../../node_modules/@aurelia/runtime-html/src/binding/spread-binding.ts", "../../node_modules/@aurelia/runtime-html/src/observation/observation-utils.ts", "../../node_modules/@aurelia/runtime-html/src/observation/class-attribute-accessor.ts", "../../node_modules/@aurelia/runtime-html/src/resources/resolvers.ts", "../../node_modules/@aurelia/runtime-html/src/renderer.ts", "../../node_modules/@aurelia/runtime-html/src/templating/rendering.ts", "../../node_modules/@aurelia/runtime-html/src/templating/styles.ts", "../../node_modules/@aurelia/runtime-html/src/templating/watchers.ts", "../../node_modules/@aurelia/runtime-html/src/templating/controller.ts", "../../node_modules/@aurelia/runtime-html/src/dom.ts", "../../node_modules/@aurelia/runtime-html/src/resources/custom-element.ts", "../../node_modules/@aurelia/runtime-html/src/app-root.ts", "../../node_modules/@aurelia/runtime-html/src/aurelia.ts", "../../node_modules/@aurelia/runtime-html/src/observation/svg-analyzer.ts", "../../node_modules/@aurelia/runtime-html/src/compiler/attribute-mapper.ts", "../../node_modules/@aurelia/runtime-html/src/compiler/template-compiler.ts", "../../node_modules/@aurelia/runtime-html/src/observation/attribute-ns-accessor.ts", "../../node_modules/@aurelia/runtime-html/src/observation/data-attribute-accessor.ts", "../../node_modules/@aurelia/runtime-html/src/observation/select-value-observer.ts", "../../node_modules/@aurelia/runtime-html/src/observation/style-attribute-accessor.ts", "../../node_modules/@aurelia/runtime-html/src/observation/value-attribute-observer.ts", "../../node_modules/@aurelia/runtime-html/src/observation/observer-locator.ts", "../../node_modules/@aurelia/runtime-html/src/observation/checked-observer.ts", "../../node_modules/@aurelia/runtime-html/src/resources/binding-behaviors/attr.ts", "../../node_modules/@aurelia/runtime-html/src/resources/binding-behaviors/self.ts", "../../node_modules/@aurelia/runtime-html/src/resources/binding-behaviors/update-trigger.ts", "../../node_modules/@aurelia/runtime-html/src/resources/template-controllers/if.ts", "../../node_modules/@aurelia/runtime-html/src/resources/template-controllers/repeat.ts", "../../node_modules/@aurelia/runtime-html/src/resources/template-controllers/with.ts", "../../node_modules/@aurelia/runtime-html/src/resources/template-controllers/switch.ts", "../../node_modules/@aurelia/runtime-html/src/resources/template-controllers/promise.ts", "../../node_modules/@aurelia/runtime-html/src/resources/custom-attributes/focus.ts", "../../node_modules/@aurelia/runtime-html/src/resources/template-controllers/portal.ts", "../../node_modules/@aurelia/runtime-html/src/resources/custom-elements/au-slot.ts", "../../node_modules/@aurelia/runtime-html/src/resources/custom-elements/au-compose.ts", "../../node_modules/@aurelia/runtime-html/src/resources/value-converters/sanitize.ts", "../../node_modules/@aurelia/runtime-html/src/resources/custom-attributes/show.ts", "../../node_modules/@aurelia/runtime-html/src/configuration.ts", "../../node_modules/@aurelia/runtime-html/src/templating/children.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * TODO: add description.\n * References:\n * - https://github.com/tc39/proposal-decorator-metadata\n * - https://github.com/microsoft/TypeScript/issues/55788\n */\nexport function initializeTC39Metadata() {\n  // We need the any-coercion here because the metadata in Symbol is marked as unique symbol.\n  // And the symbol we are creating here is not assignable to the unique symbol.\n  // More info: https://github.com/Microsoft/TypeScript/issues/23388\n  (Symbol as any).metadata ??= Symbol.for(\"Symbol.metadata\");\n}\n\nexport const Metadata = {\n  get<T>(key: string, type: any): T | undefined {\n    return type[Symbol.metadata]?.[key];\n  },\n  define(value: any, type: any,...keys: string[]): void {\n    // Define metadata on the type, when absent.\n    // Note that TS also does exactly that when decorators are used.\n    // This avoids the problem of children inheriting and overwriting metadata from their parents.\n    let metadata = Object.getOwnPropertyDescriptor(type, Symbol.metadata)?.value;\n    if (metadata == null) {\n      Object.defineProperty(type, Symbol.metadata, { value: metadata = Object.create(null), enumerable: true, configurable: true, writable: true });\n    }\n    const length = keys.length;\n    switch (length) {\n      case 0: throw new Error('At least one key must be provided');\n      case 1: metadata[keys[0]] = value; return;\n      case 2: metadata[keys[0]] = metadata[keys[1]] = value; return;\n      default: {\n        for (let i = 0; i < length; ++i) {\n          metadata[keys[i]] = value;\n        }\n        return;\n      }\n    }\n  },\n  has(key: string, type: any): boolean {\n    const metadata = type[Symbol.metadata];\n    return metadata == null\n      ? false\n      : key in metadata;\n  },\n  delete(key: string, type: any): void {\n    const metadata = type[Symbol.metadata];\n    if (metadata == null) return;\n    Reflect.deleteProperty(metadata, key);\n    return;\n  },\n};\n", "import { Metadata } from '@aurelia/metadata';\n\n/** @internal */ export const objectFreeze = Object.freeze;\n/** @internal */ export const objectAssign = Object.assign;\n/** @internal */ export const safeString = String;\n/** @internal */ export const getMetadata = Metadata.get;\n/** @internal */ export const hasMetadata = Metadata.has;\n/** @internal */ export const defineMetadata = Metadata.define;\n\n/**\n * Returns true if the value is a Promise via checking if it's an instance of Promise.\n * This does not work for objects across different realms (e.g., iframes).\n * An utility to be shared among core packages for better size optimization\n */\nexport const isPromise = <T>(v: unknown): v is Promise<T> => v instanceof Promise;\n\n/**\n * Returns true if the value is an Array via checking if it's an instance of Array.\n * This does not work for objects across different realms (e.g., iframes).\n * An utility to be shared among core packages for better size optimization\n */\nexport const isArray = <T>(v: unknown): v is T[] => v instanceof Array;\n\n/**\n * Returns true if the value is a Set via checking if it's an instance of Set.\n * This does not work for objects across different realms (e.g., iframes).\n * An utility to be shared among core packages for better size optimization\n */\nexport const isSet = <T>(v: unknown): v is Set<T> => v instanceof Set;\n\n/**\n * Returns true if the value is a Map via checking if it's an instance of Map.\n * This does not work for objects across different realms (e.g., iframes).\n * An utility to be shared among core packages for better size optimization\n */\nexport const isMap = <T, K>(v: unknown): v is Map<T, K> => v instanceof Map;\n\n/**\n * Returns true if the value is an object via checking if it's an instance of Object.\n * This does not work for objects across different realms (e.g., iframes).\n * An utility to be shared among core packages only for better size optimization\n *\n * This is semi private to core packages and applications should not depend on this.\n */\nexport const isObject = (v: unknown): v is object => v instanceof Object;\n\n/**\n * IMPORTANT: This is semi private to core packages and applications should not depend on this.\n *\n * Determine whether a value is an object.\n *\n * Uses `typeof` to guarantee this works cross-realm, which is where `instanceof Object` might fail.\n *\n * Some environments where these issues are known to arise:\n * - same-origin iframes (accessing the other realm via `window.top`)\n * - `jest`.\n *\n * The exact test is:\n * ```ts\n * typeof value === 'object' && value !== null || typeof value === 'function'\n * ```\n *\n * @param value - The value to test.\n * @returns `true` if the value is an object, otherwise `false`.\n * Also performs a type assertion that defaults to `value is Object | Function` which, if the input type is a union with an object type, will infer the correct type.\n * This can be overridden with the generic type argument.\n *\n * @example\n *\n * ```ts\n * class Foo {\n *   bar = 42;\n * }\n *\n * function doStuff(input?: Foo | null) {\n *   input.bar; // Object is possibly 'null' or 'undefined'\n *\n *   // input has an object type in its union (Foo) so that type will be extracted for the 'true' condition\n *   if (isObject(input)) {\n *     input.bar; // OK (input is now typed as Foo)\n *   }\n * }\n *\n * function doOtherStuff(input: unknown) {\n *   input.bar; // Object is of type 'unknown'\n *\n *   // input is 'unknown' so there is no union type to match and it will default to 'Object | Function'\n *   if (isObject(input)) {\n *     input.bar; // Property 'bar' does not exist on type 'Object | Function'\n *   }\n *\n *   // if we know for sure that, if input is an object, it must be a specific type, we can explicitly tell the function to assert that for us\n *   if (isObject<Foo>(input)) {\n *    input.bar; // OK (input is now typed as Foo)\n *   }\n * }\n * ```\n *\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isObjectOrFunction<T extends object = Object | Function>(value: unknown): value is T {\n  return typeof value === 'object' && value !== null || typeof value === 'function';\n}\n\n/**\n * Returns true if the value is a function\n * An utility to be shared among core packages for better size optimization\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const isFunction = <T extends Function>(v: unknown): v is T => typeof v === 'function';\n\n/**\n * Returns true if the value is a string\n * An utility to be shared among core packages for better size optimization\n */\nexport const isString = (v: unknown): v is string => typeof v === 'string';\n\n/**\n * Returns true if the value is a symbol\n * An utility to be shared among core packages for better size optimization\n */\nexport const isSymbol = (v: unknown): v is string => typeof v === 'symbol';\n\n/**\n * Returns true if the value is a number\n * An utility to be shared among core packages for better size optimization\n */\nexport const isNumber = (v: unknown): v is number => typeof v === 'number';\n\n/**\n * Create an object with no prototype to be used as a record\n * An utility to be shared among core packages for better size optimization\n */\nexport const createLookup = <T>() => Object.create(null) as Record<string, T>;\n\n/**\n * Compare the 2 values without pitfall of JS ===, including NaN and +0/-0\n * An utility to be shared among core packages for better size optimization\n */\nexport const areEqual = Object.is;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type AnyFunction = (...args: any) => any;\nexport type FunctionPropNames<T> = {\n  [K in keyof T]: K extends 'constructor' ? never : NonNullable<T[K]> extends AnyFunction ? K : never;\n}[keyof T];\nexport type MaybePromise<T> = T | Promise<T>;\n", "/* eslint-disable prefer-template */\n\nimport { safeString } from './utilities';\n\n/** @internal */\nexport const createMappedError: CreateError = __DEV__\n  ? (code: ErrorNames, ...details: unknown[]) => new Error(`AUR${safeString(code).padStart(4, '0')}: ${getMessageByCode(code, ...details)}`)\n  : (code: ErrorNames, ...details: unknown[]) => new Error(`AUR${safeString(code).padStart(4, '0')}:${details.map(safeString)}`);\n\n_START_CONST_ENUM();\n/** @internal */\nexport const enum ErrorNames {\n  no_registration_for_interface = 1,\n  none_resolver_found = 2,\n  cyclic_dependency = 3,\n  no_factory = 4,\n  invalid_resolver_strategy = 5,\n  unable_auto_register = 6,\n  resource_already_exists = 7,\n  unable_resolve_key = 8,\n  unable_jit_non_constructor = 9,\n  no_jit_intrinsic_type = 10,\n  null_resolver_from_register = 11,\n  no_jit_interface = 12,\n  no_instance_provided = 13,\n  null_undefined_key = 14,\n  no_construct_native_fn = 15,\n  no_active_container_for_resolve = 16,\n  invalid_new_instance_on_interface = 17,\n  event_aggregator_publish_invalid_event_name = 18,\n  event_aggregator_subscribe_invalid_event_name = 19,\n  first_defined_no_value = 20,\n  invalid_module_transform_input = 21,\n  invalid_inject_decorator_usage = 22,\n  resource_key_already_registered = 23,\n}\n_END_CONST_ENUM();\n\nconst errorsMap: Record<ErrorNames, string>  = {\n  [ErrorNames.no_registration_for_interface]: `No registration for interface: '{{0}}'`,\n  [ErrorNames.none_resolver_found]: `'{{0}}' was registered with \"none\" resolver, are you injecting the right key?`,\n  [ErrorNames.cyclic_dependency]: `Cyclic dependency found: {{0}}`,\n  [ErrorNames.no_factory]: `Resolver for {{0}} returned a null factory`,\n  [ErrorNames.invalid_resolver_strategy]: `Invalid resolver strategy specified: {{0}}. Did you assign an invalid strategy value?`,\n  [ErrorNames.unable_auto_register]: `Unable to autoregister dependency: {{0}}`,\n  [ErrorNames.resource_already_exists]: `Resource key \"{{0}}\" already registered`,\n  [ErrorNames.unable_resolve_key]: `Unable to resolve key: {{0}}`,\n  [ErrorNames.unable_jit_non_constructor]: `Attempted to jitRegister something that is not a constructor: '{{0}}'. Did you forget to register this resource?`,\n  [ErrorNames.no_jit_intrinsic_type]: `Attempted to jitRegister an intrinsic type: \"{{0}}\". Did you forget to add @inject(Key)`,\n  [ErrorNames.null_resolver_from_register]: `Invalid resolver, null/undefined returned from the static register method.`,\n  [ErrorNames.no_jit_interface]: `Attempted to jitRegister an interface: {{0}}`,\n  [ErrorNames.no_instance_provided]: `Cannot call resolve '{{0}}' before calling prepare or after calling dispose.`,\n  [ErrorNames.null_undefined_key]: `Key cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?` +\n    `A common cause is circular dependency with bundler, did you accidentally introduce circular dependency into your module graph?`,\n  [ErrorNames.no_construct_native_fn]: `'{{0}}' is a native function and cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`,\n  [ErrorNames.no_active_container_for_resolve]: `There is not a currently active container to resolve \"{{0}}\". Are you trying to \"new Class(...)\" that has a resolve(...) call?`,\n  [ErrorNames.invalid_new_instance_on_interface]: `Failed to instantiate '{{0}}' via @newInstanceOf/@newInstanceForScope, there's no registration and no default implementation,`\n    + ` or the default implementation does not result in factory for constructing the instances.`,\n  [ErrorNames.event_aggregator_publish_invalid_event_name]: `Invalid channel name or instance: '{{0}}'.`,\n  [ErrorNames.event_aggregator_subscribe_invalid_event_name]: `Invalid channel name or type: {{0}}.`,\n  [ErrorNames.first_defined_no_value]: `No defined value found when calling firstDefined()`,\n  [ErrorNames.invalid_module_transform_input]: `Invalid module transform input: {{0}}. Expected Promise or Object.`,\n  [ErrorNames.invalid_inject_decorator_usage]: `The @inject decorator on the target ('{{0}}') type '{{1}}' is not supported.`,\n  [ErrorNames.resource_key_already_registered]: `Resource key '{{0}}' has already been registered.`,\n};\n\nconst getMessageByCode = (name: ErrorNames, ...details: unknown[]) => {\n  let cooked: string = errorsMap[name];\n  for (let i = 0; i < details.length; ++i) {\n    cooked = cooked.replace(`{{${i}}}`, String(details[i]));\n  }\n  return cooked;\n};\n\ntype CreateError = (code: ErrorNames, ...details: unknown[]) => Error;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction pleaseHelpCreateAnIssue(title: string, body?: string) {\n  return `\\nThis is likely an issue with Aurelia.\\n Please help create an issue by clicking the following link\\n`\n    + `https://github.com/aurelia/aurelia/issues/new?title=${encodeURIComponent(title)}`\n    + (body != null ? `&body=${encodeURIComponent(body)}` : '&template=bug_report.md');\n}\n\n/** @internal */\n// eslint-disable-next-line\nexport const logError = (...args: unknown[]) => (globalThis as any).console.error(...args);\n\n/** @internal */\n// eslint-disable-next-line\nexport const logWarn = (...args: unknown[]) => (globalThis as any).console.warn(...args);\n", "import { ErrorNames, createMappedError } from './errors';\nimport { Constructable, Overwrite } from './interfaces';\nimport { createLookup, isPromise, MaybePromise, objectAssign } from './utilities';\n\n/**\n * Efficiently determine whether the provided property key is numeric\n * (and thus could be an array indexer) or not.\n *\n * Always returns true for values of type `'number'`.\n *\n * Otherwise, only returns true for strings that consist only of positive integers.\n *\n * Results are cached.\n */\nexport const isArrayIndex = (() => {\n  const isNumericLookup: Record<string, boolean> = {};\n  let result: boolean | undefined = false;\n  let length = 0;\n  let ch = 0;\n  let i = 0;\n  return (value: unknown): value is number | string => {\n    switch (typeof value) {\n      case 'number':\n        return value >= 0 && (value | 0) === value;\n      case 'string':\n        result = isNumericLookup[value];\n        if (result !== void 0) {\n          return result;\n        }\n        length = value.length;\n        if (length === 0) {\n          return isNumericLookup[value] = false;\n        }\n        ch = 0;\n        i = 0;\n        for (; i < length; ++i) {\n          ch = value.charCodeAt(i);\n          if (i === 0 && ch === 0x30 && length > 1 /* must not start with 0 */ || ch < 0x30 /* 0 */ || ch > 0x39/* 9 */) {\n            return isNumericLookup[value] = false;\n          }\n        }\n        return isNumericLookup[value] = true;\n      default:\n        return false;\n    }\n  };\n})();\n\n/**\n * Base implementation of camel and kebab cases\n */\nconst baseCase = /*@__PURE__*/(function () {\n  _START_CONST_ENUM();\n  const enum CharKind {\n    none  = 0,\n    digit = 1,\n    upper = 2,\n    lower = 3,\n  }\n  _END_CONST_ENUM();\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  const isDigit = objectAssign(createLookup(), {\n    '0': true,\n    '1': true,\n    '2': true,\n    '3': true,\n    '4': true,\n    '5': true,\n    '6': true,\n    '7': true,\n    '8': true,\n    '9': true,\n  } as Record<string, true | undefined>);\n\n  const charToKind = (char: string): CharKind => {\n    if (char === '') {\n      // We get this if we do charAt() with an index out of range\n      return CharKind.none;\n    }\n\n    if (char !== char.toUpperCase()) {\n      return CharKind.lower;\n    }\n\n    if (char !== char.toLowerCase()) {\n      return CharKind.upper;\n    }\n\n    if (isDigit[char] === true) {\n      return CharKind.digit;\n    }\n\n    return CharKind.none;\n  };\n\n  return (input: string, cb: (char: string, sep: boolean) => string): string => {\n    const len = input.length;\n    if (len === 0) {\n      return input;\n    }\n\n    let sep = false;\n    let output = '';\n\n    let prevKind: CharKind;\n\n    let curChar = '';\n    let curKind = CharKind.none;\n\n    let nextChar = input.charAt(0);\n    let nextKind = charToKind(nextChar);\n\n    let i = 0;\n    for (; i < len; ++i) {\n      prevKind = curKind;\n\n      curChar = nextChar;\n      curKind = nextKind;\n\n      nextChar = input.charAt(i + 1);\n      nextKind = charToKind(nextChar);\n\n      if (curKind === CharKind.none) {\n        if (output.length > 0) {\n          // Only set sep to true if it's not at the beginning of output.\n          sep = true;\n        }\n      } else {\n        if (!sep && output.length > 0 && curKind === CharKind.upper) {\n          // Separate UAFoo into UA Foo.\n          // Separate uaFOO into ua FOO.\n          sep = prevKind === CharKind.lower || nextKind === CharKind.lower;\n        }\n\n        output += cb(curChar, sep);\n        sep = false;\n      }\n    }\n\n    return output;\n  };\n})();\n\n/**\n * Efficiently convert a string to camelCase.\n *\n * Non-alphanumeric characters are treated as separators.\n *\n * Primarily used by Aurelia to convert DOM attribute names to ViewModel property names.\n *\n * Results are cached.\n */\nexport const camelCase = /*@__PURE__*/(function () {\n  const cache = createLookup<string | undefined>();\n\n  const callback = (char: string, sep: boolean): string => {\n    return sep ? char.toUpperCase() : char.toLowerCase();\n  };\n\n  return (input: string): string => {\n    let output = cache[input];\n    if (output === void 0) {\n      output = cache[input] = baseCase(input, callback);\n    }\n\n    return output;\n  };\n})();\n\n/**\n * Efficiently convert a string to PascalCase.\n *\n * Non-alphanumeric characters are treated as separators.\n *\n * Primarily used by Aurelia to convert element names to class names for synthetic types.\n *\n * Results are cached.\n */\nexport const pascalCase = /*@__PURE__*/(function () {\n  const cache = createLookup<string | undefined>();\n\n  return (input: string): string => {\n    let output = cache[input];\n    if (output === void 0) {\n      output = camelCase(input);\n      if (output.length > 0) {\n        output = output[0].toUpperCase() + output.slice(1);\n      }\n      cache[input] = output;\n    }\n\n    return output;\n  };\n})();\n\n/**\n * Efficiently convert a string to kebab-case.\n *\n * Non-alphanumeric characters are treated as separators.\n *\n * Primarily used by Aurelia to convert ViewModel property names to DOM attribute names.\n *\n * Results are cached.\n */\nexport const kebabCase = /*@__PURE__*/(function () {\n  const cache = createLookup<string | undefined>();\n\n  const callback = (char: string, sep: boolean): string => {\n    return sep ? `-${char.toLowerCase()}` : char.toLowerCase();\n  };\n\n  return (input: string): string => {\n    let output = cache[input];\n    if (output === void 0) {\n      output = cache[input] = baseCase(input, callback);\n    }\n\n    return output;\n  };\n})();\n\n/**\n * Efficiently (up to 10x faster than `Array.from`) convert an `ArrayLike` to a real array.\n *\n * Primarily used by Aurelia to convert DOM node lists to arrays.\n */\nexport const toArray = <T = unknown>(input: ArrayLike<T>): T[] => {\n  // benchmark: http://jsben.ch/xjsyF\n  const length = input.length;\n  const arr = Array(length) as T[];\n  let i = 0;\n  for (; i < length; ++i) {\n    arr[i] = input[i];\n  }\n  return arr;\n};\n\n/**\n * Decorator. Bind the method to the class instance.\n */\nexport const bound = <\n  TThis extends object,\n  TArgs extends unknown[],\n  TReturn>(\n  originalMethod: (this: TThis, ...args: TArgs) => TReturn,\n  context: ClassMethodDecoratorContext<TThis, (this: TThis, ...args: TArgs) => TReturn>,\n): void => {\n  const methodName = context.name as string;\n  context.addInitializer(function (this: TThis) {\n    Reflect.defineProperty(this, methodName, {\n      value: originalMethod.bind(this),\n      writable: true,\n      configurable: true,\n      enumerable: false,\n    });\n  });\n};\n\nexport const mergeArrays = <T>(...arrays: (readonly T[] | undefined)[]): T[] => {\n  const result: T[] = [];\n  let k = 0;\n  const arraysLen = arrays.length;\n  let arrayLen = 0;\n  let array: readonly T[] | undefined;\n  let i = 0;\n  for (; i < arraysLen; ++i) {\n    array = arrays[i];\n    if (array !== void 0) {\n      arrayLen = array.length;\n      let j = 0;\n      for (; j < arrayLen; ++j) {\n        result[k++] = array[j];\n      }\n    }\n  }\n  return result;\n};\n\nexport const firstDefined = <T>(...values: readonly (T | undefined)[]): T => {\n  const len = values.length;\n  let value: T | undefined;\n  let i = 0;\n  for (; len > i; ++i) {\n    value = values[i];\n    if (value !== void 0) {\n      return value;\n    }\n  }\n  throw createMappedError(ErrorNames.first_defined_no_value);\n};\n\n/**\n * Get the prototypes of a class hierarchy. Es6 classes have their parent class as prototype\n * so this will return a list of constructors\n *\n * @example\n * ```ts\n * class A {}\n * class B extends A {}\n *\n * assert.deepStrictEqual(getPrototypeChain(A), [A])\n * assert.deepStrictEqual(getPrototypeChain(B), [B, A])\n * ```\n */\nexport const getPrototypeChain = /*@__PURE__*/(function () {\n  const functionPrototype = Function.prototype;\n  const getPrototypeOf = Object.getPrototypeOf;\n\n  const cache = new WeakMap<Constructable, [Constructable, ...Constructable[]]>();\n  let proto = functionPrototype as Constructable;\n  let i = 0;\n  let chain: [Constructable, ...Constructable[]] | undefined = void 0;\n\n  return function <T extends Constructable> (Type: T): readonly [T, ...Constructable[]] {\n    chain = cache.get(Type);\n    if (chain === void 0) {\n      cache.set(Type, chain = [proto = Type]);\n      i = 0;\n      while ((proto = getPrototypeOf(proto)) !== functionPrototype) {\n        chain[++i] = proto;\n      }\n    }\n    return chain as [T, ...Constructable[]];\n  };\n})();\n\nexport function toLookup<\n  T1 extends {},\n>(\n  obj1: T1,\n): T1;\nexport function toLookup<\n  T1 extends {},\n  T2 extends {},\n>(\n  obj1: T1,\n  obj2: T2,\n): Overwrite<T1, T2>;\nexport function toLookup<\n  T1 extends {},\n  T2 extends {},\n  T3 extends {},\n>(\n  obj1: T1,\n  obj2: T2,\n  obj3: T3,\n): Overwrite<T1, Overwrite<T1, T2>>;\nexport function toLookup<\n  T1 extends {},\n  T2 extends {},\n  T3 extends {},\n  T4 extends {},\n>(\n  obj1: T1,\n  obj2: T2,\n  obj3: T3,\n  obj4: T4,\n): Readonly<T1 & T2 & T3 & T4>;\nexport function toLookup<\n  T1 extends {},\n  T2 extends {},\n  T3 extends {},\n  T4 extends {},\n  T5 extends {},\n>(\n  obj1: T1,\n  obj2: T2,\n  obj3: T3,\n  obj4: T4,\n  obj5: T5,\n): Readonly<T1 & T2 & T3 & T4 & T5>;\n/** @internal */\nexport function toLookup(...objs: {}[]): Readonly<{}> {\n  return objectAssign(createLookup(), ...objs);\n}\n\n/**\n * Determine whether the value is a native function.\n *\n * @param fn - The function to check.\n * @returns `true` is the function is a native function, otherwise `false`\n */\nexport const isNativeFunction = /*@__PURE__*/(() => {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  const lookup: WeakMap<Function, boolean> = new WeakMap();\n  let isNative = false as boolean | undefined;\n  let sourceText = '';\n  let i = 0;\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  return (fn: Function) => {\n    isNative = lookup.get(fn);\n    if (isNative == null) {\n      i = (sourceText = fn.toString()).length;\n      isNative = i > 28 && sourceText.indexOf('[native code] }') === i - 15;\n      lookup.set(fn, isNative);\n    }\n    return isNative;\n  };\n})();\n\n/**\n * Normalize a potential promise via a callback, to ensure things stay synchronous when they can.\n *\n * If the value is a promise, it is `then`ed before the callback is invoked. Otherwise the callback is invoked synchronously.\n */\nexport const onResolve: {\n  // used for async code paths\n  <TValue, TRet>(\n    maybePromise: Promise<TValue>,\n    resolveCallback: (value: TValue) => MaybePromise<TRet>,\n  ): Promise<TRet>;\n\n  // used for express synchronous only code paths\n  <TValue, TRet>(\n    maybePromise: TValue extends Promise<unknown> ? never : TValue,\n    resolveCallback: (value: TValue) => TRet,\n  ): TRet extends Promise<infer R> ? Promise<R> : TRet;\n\n  // used for mixed code paths\n  <TValue, TRet>(\n    maybePromise: MaybePromise<TValue>,\n    resolveCallback: (value: TValue) => MaybePromise<TRet>,\n  ): MaybePromise<TRet>;\n\n}\n// implementation\n= (maybePromise, resolveCallback) => {\n  if (isPromise(maybePromise)) {\n    return maybePromise.then(resolveCallback);\n  }\n  return resolveCallback(maybePromise);\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction testOnResolve() {\n  /* eslint-disable @typescript-eslint/no-floating-promises, @typescript-eslint/ban-ts-comment */\n  onResolve(Promise.resolve(1), (value) => value === 1);\n  onResolve(1, value => value === 1);\n\n  // @ts-expect-error\n  onResolve(1, value => value === Promise.resolve(1));\n  // @ts-expect-error\n  onResolve(Promise.resolve(1), value => value === Promise.resolve(1));\n\n  const ret = onResolve(Promise.resolve(1), (value) => value === 1);\n  // @ts-expect-error\n  if (ret === false) {\n    // nothing\n  }\n\n  // @ts-expect-error\n  const ret2 = onResolve(1, value => value === Promise.resolve(1));\n  if (ret2 === false) {\n    // nothing\n  }\n\n  type Component = {\n    canDeactivate?: () => boolean | Promise<boolean>;\n  };\n\n  const cmp: Component = {};\n  onResolve(\n    cmp.canDeactivate?.(),\n    canDeactivate => {\n    if (canDeactivate === false) {\n      // nothing\n    }\n  });\n\n  /* eslint-enable @typescript-eslint/no-floating-promises, @typescript-eslint/ban-ts-comment */\n}\n\n/**\n * Normalize an array of potential promises, to ensure things stay synchronous when they can.\n *\n * If exactly one value is a promise, then that promise is returned.\n *\n * If more than one value is a promise, a new `Promise.all` is returned.\n *\n * If none of the values is a promise, nothing is returned, to indicate that things can stay synchronous.\n */\nexport const onResolveAll = (...maybePromises: unknown[]): void | Promise<void> => {\n  let maybePromise: unknown = void 0;\n  let firstPromise: unknown = void 0;\n  let promises: unknown[] | undefined = void 0;\n  let i = 0;\n  // eslint-disable-next-line\n  let ii = maybePromises.length;\n  for (; i < ii; ++i) {\n    maybePromise = maybePromises[i];\n    if (isPromise(maybePromise = maybePromises[i])) {\n      if (firstPromise === void 0) {\n        firstPromise = maybePromise;\n      } else if (promises === void 0) {\n        promises = [firstPromise, maybePromise];\n      } else {\n        promises.push(maybePromise);\n      }\n    }\n  }\n\n  if (promises === void 0) {\n    return firstPromise as void | Promise<void>;\n  }\n  return Promise.all(promises) as unknown as Promise<void>;\n};\n", "import {\n  type Key,\n  IRegistration,\n  Resolver,\n  ResolverStrategy,\n  type ResolveCallback,\n  type Resolved,\n  type IRegistry,\n  type IContainer,\n  IResolver,\n  ParameterizedRegistry,\n  InterfaceSymbol,\n} from './di';\nimport { Constructable } from './interfaces';\n\n/** @internal */\nexport const instanceRegistration = <T>(key: Key, value: T): IRegistration<T> =>\n  new Resolver(key, ResolverStrategy.instance, value);\n\n/** @internal */\nexport const singletonRegistration = <T extends Constructable>(key: Key, value: T): IRegistration<InstanceType<T>> =>\n  new Resolver(key, ResolverStrategy.singleton, value);\n\n/** @internal */\nexport const transientRegistation = <T extends Constructable>(key: Key, value: T): IRegistration<InstanceType<T>> =>\n  new Resolver(key, ResolverStrategy.transient, value);\n\n/** @internal */\nexport const callbackRegistration = <T>(key: Key, callback: ResolveCallback<T>): IRegistration<Resolved<T>> =>\n  new Resolver(key, ResolverStrategy.callback, callback);\n\n/** @internal */\nexport const cachedCallbackRegistration = <T>(key: Key, callback: ResolveCallback<T>): IRegistration<Resolved<T>> =>\n  new Resolver(key, ResolverStrategy.callback, cacheCallbackResult(callback));\n\n/** @internal */\nexport const aliasToRegistration = <T>(originalKey: T, aliasKey: Key): IRegistration<Resolved<T>> =>\n  new Resolver(aliasKey, ResolverStrategy.alias, originalKey);\n\n/** @internal */\nexport const deferRegistration = (key: Key, ...params: unknown[]): IRegistry =>\n  new ParameterizedRegistry(key, params);\n\ntype ResolverLookup = WeakMap<IResolver, unknown>;\nconst containerLookup = new WeakMap<IContainer, ResolverLookup>();\n\n/** @internal */\nexport const cacheCallbackResult = <T>(fun: ResolveCallback<T>): ResolveCallback<T> => {\n  return (handler: IContainer, requestor: IContainer, resolver: IResolver): T => {\n    let resolverLookup = containerLookup.get(handler);\n    if (resolverLookup === void 0) {\n      containerLookup.set(handler, resolverLookup = new WeakMap());\n    }\n    if (resolverLookup.has(resolver)) {\n      return resolverLookup.get(resolver) as T;\n    }\n    const t = fun(handler, requestor, resolver);\n    resolverLookup.set(resolver, t);\n    return t;\n  };\n};\n\n/**\n * you can use the resulting {@linkcode IRegistration} of any of the factory methods\n * to register with the container, e.g.\n * ```\n * class Foo {}\n * const container = DI.createContainer();\n * container.register(Registration.instance(Foo, new Foo()));\n * container.get(Foo);\n * ```\n */\nexport const Registration = {\n  /**\n   * allows you to pass an instance.\n   * Every time you request this {@linkcode Key} you will get this instance back.\n   * ```\n   * Registration.instance(Foo, new Foo()));\n   * ```\n   *\n   * @param key - key to register the instance with\n   * @param value - the instance associated with the key\n   */\n  instance: instanceRegistration,\n  /**\n   * Creates an instance from the class.\n   * Every time you request this {@linkcode Key} you will get the same one back.\n   * ```\n   * Registration.singleton(Foo, Foo);\n   * ```\n   *\n   * @param key - key to register the singleton class with\n   * @param value - the singleton class to instantiate when a container resolves the associated key\n   */\n  singleton: singletonRegistration,\n  /**\n   * Creates an instance from a class.\n   * Every time you request this {@linkcode Key} you will get a new instance.\n   * ```\n   * Registration.instance(Foo, Foo);\n   * ```\n   *\n   * @param key - key to register the transient class with\n   * @param value - the class to instantiate when a container resolves the associated key\n   */\n  transient: transientRegistation,\n  /**\n   * Creates an instance from the method passed.\n   * Every time you request this {@linkcode Key} you will get a new instance.\n   * ```\n   * Registration.callback(Foo, () => new Foo());\n   * Registration.callback(Bar, (c: IContainer) => new Bar(c.get(Foo)));\n   * ```\n   *\n   * @param key - key to register the callback with\n   * @param callback - the callback to invoke when a container resolves the associated key\n   */\n  callback: callbackRegistration,\n  /**\n   * Creates an instance from the method passed.\n   * On the first request for the {@linkcode Key} your callback is called and returns an instance.\n   * subsequent requests for the {@linkcode Key}, the initial instance returned will be returned.\n   * If you pass the same {@linkcode Registration} to another container the same cached value will be used.\n   * Should all references to the resolver returned be removed, the cache will expire.\n   * ```\n   * Registration.cachedCallback(Foo, () => new Foo());\n   * Registration.cachedCallback(Bar, (c: IContainer) => new Bar(c.get(Foo)));\n   * ```\n   *\n   * @param key - key to register the cached callback with\n   * @param callback - the cache callback to invoke when a container resolves the associated key\n   */\n  cachedCallback: cachedCallbackRegistration,\n  /**\n   * creates an alternate {@linkcode Key} to retrieve an instance by.\n   * Returns the same scope as the original {@linkcode Key}.\n   * ```\n   * Register.singleton(Foo, Foo)\n   * Register.aliasTo(Foo, MyFoos);\n   *\n   * container.getAll(MyFoos) // contains an instance of Foo\n   * ```\n   *\n   * @param originalKey - the real key to resolve the get call from a container\n   * @param aliasKey - the key that a container allows to resolve the real key associated\n   */\n  aliasTo: aliasToRegistration,\n  /**\n   * @internal\n   * @param key - the key to register a defer registration\n   * @param params - the parameters that should be passed to the resolution of the key\n   */\n  defer: deferRegistration,\n};\n\nexport const createImplementationRegister = function<T extends Key>(key: InterfaceSymbol<T>) {\n  return function register<C extends Constructable>(this: C, container: IContainer) {\n    container.register(\n      singletonRegistration(this, this),\n      aliasToRegistration(this, key),\n    );\n  };\n};\n", "import { IContainer } from './di';\nimport { Constructable } from './interfaces';\nimport { defineMetadata, getMetadata, objectFreeze } from './utilities';\n\nexport type StaticResourceType<TDef extends object = object> = {\n  readonly aliases?: string[];\n  readonly $au?: PartialResourceDefinition<{\n    type: string;\n  } & TDef>;\n};\n\nexport type ResourceType<\n  TUserType extends Constructable = Constructable,\n  TResInstance extends {} = {},\n  TResType extends {} = {},\n  TUserInstance extends InstanceType<TUserType> = InstanceType<TUserType>,\n> = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  new (...args: any[]) => TResInstance & TUserInstance\n) & StaticResourceType & TResType & TUserType;\n\nexport type ResourceDefinition<\n  TUserType extends Constructable = Constructable,\n  TResInstance extends {} = {},\n  TDef extends {} = {},\n  TResType extends {} = {},\n  TUserInstance extends InstanceType<TUserType> = InstanceType<TUserType>,\n> = {\n  /**\n   * Unique key to identify the resource.\n   */\n  readonly key: string;\n  /**\n   * A common name for the resource.\n   */\n  readonly name: string;\n  readonly Type: ResourceType<TUserType, TResInstance, TResType, TUserInstance>;\n  readonly aliases?: readonly string[];\n\n  /**\n   * @param aliasName - If provided, the resource will be registered with this alias key.\n   */\n  register(container: IContainer, aliasName?: string): void;\n} & TDef;\n\nexport type PartialResourceDefinition<TDef extends object = object> = {\n  readonly name: string;\n  readonly aliases?: readonly string[];\n} & TDef;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface IResourceKind<TType extends ResourceType, TDef extends ResourceDefinition> {\n  readonly name: string;\n  keyFrom(name: string): string;\n}\n\nconst annoBaseName = 'au:annotation';\n/** @internal */\nexport const getAnnotationKeyFor = (name: string, context?: string): string => {\n  if (context === void 0) {\n    return `${annoBaseName}:${name}`;\n  }\n\n  return `${annoBaseName}:${name}:${context}`;\n};\n/** @internal */\nexport const appendAnnotation = (target: Constructable, key: string): void => {\n  const keys = getMetadata<string[]>(annoBaseName, target);\n  if (keys === void 0) {\n    defineMetadata([key], target, annoBaseName);\n  } else {\n    keys.push(key);\n  }\n};\n\nconst annotation = /*@__PURE__*/ objectFreeze({\n  name: 'au:annotation',\n  appendTo: appendAnnotation,\n  set(target: Constructable, prop: string, value: unknown): void {\n    defineMetadata(value, target, getAnnotationKeyFor(prop));\n  },\n  get: (target: Constructable, prop: string): unknown => getMetadata(getAnnotationKeyFor(prop), target),\n  getKeys(target: Constructable): readonly string[] {\n    let keys = getMetadata<string[]>(annoBaseName, target);\n    if (keys === void 0) {\n      defineMetadata(keys = [], target, annoBaseName);\n    }\n    return keys;\n  },\n  isKey: (key: string): boolean  => key.startsWith(annoBaseName),\n  keyFor: getAnnotationKeyFor,\n});\n\nexport const resourceBaseName = 'au:resource';\n/**\n * Builds a resource key from the provided parts.\n */\nexport const getResourceKeyFor = (type: string, name?: string, context?: string): string => {\n  if (name == null) {\n    return `${resourceBaseName}:${type}`;\n  }\n  if (context == null) {\n    return `${resourceBaseName}:${type}:${name}`;\n  }\n\n  return `${resourceBaseName}:${type}:${name}:${context}`;\n};\n\nexport const Protocol = {\n  annotation,\n};\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n/**\n * The order in which the values are checked:\n * 1. Annotations (usually set by decorators) have the highest priority; they override the definition as well as static properties on the type.\n * 2. Definition properties (usually set by the customElement decorator object literal) come next. They override static properties on the type.\n * 3. Static properties on the type come last. Note that this does not look up the prototype chain (bindables are an exception here, but we do that differently anyway)\n * 4. The default property that is provided last. The function is only called if the default property is needed\n */\nexport function fromAnnotationOrDefinitionOrTypeOrDefault<\n  TDef extends PartialResourceDefinition,\n  K extends keyof TDef,\n>(\n  name: K,\n  def: TDef,\n  Type: Constructable,\n  getDefault: () => Required<TDef>[K],\n): Required<TDef>[K] {\n  let value = getMetadata<TDef[K] | undefined>(getAnnotationKeyFor(name as string), Type);\n  if (value === void 0) {\n    value = def[name];\n    if (value === void 0) {\n      value = (Type as Constructable & TDef)[name] as TDef[K] | undefined;\n      if (value === void 0 || !hasOwn.call(Type, name)) { // First just check the value (common case is faster), but do make sure it doesn't come from the proto chain\n        return getDefault();\n      }\n      return value;\n    }\n    return value;\n  }\n  return value;\n}\n\n/**\n * The order in which the values are checked:\n * 1. Annotations (usually set by decorators) have the highest priority; they override static properties on the type.\n * 2. Static properties on the typ. Note that this does not look up the prototype chain (bindables are an exception here, but we do that differently anyway)\n * 3. The default property that is provided last. The function is only called if the default property is needed\n */\nexport function fromAnnotationOrTypeOrDefault<T, K extends keyof T, V>(\n  name: K,\n  Type: T,\n  getDefault: () => V,\n): V {\n  let value = getMetadata<V>(getAnnotationKeyFor(name as string), Type);\n  if (value === void 0) {\n    value = Type[name] as unknown as V;\n    if (value === void 0 || !hasOwn.call(Type, name)) { // First just check the value (common case is faster), but do make sure it doesn't come from the proto chain\n      return getDefault();\n    }\n    return value;\n  }\n  return value;\n}\n\n/**\n * The order in which the values are checked:\n * 1. Definition properties.\n * 2. The default property that is provided last. The function is only called if the default property is needed\n */\nexport function fromDefinitionOrDefault<\n  TDef extends PartialResourceDefinition,\n  K extends keyof TDef,\n>(\n  name: K,\n  def: TDef,\n  getDefault: () => Required<TDef>[K],\n): Required<TDef>[K] {\n  const value = def[name];\n  if (value === void 0) {\n    return getDefault();\n  }\n  return value;\n}\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable @typescript-eslint/strict-boolean-expressions, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */\nimport {\n  IContainer,\n  InterfaceSymbol,\n  Resolver,\n  ResolverStrategy,\n  getDependencies,\n  type IContainerConfiguration,\n  type IFactory,\n  type IRegistry,\n  type IResolver,\n  type Key,\n  type RegisterSelf,\n  type Resolved,\n  type Transformer,\n  IDisposableResolver,\n} from './di';\nimport { aliasToRegistration, singletonRegistration } from './di.registration';\nimport type {\n  IAllResolver,\n  IFactoryResolver,\n  ILazyResolver,\n  INewInstanceResolver,\n  IOptionalResolver,\n  IResolvedFactory,\n  IResolvedLazy,\n} from './di.resolvers';\nimport { ErrorNames, createMappedError, logError } from './errors';\nimport { isNativeFunction } from './functions';\nimport { type Class, type Constructable } from './interfaces';\nimport { emptyArray } from './platform';\nimport { ResourceDefinition, StaticResourceType, resourceBaseName, type ResourceType } from './resource';\nimport { getMetadata, isFunction, isObjectOrFunction, isString } from './utilities';\n\nexport const registrableMetadataKey = Symbol.for('au:registrable');\nexport const DefaultResolver = {\n  none(key: Key): IResolver {\n    throw createMappedError(ErrorNames.none_resolver_found, key);\n  },\n  singleton: (key: Key): IResolver => new Resolver(key, ResolverStrategy.singleton, key),\n  transient: (key: Key): IResolver => new Resolver(key, ResolverStrategy.transient, key),\n};\n\nexport class ContainerConfiguration implements IContainerConfiguration {\n  public static readonly DEFAULT: ContainerConfiguration = ContainerConfiguration.from({});\n\n  private constructor(\n    public readonly inheritParentResources: boolean,\n    public readonly defaultResolver: (\n      key: Key,\n      handler: IContainer\n    ) => IResolver\n  ) {}\n\n  public static from(config?: IContainerConfiguration): ContainerConfiguration {\n    if (\n      config === void 0 ||\n      config === ContainerConfiguration.DEFAULT\n    ) {\n      return ContainerConfiguration.DEFAULT;\n    }\n    return new ContainerConfiguration(\n      config.inheritParentResources ?? false,\n      config.defaultResolver ?? DefaultResolver.singleton,\n    );\n  }\n}\n\n/** @internal */\nexport const createContainer = (config?: Partial<IContainerConfiguration>): IContainer => new Container(null, ContainerConfiguration.from(config));\n\nconst InstrinsicTypeNames = new Set<string>('Array ArrayBuffer Boolean DataView Date Error EvalError Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Number Object Promise RangeError ReferenceError RegExp Set SharedArrayBuffer String SyntaxError TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array URIError WeakMap WeakSet'.split(' '));\n// const factoryKey = 'di:factory';\n// const factoryAnnotationKey = Protocol.annotation.keyFor(factoryKey);\nlet containerId = 0;\n\nlet currentContainer: IContainer | null = null;\n\n/** @internal */\nexport class Container implements IContainer {\n  public readonly id: number = ++containerId;\n  /** @internal */\n  private _registerDepth: number = 0;\n\n  public get depth(): number {\n    return this._parent === null ? 0 : this._parent.depth + 1;\n  }\n  public readonly root: Container;\n\n  /**\n   * All own resolvers of this container\n   *\n   * @internal\n   */\n  private readonly _resolvers: Map<Key, IResolver>;\n  /**\n   * A map of Factory per Constructor (Type) of this container tree.\n   *\n   * Factories are \"global\" per container tree\n   *\n   * @internal\n   */\n  private readonly _factories: Map<Constructable, Factory>;\n\n  /**\n   * A map of all resources resolver by their key\n   */\n  private res: Record<string, IResolver | undefined>;\n\n  /** @internal */\n  private readonly _disposableResolvers = new Map<Key, IResolver>();\n\n  public get parent(): IContainer | null {\n    return this._parent as (IContainer | null);\n  }\n\n  /** @internal */\n  private readonly _parent: Container | null;\n  /** @internal */\n  private readonly config: ContainerConfiguration;\n\n  public constructor(\n    parent: Container | null,\n    config: ContainerConfiguration\n  ) {\n    this._parent = parent;\n    this.config = config;\n    this._resolvers = new Map();\n    this.res = {};\n\n    if (parent === null) {\n      this.root = this;\n      this._factories = new Map<Constructable, Factory>();\n    } else {\n      this.root = parent.root;\n      this._factories = parent._factories;\n\n      if (config.inheritParentResources) {\n        // todo: when the simplify resource system work is commenced\n        //       this resource inheritance can just be a Object.create() call\n        //       with parent resources as the prototype of the child resources\n        for (const key in parent.res) {\n          this.registerResolver(key, parent.res[key]!);\n        }\n      }\n    }\n\n    this._resolvers.set(IContainer, containerResolver);\n  }\n\n  public register(...params: any[]): IContainer {\n    if (++this._registerDepth === 100) {\n      throw createMappedError(ErrorNames.unable_auto_register, ...params);\n    }\n    let current: IRegistry | Record<string, IRegistry>;\n    let keys: string[];\n    let value: IRegistry;\n    let j: number;\n    let jj: number;\n    let i = 0;\n    // eslint-disable-next-line\n    let ii = params.length;\n    let def: ResourceDefinition;\n\n    for (; i < ii; ++i) {\n      current = params[i];\n      if (!isObjectOrFunction(current)) {\n        continue;\n      }\n      if (isRegistry(current)) {\n        current.register(this);\n      } else if ((def = getMetadata(resourceBaseName, current)!) != null) {\n        def.register(this);\n      } else if (isClass<StaticResourceType>(current)) {\n        const registrable = current[Symbol.metadata]?.[registrableMetadataKey] as IRegistry;\n        if (isRegistry(registrable)) {\n          registrable.register(this);\n        } else if (isString((current).$au?.type)) {\n          const $au = current.$au;\n          const aliases = (current.aliases ?? emptyArray).concat($au.aliases ?? emptyArray);\n          let key = `${resourceBaseName}:${$au.type}:${$au.name}`;\n          if (this.has(key, false)) {\n            if (__DEV__) {\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n              (globalThis as any).console?.warn(createMappedError(ErrorNames.resource_already_exists, key));\n            }\n            continue;\n          }\n          aliasToRegistration(current, key).register(this);\n          if (!this.has(current, false)) {\n            singletonRegistration(current, current).register(this);\n          }\n          j = 0;\n          jj = aliases.length;\n          for (; j < jj; ++j) {\n            key = `${resourceBaseName}:${$au.type}:${aliases[j]}`;\n            if (this.has(key, false)) {\n              if (__DEV__) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n                (globalThis as any).console?.warn(createMappedError(ErrorNames.resource_already_exists, key));\n              }\n              continue;\n            }\n            aliasToRegistration(current, key).register(this);\n          }\n        } else {\n          singletonRegistration(current, current as Constructable).register(this);\n        }\n      } else {\n        keys = Object.keys(current);\n        j = 0;\n        jj = keys.length;\n        for (; j < jj; ++j) {\n          value = current[keys[j]];\n          if (!isObjectOrFunction(value)) {\n            continue;\n          }\n          // note: we could remove this if-branch and call this.register directly\n          // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator\n          if (isRegistry(value)) {\n            value.register(this);\n          } else {\n            this.register(value);\n          }\n        }\n      }\n    }\n    --this._registerDepth;\n    return this;\n  }\n\n  public registerResolver<K extends Key, T extends IResolver<K>>(key: K, resolver: T, isDisposable: boolean = false): T {\n    validateKey(key);\n\n    const resolvers = this._resolvers;\n    const result = resolvers.get(key);\n\n    if (result == null) {\n      resolvers.set(key, resolver);\n      if (isResourceKey(key)) {\n        if (this.res[key] !== void 0) {\n          throw createMappedError(ErrorNames.resource_already_exists, key);\n        }\n        this.res[key] = resolver;\n      }\n    } else if (result instanceof Resolver && result._strategy === ResolverStrategy.array) {\n      (result._state as IResolver[]).push(resolver);\n    } else {\n      resolvers.set(key, new Resolver(key, ResolverStrategy.array, [result, resolver]) as IResolver<K>);\n    }\n\n    if (isDisposable) {\n      this._disposableResolvers.set(key, resolver);\n    }\n\n    return resolver;\n  }\n\n  public deregister(key: Key): void {\n    validateKey(key);\n\n    const resolver = this._resolvers.get(key);\n    if (resolver != null) {\n      this._resolvers.delete(key);\n\n      if (isResourceKey(key)) {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete this.res[key];\n      }\n\n      if (this._disposableResolvers.has(key)) {\n        (resolver as IDisposableResolver).dispose();\n        this._disposableResolvers.delete(key);\n      }\n    }\n  }\n\n  // public deregisterResolverFor<K extends Key>(key: K, searchAncestors: boolean): void {\n  //   validateKey(key);\n  //   // eslint-disable-next-line @typescript-eslint/no-this-alias\n  //   let current: Container | null = this;\n  //   let resolver: IResolver | undefined;\n  //   while (current != null) {\n  //     resolver = current._resolvers.get(key);\n  //     if (resolver != null) {\n  //       current._resolvers.delete(key);\n  //       break;\n  //     }\n  //     if (current.parent == null) { return; }\n  //     current = searchAncestors ? current.parent : null;\n  //   }\n  //   if (resolver == null) { return; }\n  //   if (resolver instanceof Resolver && resolver.strategy === ResolverStrategy.array) {\n  //     throw createError('Cannot deregister a resolver with array strategy');\n  //   }\n  //   if (this._disposableResolvers.has(resolver as IDisposableResolver<K>)) {\n  //     (resolver as IDisposableResolver<K>).dispose();\n  //   }\n  //   if (isResourceKey(key)) {\n  //     // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n  //     delete this.res[key];\n  //   }\n  // }\n  public registerTransformer<K extends Key, T = K>(key: K, transformer: Transformer<T>): boolean {\n    const resolver = this.getResolver(key);\n\n    if (resolver == null) {\n      return false;\n    }\n\n    if (resolver.getFactory) {\n      const factory = resolver.getFactory(this);\n\n      if (factory == null) {\n        return false;\n      }\n\n      // This type cast is a bit of a hacky one, necessary due to the duplicity of IResolverLike.\n      // Problem is that that interface's type arg can be of type Key, but the getFactory method only works on\n      // type Constructable. So the return type of that optional method has this additional constraint, which\n      // seems to confuse the type checker.\n      factory.registerTransformer(\n        transformer as unknown as Transformer<Constructable>\n      );\n      return true;\n    }\n\n    return false;\n  }\n\n  public getResolver<K extends Key, T = K>(key: K | Key, autoRegister: boolean = true): IResolver<T> | null {\n    validateKey(key);\n\n    if ((key as unknown as IResolver).resolve !== void 0) {\n      return key as unknown as IResolver;\n    }\n\n    const previousContainer = currentContainer;\n    let current: Container = currentContainer = this;\n    let resolver: IResolver | undefined;\n    let handler: Container;\n\n    try {\n      while (current != null) {\n        resolver = current._resolvers.get(key);\n\n        if (resolver == null) {\n          if (current._parent == null) {\n            handler = (isRegisterInRequester(key as unknown as RegisterSelf<Constructable>)) ? this : current;\n            if (autoRegister) {\n              return this._jitRegister(key, handler);\n            }\n            return null;\n          }\n\n          current = current._parent;\n        } else {\n          return resolver;\n        }\n      }\n    } finally {\n      currentContainer = previousContainer;\n    }\n\n    return null;\n  }\n\n  public has<K extends Key>(key: K, searchAncestors: boolean = false): boolean {\n    return this._resolvers.has(key)\n      || isResourceKey(key) && key in this.res\n      || ((searchAncestors && this._parent?.has(key, true)) ?? false);\n  }\n\n  public get<K extends Key>(key: K): Resolved<K> {\n    validateKey(key);\n\n    if ((key as IResolver).$isResolver) {\n      return (key as IResolver).resolve(this, this);\n    }\n\n    const previousContainer = currentContainer;\n    let current: Container = currentContainer = this;\n    let resolver: IResolver | undefined;\n    let handler: Container;\n    try {\n      while (current != null) {\n        resolver = current._resolvers.get(key);\n\n        if (resolver == null) {\n          if (current._parent == null) {\n            handler = (isRegisterInRequester(key as unknown as RegisterSelf<Constructable>)) ? this : current;\n            resolver = this._jitRegister(key, handler);\n            return resolver.resolve(current, this);\n          }\n          current = current._parent;\n        } else {\n          return resolver.resolve(current, this);\n        }\n      }\n    } finally {\n      currentContainer = previousContainer;\n    }\n\n    throw createMappedError(ErrorNames.unable_resolve_key, key);\n  }\n\n  public getAll<K extends Key>(key: K, searchAncestors: boolean = false): Resolved<K>[] {\n    validateKey(key);\n\n    const previousContainer = currentContainer;\n    const requestor = currentContainer = this;\n    let current: Container | null = requestor;\n    let resolver: IResolver | undefined;\n    let resolutions: Resolved<K>[] = emptyArray;\n\n    try {\n      if (searchAncestors) {\n        while (current != null) {\n          resolver = current._resolvers.get(key);\n          if (resolver != null) {\n            resolutions = resolutions.concat(buildAllResponse(resolver, current, requestor));\n          }\n          current = current._parent;\n        }\n        return resolutions;\n      }\n\n      while (current != null) {\n        resolver = current._resolvers.get(key);\n\n        if (resolver == null) {\n          current = current._parent;\n\n          if (current == null) {\n            return emptyArray;\n          }\n        } else {\n          return buildAllResponse(resolver, current, requestor);\n        }\n      }\n    } finally {\n      currentContainer = previousContainer;\n    }\n\n    return emptyArray;\n  }\n\n  public invoke<T extends {}, TDeps extends unknown[] = unknown[]>(Type: Constructable<T>, dynamicDependencies?: TDeps): T {\n    if (isNativeFunction(Type)) {\n      throw createMappedError(ErrorNames.no_construct_native_fn, Type);\n    }\n    const previousContainer = currentContainer;\n    currentContainer = this;\n    if (__DEV__) {\n      let resolvedDeps: unknown[];\n      let dep: Key | undefined;\n\n      try {\n        resolvedDeps = getDependencies(Type).map(_ => this.get(dep = _));\n      } catch (ex) {\n        logError(`[DEV:aurelia] Error during construction of ${!Type.name ? `(Anonymous) ${String(Type)}` : Type.name}, caused by dependency: ${String(dep)}`);\n        currentContainer = previousContainer;\n        throw ex;\n      }\n\n      try {\n        return dynamicDependencies === void 0\n          ? new Type(...resolvedDeps)\n          : new Type(...resolvedDeps, ...dynamicDependencies);\n      } catch (ex) {\n        logError(`[DEV:aurelia] Error during construction of ${!Type.name ? `(Anonymous) ${String(Type)}` : Type.name}`);\n        throw ex;\n      } finally {\n        currentContainer = previousContainer;\n      }\n    }\n    try {\n      return dynamicDependencies === void 0\n        ? new Type(...getDependencies(Type).map(containerGetKey, this))\n        : new Type(...getDependencies(Type).map(containerGetKey, this), ...dynamicDependencies);\n    } finally {\n      currentContainer = previousContainer;\n    }\n  }\n\n  public hasFactory<T extends Constructable>(key: T): boolean {\n    return this._factories.has(key);\n  }\n\n  public getFactory<K extends Constructable>(Type: K): IFactory<K> {\n    let factory = this._factories.get(Type);\n    if (factory === void 0) {\n      if (isNativeFunction(Type)) {\n        throw createMappedError(ErrorNames.no_construct_native_fn, Type);\n      }\n      this._factories.set(Type, factory = new Factory<K>(Type, getDependencies(Type)));\n    }\n    return factory;\n  }\n\n  public registerFactory<K extends Constructable>(key: K, factory: IFactory<K>): void {\n    this._factories.set(key, factory as Factory);\n  }\n\n  public createChild(config?: Partial<IContainerConfiguration>): IContainer {\n    if (config === void 0 && this.config.inheritParentResources) {\n      if (this.config === ContainerConfiguration.DEFAULT) {\n        return new Container(this, this.config);\n      }\n      return new Container(\n        this,\n        ContainerConfiguration.from({\n          ...this.config,\n          inheritParentResources: false,\n        })\n      );\n    }\n    return new Container(this, ContainerConfiguration.from(config ?? this.config));\n  }\n\n  public disposeResolvers(): void {\n    const resolvers = this._resolvers;\n    const disposableResolvers = this._disposableResolvers;\n\n    let disposable: IResolver;\n    let key: Key;\n\n    for ([key, disposable] of disposableResolvers.entries()) {\n      disposable.dispose?.();\n      resolvers.delete(key);\n    }\n    disposableResolvers.clear();\n  }\n\n  public useResources(container: Container): void {\n    const res = container.res;\n    for (const key in res) {\n      this.registerResolver(key, res[key]!);\n    }\n  }\n\n  public find<TResType extends ResourceType>(kind: string, name: string): TResType | null;\n  public find<TResType extends ResourceType>(key: string): TResType | null;\n  public find<TResType extends ResourceType>(keyOrKind: string, name?: string): TResType | null {\n    const key = isString(name) ? `${resourceBaseName}:${keyOrKind}:${name}` : keyOrKind;\n    let container: Container = this;\n    let resolver = container.res[key];\n    if (resolver == null) {\n      container = container.root;\n      resolver = container.res[key];\n    }\n    if (resolver == null) {\n      return null;\n    }\n    return resolver.getFactory?.(container)?.Type as TResType ?? null;\n  }\n\n  public dispose(): void {\n    if (this._disposableResolvers.size > 0) {\n      this.disposeResolvers();\n    }\n    this._resolvers.clear();\n    if (this.root === this) {\n      this._factories.clear();\n      this.res = {};\n    }\n  }\n\n  /** @internal */\n  private _jitRegister(keyAsValue: any, handler: Container): IResolver {\n    const $isRegistry = isRegistry(keyAsValue);\n    if (!isFunction(keyAsValue) && !$isRegistry) {\n      throw createMappedError(ErrorNames.unable_jit_non_constructor, keyAsValue);\n    }\n\n    if (InstrinsicTypeNames.has(keyAsValue.name)) {\n      throw createMappedError(ErrorNames.no_jit_intrinsic_type, keyAsValue);\n    }\n\n    if ($isRegistry) {\n      const registrationResolver = keyAsValue.register(handler, keyAsValue);\n      if (!(registrationResolver instanceof Object) || (registrationResolver as IResolver).resolve == null) {\n        const newResolver = handler._resolvers.get(keyAsValue);\n        if (newResolver != null) {\n          return newResolver;\n        }\n        throw createMappedError(ErrorNames.null_resolver_from_register, keyAsValue);\n      }\n      return registrationResolver as IResolver;\n    }\n\n    // TODO(sayan): remove potential dead code\n    if (keyAsValue.$isInterface) {\n      throw createMappedError(ErrorNames.no_jit_interface, keyAsValue.friendlyName);\n    }\n\n    const resolver = this.config.defaultResolver(keyAsValue, handler);\n    handler._resolvers.set(keyAsValue, resolver);\n    return resolver;\n  }\n}\n\n/** @internal */\nclass Factory<T extends Constructable = any> implements IFactory<T> {\n  private transformers: ((instance: any) => any)[] | null = null;\n  public constructor(\n    public Type: T,\n    private readonly dependencies: Key[],\n  ) { }\n\n  public construct(container: IContainer, dynamicDependencies?: unknown[]): Resolved<T> {\n    const previousContainer = currentContainer;\n    currentContainer = container;\n    let instance: Resolved<T>;\n    /* istanbul ignore next */\n    if (__DEV__) {\n      let resolvedDeps: unknown[];\n      let dep: Key | undefined;\n      try {\n        resolvedDeps = this.dependencies.map(_ => container.get(dep = _));\n      } catch (ex) {\n        logError(`[DEV:aurelia] Error during construction of ${!this.Type.name ? `(Anonymous) ${String(this.Type)}` : this.Type.name}, caused by dependency: ${String(dep)}`);\n        currentContainer = previousContainer;\n        throw ex;\n      }\n\n      try {\n        if (dynamicDependencies === void 0) {\n          instance = new this.Type(...resolvedDeps) as Resolved<T>;\n        } else {\n          instance = new this.Type(...resolvedDeps, ...dynamicDependencies) as Resolved<T>;\n        }\n\n        if (this.transformers == null) {\n          return instance;\n        }\n\n        return this.transformers.reduce(transformInstance, instance);\n      } catch (ex) {\n        logError(`[DEV:aurelia] Error during construction of ${!this.Type.name ? `(Anonymous) ${String(this.Type)}` : this.Type.name}`);\n        throw ex;\n      } finally {\n        currentContainer = previousContainer;\n      }\n    }\n    try {\n      if (dynamicDependencies === void 0) {\n        instance = new this.Type(...this.dependencies.map(containerGetKey, container)) as Resolved<T>;\n      } else {\n        instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies) as Resolved<T>;\n      }\n\n      if (this.transformers == null) {\n        return instance;\n      }\n\n      return this.transformers.reduce(transformInstance, instance);\n    } finally {\n      currentContainer = previousContainer;\n    }\n  }\n\n  public registerTransformer(transformer: (instance: any) => any): void {\n    (this.transformers ??= []).push(transformer);\n  }\n}\n\nfunction transformInstance<T>(inst: Resolved<T>, transform: (instance: any) => any) {\n  return transform(inst);\n}\n\nfunction validateKey(key: any): void {\n  if (key === null || key === void 0) {\n    throw createMappedError(ErrorNames.null_undefined_key);\n  }\n}\n\nfunction containerGetKey(this: IContainer, d: Key) {\n  return this.get(d);\n}\n\nexport type IResolvedInjection<K extends Key> =\n  K extends IAllResolver<infer R>\n    ? Resolved<R>[]\n    : K extends INewInstanceResolver<infer R>\n      ? Resolved<R>\n      : K extends ILazyResolver<infer R>\n        ? IResolvedLazy<R>\n        : K extends IOptionalResolver<infer R>\n          ? Resolved<R> | undefined\n          : K extends IFactoryResolver<infer R>\n            ? IResolvedFactory<R>\n            : K extends IResolver<infer R>\n              ? Resolved<R>\n              : K extends [infer R1 extends Key, ...infer R2]\n                ? [IResolvedInjection<R1>, ...IResolvedInjection<R2>]\n                : K extends InterfaceSymbol<infer T>\n                  ? T\n                  : Resolved<K>;\n\n/**\n * Retrieve the resolved value of a key, or values of a list of keys from the currently active container.\n *\n * Calling this without an active container will result in an error.\n */\nexport function resolve<K extends Key>(key: K): IResolvedInjection<K>;\nexport function resolve<K extends Key[]>(...keys: K): IResolvedInjection<K>;\nexport function resolve<K extends Key, A extends K[]>(...keys: A): Resolved<K> | Resolved<K>[] {\n  if (currentContainer == null) {\n    throw createMappedError(ErrorNames.no_active_container_for_resolve, ...keys);\n  }\n  /* istanbul ignore next */\n  if (__DEV__) {\n    if (keys.length === 1) {\n      try {\n        return currentContainer.get(keys[0]);\n      } catch (ex) {\n        logError(`[DEV:aurelia] resolve() call error for: ${String(keys[0])}`);\n        throw ex;\n      }\n    } else {\n      let key: Key | undefined;\n      try {\n        return keys.map(_ => currentContainer!.get(key = _));\n      } catch (ex) {\n        logError(`[DEV:aurelia] resolve() call error for: ${String(key)}`);\n        throw ex;\n      }\n    }\n  }\n  return keys.length === 1\n    ? currentContainer.get(keys[0])\n    : keys.map(containerGetKey, currentContainer);\n}\n\nconst buildAllResponse = (resolver: IResolver, handler: IContainer, requestor: IContainer): any[] => {\n  if (resolver instanceof Resolver && resolver._strategy === ResolverStrategy.array) {\n    const state = resolver._state as IResolver[];\n    const ii = state.length;\n    const results = Array(ii);\n    let i = 0;\n\n    for (; i < ii; ++i) {\n      results[i] = state[i].resolve(handler, requestor);\n    }\n\n    return results;\n  }\n\n  return [resolver.resolve(handler, requestor)];\n};\n\nconst containerResolver: IResolver = {\n  $isResolver: true,\n  resolve(handler: IContainer, requestor: IContainer): IContainer {\n    return requestor;\n  }\n};\n\nconst isRegistry = (obj: IRegistry | Record<string, IRegistry>): obj is IRegistry =>\n  isFunction(obj?.register);\n\nconst isSelfRegistry = <T extends Constructable>(obj: RegisterSelf<T>): obj is RegisterSelf<T> =>\n  isRegistry(obj) && typeof obj.registerInRequestor === 'boolean';\n\nconst isRegisterInRequester = <T extends Constructable>(obj: RegisterSelf<T>): obj is RegisterSelf<T> =>\n  isSelfRegistry(obj) && obj.registerInRequestor;\n\nconst isClass = <T>(obj: unknown): obj is Class<any, T> =>\n  (obj as { prototype: object }).prototype !== void 0;\n\nconst isResourceKey = (key: Key): key is string =>\n  isString(key) && key.indexOf(':') > 0;\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\nimport { initializeTC39Metadata } from '@aurelia/metadata';\n\nimport { isArrayIndex } from './functions';\nimport { createContainer } from './di.container';\nimport { Constructable, IDisposable } from './interfaces';\nimport { getAnnotationKeyFor, ResourceType } from './resource';\nimport { defineMetadata, getMetadata, isFunction, isString } from './utilities';\nimport { singletonRegistration, cacheCallbackResult, transientRegistation } from './di.registration';\nimport { ErrorNames, createMappedError } from './errors';\nimport type { IAllResolver, ICallableResolver, IFactoryResolver, ILazyResolver, INewInstanceResolver, IOptionalResolver, IResolvedFactory, IResolvedLazy } from './di.resolvers';\n\nexport type ResolveCallback<T = any> = (handler: IContainer, requestor: IContainer, resolver: IResolver<T>) => T;\n\nexport interface InterfaceSymbol<K = any> {\n  // We can activate decorator if the argument decorator proposal will be standardized by TC39 (https://github.com/tc39/proposal-class-method-parameter-decorators)\n  // (target: Injectable | AbstractInjectable, property: string | symbol | undefined, index?: number): void;\n  $isInterface: boolean;\n  friendlyName?: string;\n  register?(container: IContainer, key?: K): IResolver<K>;\n  toString?(): string;\n}\n\n// This interface exists only to break a circular type referencing issue in the IServiceLocator interface.\n// Otherwise IServiceLocator references IResolver, which references IContainer, which extends IServiceLocator.\ninterface IResolverLike<C, K = any> {\n  readonly $isResolver: true;\n  resolve(handler: C, requestor: C): Resolved<K>;\n  getFactory?<T extends K extends Constructable ? IFactory<K> : IFactory<Constructable>>(container: C): T | null;\n}\n\nexport interface IResolver<K = any> extends IResolverLike<IContainer, K>, Partial<IDisposable> { }\nexport interface IDisposableResolver<K = any> extends IResolver<K> {\n  dispose(): void;\n}\n\nexport interface IRegistration<K = any> extends IResolver<K> {\n  register(container: IContainer, key?: Key): IResolver<K>;\n}\n\nexport type Transformer<K> = (instance: Resolved<K>) => Resolved<K>;\n\nexport interface IFactory<T extends Constructable = any> {\n  readonly Type: T;\n  registerTransformer(transformer: Transformer<T>): void;\n  construct(container: IContainer, dynamicDependencies?: unknown[]): Resolved<T>;\n}\n\nexport interface IServiceLocator {\n  readonly root: IServiceLocator;\n  has<K extends Key>(key: K | Key, searchAncestors: boolean): boolean;\n  get<K extends Key>(key: IAllResolver<K>): Resolved<K>[];\n  get<K extends Key>(key: INewInstanceResolver<K>): Resolved<K>;\n  get<K extends Key>(key: ILazyResolver<K>): IResolvedLazy<K>;\n  get<K extends Key>(key: IOptionalResolver<K>): Resolved<K> | undefined;\n  get<K extends Key>(key: IFactoryResolver<K>): IResolvedFactory<K>;\n  get<K extends Key>(key: ICallableResolver<K>): Resolved<K>;\n  get<K extends Key>(key: IResolver<K>): Resolved<K>;\n  get<K extends Key>(key: K): Resolved<K>;\n  get<K extends Key>(key: Key): Resolved<K>;\n  get<K extends Key>(key: K | Key): Resolved<K>;\n  getAll<K extends Key>(key: K, searchAncestors?: boolean): Resolved<K>[];\n  getAll<K extends Key>(key: Key, searchAncestors?: boolean): Resolved<K>[];\n  getAll<K extends Key>(key: K | Key, searchAncestors?: boolean): Resolved<K>[];\n}\n\nexport interface IRegistry {\n  register(container: IContainer, ...params: unknown[]): void | IResolver | IContainer;\n}\n\nexport interface IContainer extends IServiceLocator, IDisposable {\n  readonly id: number;\n  readonly root: IContainer;\n  readonly parent: IContainer | null;\n  register(...params: any[]): IContainer;\n  registerResolver<K extends Key, T extends IResolver<K>>(key: K, resolver: T, isDisposable?: boolean): T;\n  // deregisterResolverFor<K extends Key>(key: K, searchAncestors: boolean): void;\n  registerTransformer<K extends Key, T = K>(key: K, transformer: Transformer<T>): boolean;\n  getResolver<K extends Key, T = K>(key: K | Key, autoRegister?: boolean): IResolver<T> | null;\n  registerFactory<T extends Constructable>(key: T, factory: IFactory<T>): void;\n  invoke<T extends {}, TDeps extends unknown[] = unknown[]>(key: Constructable<T>, dynamicDependencies?: TDeps): T;\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  hasFactory<T extends Constructable>(key: any): boolean;\n  getFactory<T extends Constructable>(key: T): IFactory<T>;\n  createChild(config?: IContainerConfiguration): IContainer;\n  disposeResolvers(): void;\n  deregister(key: Key): void;\n  /**\n   * Register resources from another container, an API for manually registering resources\n   *\n   * This is a semi private API, apps should avoid using it directly\n   */\n  useResources(container: IContainer): void;\n  find<TResType extends ResourceType>(kind: string, name: string): TResType | null;\n  find<TResType extends ResourceType>(key: string): TResType | null;\n}\n\nexport class ResolverBuilder<K> {\n  public constructor(\n    /** @internal */ private _container: IContainer,\n    /** @internal */ private _key: Key,\n  ) {}\n\n  public instance(value: K): IResolver<K> {\n    return this._registerResolver(ResolverStrategy.instance, value);\n  }\n\n  public singleton(value: Constructable): IResolver<K> {\n    return this._registerResolver(ResolverStrategy.singleton, value);\n  }\n\n  public transient(value: Constructable): IResolver<K> {\n    return this._registerResolver(ResolverStrategy.transient, value);\n  }\n\n  public callback(value: ResolveCallback<K>): IResolver<K> {\n    return this._registerResolver(ResolverStrategy.callback, value);\n  }\n\n  public cachedCallback(value: ResolveCallback<K>): IResolver<K> {\n    return this._registerResolver(ResolverStrategy.callback, cacheCallbackResult(value));\n  }\n\n  public aliasTo(destinationKey: Key): IResolver<K> {\n    return this._registerResolver(ResolverStrategy.alias, destinationKey);\n  }\n\n  /** @internal */\n  private _registerResolver(strategy: ResolverStrategy, state: unknown): IResolver<K> {\n    const { _container: container, _key: key } = this;\n    this._container = this._key = (void 0)!;\n    return container.registerResolver(key, new Resolver(key, strategy, state)) as IResolver<K>;\n  }\n}\n\nexport type RegisterSelf<T extends Constructable> = {\n  register(container: IContainer): IResolver<InstanceType<T>>;\n  registerInRequestor: boolean;\n};\n\nexport type Key = PropertyKey | object | InterfaceSymbol | Constructable | IResolver;\n\nexport type Resolved<K> = (\n  K extends InterfaceSymbol<infer T>\n    ? T\n    : K extends Constructable\n      ? InstanceType<K>\n      : K extends IResolverLike<any, infer T1>\n        ? T1 extends Constructable\n          ? InstanceType<T1>\n          : T1\n        : K\n);\n\nexport type Injectable<T = {}> = Constructable<T> & { inject?: Key[] };\nexport type AbstractInjectable<T = {}> = (abstract new (...args: any[]) => T) & { inject?: Key[] };\n\nconst cloneArrayWithPossibleProps = <T>(source: readonly T[]): T[] => {\n  const clone = source.slice();\n  const keys = Object.keys(source);\n  const len = keys.length;\n  let key: string;\n  for (let i = 0; i < len; ++i) {\n    key = keys[i];\n    if (!isArrayIndex(key)) {\n      clone[key] = source[key];\n    }\n  }\n  return clone;\n};\n\nexport interface IContainerConfiguration {\n  /**\n   * If `true`, `createChild` will inherit the resource resolvers from its parent container\n   * instead of only from the root container.\n   *\n   * Setting this flag will not implicitly perpetuate it in the child container hierarchy.\n   * It must be explicitly set on each call to `createChild`.\n   */\n  inheritParentResources?: boolean;\n  defaultResolver?(key: Key, handler: IContainer): IResolver;\n}\n\nconst diParamTypesKeys = getAnnotationKeyFor('di:paramtypes');\nconst getAnnotationParamtypes = (Type: Constructable | Injectable): readonly Key[] | undefined => {\n  return getMetadata(diParamTypesKeys, Type);\n};\n\nconst getDesignParamtypes = (Type: Constructable | Injectable): readonly Key[] | undefined =>\n  getMetadata('design:paramtypes', Type);\n\nconst getOrCreateAnnotationParamTypes = (context: DecoratorContext): Key[] => {\n  return (context.metadata[diParamTypesKeys] ??= []) as Key[];\n};\n\n/** @internal */\nexport const getDependencies = (Type: Constructable | Injectable): Key[] => {\n  // Note: Every detail of this getDependencies method is pretty deliberate at the moment, and probably not yet 100% tested from every possible angle,\n  // so be careful with making changes here as it can have a huge impact on complex end user apps.\n  // Preferably, only make changes to the dependency resolution process via a RFC.\n\n  const key = getAnnotationKeyFor('di:dependencies');\n  let dependencies = getMetadata<Key[] | undefined>(key, Type);\n  if (dependencies === void 0) {\n    // Type.length is the number of constructor parameters. If this is 0, it could mean the class has an empty constructor\n    // but it could also mean the class has no constructor at all (in which case it inherits the constructor from the prototype).\n\n    // Non-zero constructor length + no paramtypes means emitDecoratorMetadata is off, or the class has no decorator.\n    // We're not doing anything with the above right now, but it's good to keep in mind for any future issues.\n\n    const inject = (Type as Injectable).inject;\n    if (inject === void 0) {\n      // design:paramtypes is set by tsc when emitDecoratorMetadata is enabled.\n      const designParamtypes = getDesignParamtypes(Type);\n      // au:annotation:di:paramtypes is set by the parameter decorator from DI.createInterface or by @inject\n      const annotationParamtypes = getAnnotationParamtypes(Type);\n      if (designParamtypes === void 0) {\n        if (annotationParamtypes === void 0) {\n          // Only go up the prototype if neither static inject nor any of the paramtypes is defined, as\n          // there is no sound way to merge a type's deps with its prototype's deps\n          const Proto = Object.getPrototypeOf(Type);\n          if (isFunction(Proto) && Proto !== Function.prototype) {\n            dependencies = cloneArrayWithPossibleProps(getDependencies(Proto));\n          } else {\n            dependencies = [];\n          }\n        } else {\n          // No design:paramtypes so just use the au:annotation:di:paramtypes\n          dependencies = cloneArrayWithPossibleProps(annotationParamtypes);\n        }\n      } else if (annotationParamtypes === void 0) {\n        // No au:annotation:di:paramtypes so just use the design:paramtypes\n        dependencies = cloneArrayWithPossibleProps(designParamtypes);\n      } else {\n        // We've got both, so merge them (in case of conflict on same index, au:annotation:di:paramtypes take precedence)\n        dependencies = cloneArrayWithPossibleProps(designParamtypes);\n        let len = annotationParamtypes.length;\n        let auAnnotationParamtype: Key;\n        let i = 0;\n        for (; i < len; ++i) {\n          auAnnotationParamtype = annotationParamtypes[i];\n          if (auAnnotationParamtype !== void 0) {\n            dependencies[i] = auAnnotationParamtype;\n          }\n        }\n\n        const keys = Object.keys(annotationParamtypes);\n        let key: string;\n        i = 0;\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          key = keys[i];\n          if (!isArrayIndex(key)) {\n            dependencies[key] = annotationParamtypes[key];\n          }\n        }\n      }\n    } else {\n      // Ignore paramtypes if we have static inject\n      dependencies = cloneArrayWithPossibleProps(inject);\n    }\n\n    defineMetadata(dependencies, Type, key);\n  }\n\n  return dependencies;\n};\n\n/**\n * @internal\n *\n * @param configureOrName - Use for improving error messaging\n */\nexport const createInterface = <K extends Key>(configureOrName?: string | ((builder: ResolverBuilder<K>) => IResolver<K>), configuror?: (builder: ResolverBuilder<K>) => IResolver<K>): InterfaceSymbol<K> => {\n  const configure = isFunction(configureOrName) ? configureOrName : configuror;\n  const friendlyName = (isString(configureOrName) ? configureOrName : undefined) ?? '(anonymous)';\n\n  const Interface = {\n    // Old code kept with the hope that the argument decorator proposal will be standardized by TC39 (https://github.com/tc39/proposal-class-method-parameter-decorators)\n    // function(_target: Injectable | AbstractInjectable, _property: string | symbol | undefined, _index: number | undefined): void {\n    //    if (target == null || new.target !== undefined) {\n    //     throw createMappedError(ErrorNames.no_registration_for_interface, friendlyName);\n    //    }\n    //    const annotationParamtypes = getOrCreateAnnotationParamTypes(target as Injectable);\n    //    annotationParamtypes[index!] = Interface;\n    // },\n    $isInterface: true,\n    friendlyName: friendlyName,\n    toString: (): string => `InterfaceSymbol<${friendlyName}>`,\n    register: configure != null\n      ? (container: IContainer, key?: Key): IResolver<K> => configure(new ResolverBuilder(container, key ?? Interface))\n      : void 0,\n  };\n  return Interface;\n};\n\nexport const inject = (...dependencies: Key[]): (decorated: unknown, context: DecoratorContext) => void => {\n  return (decorated: unknown, context: DecoratorContext): void => {\n    switch (context.kind) {\n      case 'class': {\n        const annotationParamtypes = getOrCreateAnnotationParamTypes(context);\n        let dep: Key;\n        let i = 0;\n        for (; i < dependencies.length; ++i) {\n          dep = dependencies[i];\n          if (dep !== void 0) {\n            annotationParamtypes[i] = dep;\n          }\n        }\n        break;\n      }\n      case 'field': {\n        const annotationParamtypes: any = getOrCreateAnnotationParamTypes(context);\n        const dep = dependencies[0];\n        if (dep !== void 0) {\n          annotationParamtypes[context.name] = dep;\n        }\n        break;\n      }\n      // TODO(sayan): support getter injection - new feature\n      // TODO:\n      //    support method parameter injection when the class-method-parameter-decorators proposal (https://github.com/tc39/proposal-class-method-parameter-decorators)\n      //    reaches stage 4 and/or implemented by TS.\n      default:\n        throw createMappedError(ErrorNames.invalid_inject_decorator_usage, String(context.name), context.kind);\n    }\n  };\n};\n\nexport const DI = /*@__PURE__*/ (() => {\n  // putting this function inside this IIFE as we wants to call it without triggering side effect\n  initializeTC39Metadata();\n\n  return {\n    createContainer,\n    getDesignParamtypes,\n    // getAnnotationParamtypes,\n    // getOrCreateAnnotationParamTypes,\n    getDependencies: getDependencies,\n    /**\n     * creates a decorator that also matches an interface and can be used as a {@linkcode Key}.\n     * ```ts\n     * const ILogger = DI.createInterface<Logger>('Logger');\n     * container.register(Registration.singleton(ILogger, getSomeLogger()));\n     * const log = container.get(ILogger);\n     * log.info('hello world');\n     * class Foo {\n     *   constructor( @ILogger log: ILogger ) {\n     *     log.info('hello world');\n     *   }\n     * }\n     * ```\n     * you can also build default registrations into your interface.\n     * ```ts\n     * export const ILogger = DI.createInterface<Logger>('Logger', builder => builder.cachedCallback(LoggerDefault));\n     * const log = container.get(ILogger);\n     * log.info('hello world');\n     * class Foo {\n     *   constructor( @ILogger log: ILogger ) {\n     *     log.info('hello world');\n     *   }\n     * }\n     * ```\n     * but these default registrations won't work the same with other decorators that take keys, for example\n     * ```ts\n     * export const MyStr = DI.createInterface<string>('MyStr', builder => builder.instance('somestring'));\n     * class Foo {\n     *   constructor( @optional(MyStr) public readonly str: string ) {\n     *   }\n     * }\n     * container.get(Foo).str; // returns undefined\n     * ```\n     * to fix this add this line somewhere before you do a `get`\n     * ```ts\n     * container.register(MyStr);\n     * container.get(Foo).str; // returns 'somestring'\n     * ```\n     *\n     * - @param configureOrName - supply a string to improve error messaging\n     */\n    createInterface,\n    inject,\n    /**\n     * Registers the `target` class as a transient dependency; each time the dependency is resolved\n     * a new instance will be created.\n     *\n     * @param target - The class / constructor function to register as transient.\n     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n     *\n     * @example ```ts\n     * // On an existing class\n     * class Foo { }\n     * DI.transient(Foo);\n     *\n     * // Inline declaration\n     * const Foo = DI.transient(class { });\n     * // Foo is now strongly typed with register\n     * Foo.register(container);\n     * ```\n     */\n    transient<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> {\n      target.register = function (container: IContainer): IResolver<InstanceType<T>> {\n        const registration = transientRegistation(target as T, target as T);\n        return registration.register(container, target);\n      };\n      target.registerInRequestor = false;\n      return target as T & RegisterSelf<T>;\n    },\n    /**\n     * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n     * consecutive time the dependency is resolved, the same instance will be returned.\n     *\n     * @param target - The class / constructor function to register as a singleton.\n     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n     * @example ```ts\n     * // On an existing class\n     * class Foo { }\n     * DI.singleton(Foo);\n     *\n     * // Inline declaration\n     * const Foo = DI.singleton(class { });\n     * // Foo is now strongly typed with register\n     * Foo.register(container);\n     * ```\n     */\n    singleton<T extends Constructable>(target: T & Partial<RegisterSelf<T>>, options: SingletonOptions = defaultSingletonOptions):\n      T & RegisterSelf<T> {\n      target.register = function (container: IContainer): IResolver<InstanceType<T>> {\n        const registration = singletonRegistration(target, target);\n        return registration.register(container, target);\n      };\n      target.registerInRequestor = options.scoped;\n      return target as T & RegisterSelf<T>;\n    },\n  };\n})();\n\nexport const IContainer = /*@__PURE__*/createInterface<IContainer>('IContainer');\nexport const IServiceLocator = IContainer as unknown as InterfaceSymbol<IServiceLocator>;\n\nfunction transientDecorator<T extends Constructable>(target: T & Partial<RegisterSelf<T>>, context: ClassDecoratorContext):\n  T & RegisterSelf<T> {\n  return DI.transient(target);\n}\n/**\n * Registers the decorated class as a transient dependency; each time the dependency is resolved\n * a new instance will be created.\n *\n * @example ```ts\n * &#64;transient()\n * class Foo { }\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function transient<T extends Constructable>(): typeof transientDecorator;\n/**\n * Registers the `target` class as a transient dependency; each time the dependency is resolved\n * a new instance will be created.\n *\n * @param target - The class / constructor function to register as transient.\n *\n * @example ```ts\n * &#64;transient()\n * class Foo { }\n * ```\n */\nexport function transient<T extends Constructable>(target: T & Partial<RegisterSelf<T>>, context: ClassDecoratorContext): T & RegisterSelf<T>;\nexport function transient<T extends Constructable>(target?: T & Partial<RegisterSelf<T>>, context?: ClassDecoratorContext): T & RegisterSelf<T> | typeof transientDecorator {\n  return  target == null ? transientDecorator : transientDecorator(target, context!);\n}\n\ntype SingletonOptions = { scoped: boolean };\nconst defaultSingletonOptions = { scoped: false };\nconst decorateSingleton = DI.singleton;\n\ntype SingletonDecorator = <T extends Constructable>(target: T & Partial<RegisterSelf<T>>, context: ClassDecoratorContext) => T & RegisterSelf<T>;\n/**\n * Registers the decorated class as a singleton dependency; the class will only be created once. Each\n * consecutive time the dependency is resolved, the same instance will be returned.\n *\n * @example ```ts\n * &#64;singleton()\n * class Foo { }\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function singleton<T extends Constructable>(): SingletonDecorator;\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function singleton<T extends Constructable>(options?: SingletonOptions): SingletonDecorator;\n/**\n * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n * consecutive time the dependency is resolved, the same instance will be returned.\n *\n * @param target - The class / constructor function to register as a singleton.\n *\n * @example ```ts\n * &#64;singleton()\n * class Foo { }\n * ```\n */\nexport function singleton<T extends Constructable>(target: T & Partial<RegisterSelf<T>>, context: ClassDecoratorContext): T & RegisterSelf<T>;\nexport function singleton<T extends Constructable>(targetOrOptions?: (T & Partial<RegisterSelf<T>>) | SingletonOptions, _context?: ClassDecoratorContext): T & RegisterSelf<T> | SingletonDecorator {\n  return isFunction(targetOrOptions)\n    // The decorator is applied without options. Example: `@singleton()` or `@singleton`\n    ? decorateSingleton(targetOrOptions)\n    : function <T extends Constructable>($target: T, _ctx: ClassDecoratorContext) {\n      return decorateSingleton($target, targetOrOptions);\n    };\n}\n\n_START_CONST_ENUM();\n/** @internal */\nexport const enum ResolverStrategy {\n  instance = 0,\n  singleton = 1,\n  transient = 2,\n  callback = 3,\n  array = 4,\n  alias = 5,\n}\n_END_CONST_ENUM();\n\n/** @internal */\nexport class Resolver<K extends Key = any> implements IResolver<K> {\n  /** @internal */\n  public _key: Key;\n  /** @internal */\n  public _strategy: ResolverStrategy;\n  /** @internal */\n  public _state: any;\n\n  public get $isResolver(): true { return true; }\n\n  /** @internal */\n  private _resolving: boolean = false;\n\n  public constructor(\n    key: K,\n    strategy: ResolverStrategy,\n    state: any,\n  ) {\n    this._key = key;\n    this._strategy = strategy;\n    this._state = state;\n  }\n\n  /**\n   * When resolving a singleton, the internal state is changed,\n   * so cache the original constructable factory for future requests\n   * @internal\n   */\n  private _cachedFactory: IFactory | null = null;\n\n  public register(container: IContainer, key?: Key): IResolver {\n    return container.registerResolver(key || this._key, this as IResolver<K>);\n  }\n\n  public resolve(handler: IContainer, requestor: IContainer): any {\n    switch (this._strategy) {\n      case ResolverStrategy.instance:\n        return this._state;\n      case ResolverStrategy.singleton: {\n        if (this._resolving) {\n          throw createMappedError(ErrorNames.cyclic_dependency, this._state.name);\n        }\n        this._resolving = true;\n        this._state = (this._cachedFactory = handler.getFactory(this._state as Constructable)).construct(requestor);\n        this._strategy = ResolverStrategy.instance;\n        this._resolving = false;\n        return this._state;\n      }\n      case ResolverStrategy.transient: {\n        // Always create transients from the requesting container\n        const factory = handler.getFactory(this._state as Constructable);\n        if (factory === null) {\n          throw createMappedError(ErrorNames.no_factory, this._key);\n        }\n        return factory.construct(requestor);\n      }\n      case ResolverStrategy.callback:\n        return (this._state as ResolveCallback)(handler, requestor, this as IResolver<K>);\n      case ResolverStrategy.array:\n        return (this._state as IResolver[])[0].resolve(handler, requestor);\n      case ResolverStrategy.alias:\n        return requestor.get(this._state);\n      default:\n        throw createMappedError(ErrorNames.invalid_resolver_strategy, this._strategy);\n    }\n  }\n\n  public getFactory<T extends K extends Constructable ? IFactory<K> : IFactory<Constructable>>(container: IContainer): T | null {\n    switch (this._strategy) {\n      case ResolverStrategy.singleton:\n      case ResolverStrategy.transient:\n        return container.getFactory(this._state as Constructable) as T;\n      case ResolverStrategy.alias:\n        return container.getResolver(this._state)?.getFactory?.(container) ?? null;\n      case ResolverStrategy.instance:\n        return this._cachedFactory as T;\n      default:\n        return null;\n    }\n  }\n}\n\n/** @internal */\nexport interface IInvoker<T extends Constructable = any> {\n  invoke(container: IContainer, fn: T, dependencies: Key[]): Resolved<T>;\n  invokeWithDynamicDependencies(\n    container: IContainer,\n    fn: T,\n    staticDependencies: Key[],\n    dynamicDependencies: Key[]\n  ): Resolved<T>;\n}\n\nexport class InstanceProvider<K extends Key> implements IDisposableResolver<K> {\n  /** @internal */ private _instance: Resolved<K> | null;\n  /** @internal */ private readonly _name?: string;\n  /** @internal */ private readonly _Type: Constructable | null;\n\n  public get friendlyName() {\n    return this._name;\n  }\n\n  public constructor(\n    name?: string,\n    /**\n     * if not undefined, then this is the value this provider will resolve to\n     * until overridden by explicit prepare call\n     */\n    instance: Resolved<K> | null = null,\n    Type: Constructable | null = null,\n  ) {\n    this._name = name;\n    this._instance = instance;\n    this._Type = Type;\n  }\n\n  public prepare(instance: Resolved<K>): void {\n    this._instance = instance;\n  }\n\n  public get $isResolver(): true {return true;}\n\n  public resolve(): Resolved<K> {\n    if (this._instance == null) {\n      throw createMappedError(ErrorNames.no_instance_provided, this._name);\n    }\n    return this._instance;\n  }\n\n  public getFactory<T extends K extends Constructable ? IFactory<K> : IFactory<Constructable>>(container: IContainer): T | null {\n    return this._Type == null ? null : container.getFactory(this._Type) as T;\n  }\n\n  public dispose(): void {\n    this._instance = null;\n  }\n}\n\n/**\n * An implementation of IRegistry that delegates registration to a\n * separately registered class. The ParameterizedRegistry facilitates the\n * passing of parameters to the final registry.\n */\nexport class ParameterizedRegistry implements IRegistry {\n  public constructor(\n    private readonly key: Key,\n    private readonly params: unknown[]\n  ) {}\n\n  public register(container: IContainer): void {\n    if (container.has(this.key, true)) {\n      const registry = container.get<IRegistry>(this.key);\n      registry.register(container, ...this.params);\n    } else {\n      container.register(...this.params.filter(x => typeof x === 'object'));\n    }\n  }\n}\n", "import { Platform } from '@aurelia/platform';\nimport { createInterface } from './di';\nimport { objectFreeze } from './utilities';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const emptyArray: any[] = objectFreeze<any>([]);\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const emptyObject: any = objectFreeze({}) as any;\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop(): void {}\n\nexport interface IPlatform extends Platform {}\nexport const IPlatform = /*@__PURE__*/createInterface<IPlatform>('IPlatform');\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { IContainer, IFactory, IRegistry, IResolver, InstanceProvider, InterfaceSymbol, Key, Resolved, inject } from './di';\nimport { createContainer } from './di.container';\nimport { ErrorNames, createMappedError } from './errors';\nimport { Constructable } from './interfaces';\nimport { isFunction, objectAssign, safeString } from './utilities';\n\nexport type ICallableResolver<T> = IResolver<T> & ((...args: unknown[]) => any);\n\n/**\n * ! Semi private API to avoid repetitive work creating resolvers.\n *\n * Naming isn't entirely correct, but it's good enough for internal usage.\n */\nexport function createResolver<T extends Key>(getter: (key: T, handler: IContainer, requestor: IContainer) => any): ((key: T) => ICallableResolver<T>) {\n  return function (key: any) {\n    function Resolver(target: any, context: DecoratorContext): void {\n      inject(Resolver)(target, context);\n    }\n\n    Resolver.$isResolver = true;\n    Resolver.resolve = function (handler: IContainer, requestor: IContainer): any {\n      return getter(key, handler, requestor);\n    };\n\n    return Resolver as ICallableResolver<T>;\n  };\n}\n\n/**\n * Create a resolver that will resolve all values of a key from resolving container\n */\nexport const all = <T extends Key>(key: T, searchAncestors: boolean = false): IAllResolver<T> => {\n  function resolver(decorated: unknown, context: DecoratorContext): void {\n    inject(resolver)(decorated, context);\n  }\n\n  resolver.$isResolver = true;\n  resolver.resolve = (handler: IContainer, requestor: IContainer) => requestor.getAll(key, searchAncestors);\n\n  return resolver as IAllResolver<T>;\n};\nexport type IAllResolver<T> = IResolver<readonly Resolved<T>[]> &\n  // any for decorator\n  ((decorated: unknown, context: DecoratorContext) => any);\n\n/**\n * Create a resolver that will resolve the last instance of a key from the resolving container\n *\n * - @param key [[`Key`]]\n */\nexport const last = <T extends Key>(key: T): IResolver<T | undefined> => ({\n  $isResolver: true,\n  resolve: handler => {\n    const allInstances = handler.getAll(key);\n    return allInstances.length > 0 ? allInstances[allInstances.length - 1] : undefined;\n  }\n});\n\n/**\n * Lazily inject a dependency depending on whether the [[`Key`]] is present at the time of function call.\n *\n * You need to make your argument a function that returns the type, for example\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => number )\n * }\n * const foo = container.get(Foo); // instanceof Foo\n * foo.random(); // throws\n * ```\n * would throw an exception because you haven't registered `'random'` before calling the method. This, would give you a\n * new [['Math.random()']] number each time.\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => random )\n * }\n * container.register(Registration.callback('random', Math.random ));\n * container.get(Foo).random(); // some random number\n * container.get(Foo).random(); // another random number\n * ```\n * `@lazy` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a\n * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.\n *\n * - @param key [[`Key`]]\n * see { @link DI.createInterface } on interactions with interfaces\n */\nexport const lazy = /*@__PURE__*/createResolver((key: Key, handler: IContainer, requestor: IContainer) =>  {\n  return () => requestor.get(key);\n}) as <K extends Key>(key: K) => ILazyResolver<K>;\nexport type ILazyResolver<K extends Key = Key> = IResolver<() => K>\n  // type only hack\n  & { __isLazy: undefined }\n  // any is needed for decorator usages\n  & ((...args: unknown[]) => any);\nexport type IResolvedLazy<K> = () => Resolved<K>;\n\n/**\n * Allows you to optionally inject a dependency depending on whether the [[`Key`]] is present, for example\n * ```ts\n * class Foo {\n *   constructor( @inject('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo); // throws\n * ```\n * would fail\n * ```ts\n * class Foo {\n *   constructor( @optional('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo).str // somestring\n * ```\n * if you use it without a default it will inject `undefined`, so rember to mark your input type as\n * possibly `undefined`!\n *\n * - @param key: [[`Key`]]\n *\n * see { @link DI.createInterface } on interactions with interfaces\n */\nexport const optional = /*@__PURE__*/createResolver((key: Key, handler: IContainer, requestor: IContainer) =>  {\n  if (requestor.has(key, true)) {\n    return requestor.get(key);\n  } else {\n    return undefined;\n  }\n}) as <K extends Key>(key: K) => IOptionalResolver<K>;\nexport type IOptionalResolver<K extends Key = Key> = IResolver<K | undefined> & {\n  // type only hack\n  __isOptional: undefined;\n  // any is needed for decorator usages\n  (...args: unknown[]): any;\n};\n\n/**\n * ignore tells the container not to try to inject a dependency\n */\nexport const ignore: IResolver<undefined> = /*@__PURE__*/objectAssign((decorated: unknown, context: DecoratorContext): void => {\n  inject(ignore)(decorated, context);\n}, {$isResolver: true, resolve: () => void 0} as const);\n\n/**\n * Inject a function that will return a resolved instance of the [[key]] given.\n * Also supports passing extra parameters to the invocation of the resolved constructor of [[key]]\n *\n * For typings, it's a function that take 0 or more arguments and return an instance. Example:\n * ```ts\n * class Foo {\n *   constructor( @factory(MyService) public createService: (...args: unknown[]) => MyService)\n * }\n * const foo = container.get(Foo); // instanceof Foo\n * const myService_1 = foo.createService('user service')\n * const myService_2 = foo.createService('content service')\n * ```\n *\n * ```ts\n * class Foo {\n *   constructor( @factory('random') public createRandomizer: () => Randomizer)\n * }\n * container.get(Foo).createRandomizer(); // create a randomizer\n * ```\n * would throw an exception because you haven't registered `'random'` before calling the method. This, would give you a\n * new instance of Randomizer each time.\n *\n * `@factory` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a\n * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.\n *\n * - @param key [[`Key`]]\n * see { @link DI.createInterface } on interactions with interfaces\n */\nexport const factory = /*@__PURE__*/createResolver((key: any, handler: IContainer, requestor: IContainer) => {\n  return (...args: unknown[]) => handler.getFactory(key).construct(requestor, args);\n}) as <K>(key: K) => IFactoryResolver<K>;\nexport type IFactoryResolver<K = any> = IResolver<K>\n  // type only hack\n  & { __isFactory: undefined }\n  // any is needed for decorator usage\n  & ((...args: unknown[]) => any);\nexport type IResolvedFactory<K> = (...args: unknown[]) => Resolved<K>;\n\n/**\n * Create a resolver that will only resolve if the requesting container has the key pre-registered\n */\nexport const own = /*@__PURE__*/createResolver((key: any, handler: IContainer, requestor: IContainer) => {\n  return requestor.has(key, false) ? requestor.get(key) : void 0;\n}) as <T extends Key>(key: T) => IOptionalResolver<T>;\n\n/**\n * Create a resolver that will resolve a key based on resource semantic (leaf + root + ignore middle layer container)\n * Will resolve at the root level if the key is not registered in the requestor container\n */\nexport const resource = /*@__PURE__*/createResolver((key, handler, requestor) =>\n  requestor.has(key, false)\n    ? requestor.get(key)\n    : requestor.root.get(key)\n) as <K extends Key>(key: K) => ICallableResolver<K>;\n\n/**\n * Create a resolver that will resolve a key based on resource semantic (leaf + root + ignore middle layer container)\n * only if the key is registered either in the requestor container or in the root container\n *\n * Returns `undefined` if the key is not registered in either container\n */\nexport const optionalResource = /*@__PURE__*/createResolver((key, handler, requestor) =>\n  requestor.has(key, false)\n    ? requestor.get(key)\n    : requestor.root.has(key, false)\n      ? requestor.root.get(key)\n      : void 0\n) as <K extends Key>(key: K) => IOptionalResolver<K>;\n\n/**\n * Create a resolver for resolving all registrations of a key with resource semantic (leaf + root + ignore middle layer container)\n */\nexport const allResources = /*@__PURE__*/createResolver((key, handler, requestor) =>\n  // prevent duplicate retrieval\n  requestor === requestor.root\n    ? requestor.getAll(key, false)\n    : requestor.has(key, false)\n      ? requestor.getAll(key, false).concat(requestor.root.getAll(key, false))\n      : requestor.root.getAll(key, false)\n) as <T>(key: T) => IAllResolver<T>;\n\n/**\n * Create a resolver that will resolve a new instance of a key, and register the newly created instance with the requestor container\n */\nexport const newInstanceForScope = /*@__PURE__*/createResolver(\n  (key: any, handler: IContainer, requestor: IContainer) => {\n    const instance = createNewInstance(key, handler, requestor);\n    const instanceProvider = new InstanceProvider<{}>(safeString(key), instance);\n    /**\n     * By default the new instances for scope are disposable.\n     * If need be, we can always enhance the `createNewInstance` to support a 'injection' context, to make a non/disposable registration here.\n     */\n    requestor.registerResolver(key, instanceProvider, true);\n\n    return instance;\n  }) as <K>(key: K) => INewInstanceResolver<K>;\n\n/**\n * Create a resolver that will resolve a new instance of a key\n */\nexport const newInstanceOf = /*@__PURE__*/createResolver(\n  (key: any, handler: IContainer, requestor: IContainer) => createNewInstance(key, handler, requestor)\n) as <K>(key: K) => INewInstanceResolver<K>;\n\nexport type INewInstanceResolver<T> = IResolver<T> & {\n  // type only hack\n  __newInstance: undefined;\n  // any is needed for decorator usage\n  (...args: unknown[]): any;\n};\n\nconst createNewInstance = (key: any, handler: IContainer, requestor: IContainer) => {\n  // 1. if there's a factory registration for the key\n  if (handler.hasFactory(key)) {\n    return handler.getFactory(key).construct(requestor);\n  }\n  // 2. if key is an interface\n  if (isInterface(key)) {\n    const hasDefault = isFunction((key as unknown as IRegistry).register);\n    const resolver = handler.getResolver(key, false) as IResolver<Constructable<typeof key>>;\n    let factory: IFactory | null | undefined;\n    if (resolver == null) {\n      if (hasDefault) {\n        // creating a new container as we do not want to pollute the resolver registry\n        factory = (newInstanceContainer ??= createContainer()).getResolver(key, true)?.getFactory?.(handler);\n      }\n      newInstanceContainer.dispose();\n    } else {\n      factory = resolver.getFactory?.(handler);\n    }\n    // 2.1 and has resolvable factory\n    if (factory != null) {\n      return factory.construct(requestor);\n    }\n    // 2.2 cannot instantiate a dummy interface\n    throw createMappedError(ErrorNames.invalid_new_instance_on_interface, key);\n  }\n  // 3. jit factory, in case of newInstanceOf(SomeClass)\n  return handler.getFactory(key).construct(requestor);\n};\n\nconst isInterface = <K>(key: any): key is InterfaceSymbol<K> => (key as {$isInterface?: boolean})?.$isInterface === true;\n\nlet newInstanceContainer: IContainer;\n", "/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n", "import { createInterface, IContainer, IRegistry } from './di';\nimport { instanceRegistration, singletonRegistration } from './di.registration';\nimport { bound, toLookup } from './functions';\nimport { Class, Constructable } from './interfaces';\nimport { IPlatform } from './platform';\nimport { getAnnotationKeyFor } from './resource';\nimport { createLookup, defineMetadata, getMetadata, isFunction, objectFreeze } from './utilities';\nimport { resolve } from './di.container';\nimport { all, optional } from './di.resolvers';\n\n/** @internal */ export const trace = 0;\n/** @internal */ export const debug = 1;\n/** @internal */ export const info = 2;\n/** @internal */ export const warn = 3;\n/** @internal */ export const error = 4;\n/** @internal */ export const fatal = 5;\n/** @internal */ export const none = 6;\n\nexport const LogLevel = objectFreeze({\n  /**\n   * The most detailed information about internal app state.\n   *\n   * Disabled by default and should never be enabled in a production environment.\n   */\n  trace,\n  /**\n   * Information that is useful for debugging during development and has no long-term value.\n   */\n  debug,\n  /**\n   * Information about the general flow of the application that has long-term value.\n   */\n  info,\n  /**\n   * Unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.\n   */\n  warn,\n  /**\n   * Unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.\n   */\n  error,\n  /**\n   * Unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.\n   */\n  fatal,\n  /**\n   * No messages should be written.\n   */\n  none,\n} as const);\nexport type LogLevel = typeof LogLevel[keyof typeof LogLevel];\n\n/**\n * Flags to enable/disable color usage in the logging output.\n * - `no-colors`: Do not use ASCII color codes in logging output.\n * - `colors`: Use ASCII color codes in logging output. By default, timestamps and the TRC and DBG prefix are colored grey. INF white, WRN yellow, and ERR and FTL red.\n */\nexport type ColorOptions = 'no-colors' | 'colors';\n\n/**\n * The global logger configuration.\n *\n * Properties on this object can be changed during runtime and will affect logging of all components that are housed under the same root DI container as the logger.\n */\nexport interface ILogConfig {\n  /**\n   * The global color options.\n   */\n  colorOptions: ColorOptions;\n  /**\n   * The global log level. Only log calls with the same level or higher are emitted.\n   */\n  level: LogLevel;\n}\n\ninterface ILoggingConfigurationOptions extends ILogConfig {\n  $console: IConsoleLike;\n  sinks: (Class<ISink> | IRegistry)[];\n}\n\n/**\n * Component that creates log event objects based on raw inputs sent to `ILogger`.\n *\n * To customize what data is sent to the sinks, replace the implementation for this interface with your own.\n *\n * @example\n *\n * ```ts\n * export class MyLogEventFactory {\n *   public createLogEvent(logger: ILogger, logLevel: LogLevel, message: string, optionalParams: unknown[]): ILogEvent {\n *     return {\n *       logLevel,\n *       optionalParams,\n *       toString() {\n *         return `[${logger.scope.join('.')}] ${message} ${optionalParams.join(', ')}`;\n *       }\n *     };\n *   }\n * }\n *\n * container.register(Registration.singleton(ILogEventFactory, MyLogEventFactory));\n * ```\n */\nexport interface ILogEventFactory {\n  /**\n   * Create a log event object based on the input parameters sent to `ILogger`.\n   *\n   * @param logger - The `ILogger` that received the message.\n   * @param logLevel - The `LogLevel` associated with the `ILogger` method that the message was passed into. E.g. `logger.debug` will result in `LogLevel.debug`\n   * @param message - The message (first parameter) that was passed into the logger. If a function was passed into the logger, this will be the return value of that function.\n   * @param optionalParams - Additional optional parameters there were passed into the logger, if any.\n   *\n   * @returns An `ILogEvent` object that, by default, only has a `.toString()` method.\n   *\n   * This is called by the default console sink to get the message to emit to the console.\n   * It could be any object of any shape, as long as the registered sinks understand that shape.\n   */\n  createLogEvent(logger: ILogger, logLevel: LogLevel, message: string | Error, optionalParams: unknown[]): ILogEvent;\n}\n\n/**\n * A logging sink that emits `ILogEvent` objects to any kind of output. This can be the console, a database, a web api, a file, etc.\n *\n * Multiple sinks can be registered, and all events will be emitted to all of them.\n *\n * @example\n * // A buffered file sink that writes once per second:\n *\n * ```ts\n * export class BufferedFileSink {\n *   private readonly buffer: ILogEvent[] = [];\n *\n *   constructor() {\n *     setInterval(() => {\n *       const events = this.buffer.splice(0);\n *       if (events.length > 0) {\n *         fs.appendFileSync('my-log.txt', events.map(e => e.toString()).join('\\n'));\n *       }\n *     }, 1000);\n *   }\n *\n *   public emit(event: ILogEvent): void {\n *     this.buffer.push(event);\n *   }\n * }\n *\n * container.register(Registration.singleton(ISink, BufferedFileSink));\n * ```\n */\nexport interface ISink {\n  /**\n   * Handle the provided `ILogEvent` to the output interface wrapped by this sink.\n   *\n   * @param event - The event object to emit. Built-in sinks will call `.toString()` on the event object but custom sinks can do anything they like with the event.\n   */\n  handleEvent(event: ILogEvent): void;\n}\n\n/**\n * The main interface to the logging API.\n *\n * Inject this as a dependency in your components to add centralized, configurable logging capabilities to your application.\n */\nexport interface ILogger extends DefaultLogger {}\n\nexport const ILogConfig = /*@__PURE__*/createInterface<ILogConfig>('ILogConfig', x => x.instance(new LogConfig('no-colors', warn)));\nexport const ISink = /*@__PURE__*/createInterface<ISink>('ISink');\nexport const ILogEventFactory = /*@__PURE__*/createInterface<ILogEventFactory>('ILogEventFactory', x => x.singleton(DefaultLogEventFactory));\nexport const ILogger = /*@__PURE__*/createInterface<ILogger>('ILogger', x => x.singleton(DefaultLogger));\nexport const ILogScopes = /*@__PURE__*/createInterface<string[]>('ILogScope');\n\ninterface SinkDefinition {\n  handles: Exclude<LogLevel, typeof none>[];\n}\n\nexport const LoggerSink = /*@__PURE__*/objectFreeze({\n  key: getAnnotationKeyFor('logger-sink-handles'),\n  define<TSink extends Constructable<ISink>>(target: TSink, definition: SinkDefinition) {\n    defineMetadata(definition.handles, target, this.key);\n  },\n  getHandles<TSink extends ISink>(target: TSink): Exclude<LogLevel, typeof none>[] | undefined {\n    return getMetadata(this.key, target.constructor);\n  },\n});\n\nexport const sink = (definition: SinkDefinition) => {\n  return <TSink extends Constructable<ISink>>(_target: TSink, context: ClassDecoratorContext<TSink>): void =>\n    context.addInitializer(function (this) {\n      LoggerSink.define(this, definition);\n    });\n};\n\nexport interface IConsoleLike {\n  debug(message: string, ...optionalParams: unknown[]): void;\n  info(message: string, ...optionalParams: unknown[]): void;\n  warn(message: string, ...optionalParams: unknown[]): void;\n  error(message: string, ...optionalParams: unknown[]): void;\n}\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\nexport const format = toLookup({\n  red<T extends string>(str: T): T {\n    return `\\u001b[31m${str}\\u001b[39m` as T;\n  },\n  green<T extends string>(str: T): T {\n    return `\\u001b[32m${str}\\u001b[39m` as T;\n  },\n  yellow<T extends string>(str: T): T {\n    return `\\u001b[33m${str}\\u001b[39m` as T;\n  },\n  blue<T extends string>(str: T): T {\n    return `\\u001b[34m${str}\\u001b[39m` as T;\n  },\n  magenta<T extends string>(str: T): T {\n    return `\\u001b[35m${str}\\u001b[39m` as T;\n  },\n  cyan<T extends string>(str: T): T {\n    return `\\u001b[36m${str}\\u001b[39m` as T;\n  },\n  white<T extends string>(str: T): T {\n    return `\\u001b[37m${str}\\u001b[39m` as T;\n  },\n  grey<T extends string>(str: T): T {\n    return `\\u001b[90m${str}\\u001b[39m` as T;\n  },\n} as const);\n\nexport interface ILogEvent {\n  readonly severity: LogLevel;\n  readonly message: string | Error;\n  readonly optionalParams?: readonly unknown[];\n  readonly scope: readonly string[];\n  readonly colorOptions: ColorOptions;\n  readonly timestamp: number;\n  toString(): string;\n  getFormattedLogInfo(forConsole?: boolean): [string, ...unknown[]];\n}\n\nexport class LogConfig implements ILogConfig {\n  public constructor(\n    public readonly colorOptions: ColorOptions,\n    public readonly level: LogLevel,\n  ) {}\n}\n\nconst getLogLevelString = (function () {\n  const logLevelString = {\n    'no-colors': toLookup({\n      TRC: 'TRC',\n      DBG: 'DBG',\n      INF: 'INF',\n      WRN: 'WRN',\n      ERR: 'ERR',\n      FTL: 'FTL',\n      QQQ: '???',\n    } as const),\n    'colors': toLookup({\n      TRC: format.grey('TRC'),\n      DBG: format.grey('DBG'),\n      INF: format.white('INF'),\n      WRN: format.yellow('WRN'),\n      ERR: format.red('ERR'),\n      FTL: format.red('FTL'),\n      QQQ: format.grey('???'),\n    } as const),\n  } as const;\n\n  return (level: LogLevel, colorOptions: ColorOptions): string => {\n    if (level <= trace) {\n      return logLevelString[colorOptions].TRC;\n    }\n    if (level <= debug) {\n      return logLevelString[colorOptions].DBG;\n    }\n    if (level <= info) {\n      return logLevelString[colorOptions].INF;\n    }\n    if (level <= warn) {\n      return logLevelString[colorOptions].WRN;\n    }\n    if (level <= error) {\n      return logLevelString[colorOptions].ERR;\n    }\n    if (level <= fatal) {\n      return logLevelString[colorOptions].FTL;\n    }\n    return logLevelString[colorOptions].QQQ;\n  };\n})();\n\nconst getScopeString = (scope: readonly string[], colorOptions: ColorOptions): string => {\n  if (colorOptions === 'no-colors') {\n    return scope.join('.');\n  }\n  return scope.map(format.cyan).join('.');\n};\n\nconst getIsoString = (timestamp: number, colorOptions: ColorOptions): string => {\n  if (colorOptions === 'no-colors') {\n    return new Date(timestamp).toISOString();\n  }\n  return format.grey(new Date(timestamp).toISOString());\n};\n\nexport class DefaultLogEvent implements ILogEvent {\n  public constructor(\n    public readonly severity: LogLevel,\n    public readonly message: string | Error,\n    public readonly optionalParams: unknown[],\n    public readonly scope: readonly string[],\n    public readonly colorOptions: ColorOptions,\n    public readonly timestamp: number,\n  ) {}\n\n  public toString(): string {\n    const { severity, message, scope, colorOptions, timestamp } = this;\n\n    if (scope.length === 0) {\n      return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)}] ${message}`;\n    }\n    return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)} ${getScopeString(scope, colorOptions)}] ${message}`;\n  }\n\n  public getFormattedLogInfo(forConsole: boolean = false): [string, ...unknown[]] {\n    const { severity, message: messageOrError, scope, colorOptions, timestamp, optionalParams } = this;\n    let error: Error|null = null;\n    let message: string = '';\n    if (forConsole && messageOrError instanceof Error) {\n      error = messageOrError;\n    } else {\n      message = messageOrError as string;\n    }\n\n    const scopeInfo = scope.length === 0 ? '' : ` ${getScopeString(scope, colorOptions)}`;\n    let msg = `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)}${scopeInfo}] ${message}`;\n\n    if (optionalParams === void 0 || optionalParams.length === 0) {\n      return error === null ? [msg] : [msg, error];\n    }\n    let offset = 0;\n    while (msg.includes('%s')) {\n      msg = msg.replace('%s', String(optionalParams[offset++]));\n    }\n    return error !== null ? [msg, error, ...optionalParams.slice(offset)] : [msg, ...optionalParams.slice(offset)];\n  }\n}\n\nexport class DefaultLogEventFactory implements ILogEventFactory {\n  public readonly config = resolve(ILogConfig);\n\n  public createLogEvent(logger: ILogger, level: LogLevel, message: string | Error, optionalParams: unknown[]): ILogEvent {\n    return new DefaultLogEvent(level, message, optionalParams, logger.scope, this.config.colorOptions, Date.now());\n  }\n}\n\nexport class ConsoleSink implements ISink {\n  public static register(container: IContainer) {\n    singletonRegistration(ISink, ConsoleSink).register(container);\n  }\n\n  public readonly handleEvent: (event: ILogEvent) => void;\n\n  public constructor(\n    p = resolve(IPlatform),\n  ) {\n    const $console = p.console as {\n      debug(...args: unknown[]): void;\n      info(...args: unknown[]): void;\n      warn(...args: unknown[]): void;\n      error(...args: unknown[]): void;\n    };\n    this.handleEvent = function emit(event: ILogEvent): void {\n      const _info = event.getFormattedLogInfo(true);\n      switch (event.severity) {\n        case trace:\n        case debug:\n          return $console.debug(..._info);\n        case info:\n          return $console.info(..._info);\n        case warn:\n          return $console.warn(..._info);\n        case error:\n        case fatal:\n          return $console.error(..._info);\n      }\n    };\n  }\n}\n\nexport class DefaultLogger {\n  /**\n   * The root `ILogger` instance. On the root logger itself, this property circularly references the root. It is never null.\n   *\n   * When using `.scopeTo`, a new `ILogger` is created. That new logger will have the `root` property set to the global (non-scoped) logger.\n   */\n  public readonly root: ILogger;\n\n  public readonly config: ILogConfig;\n\n  public readonly sinks: readonly ISink[];\n  /**\n   * The parent `ILogger` instance. On the root logger itself, this property circularly references the root. It is never null.\n   *\n   * When using `.scopeTo`, a new `ILogger` is created. That new logger will have the `parent` property set to the logger that it was created from.\n   */\n  private readonly parent: ILogger;\n  /** @internal */\n  private readonly _traceSinks: ISink[];\n  /** @internal */\n  private readonly _debugSinks: ISink[];\n  /** @internal */\n  private readonly _infoSinks: ISink[];\n  /** @internal */\n  private readonly _warnSinks: ISink[];\n  /** @internal */\n  private readonly _errorSinks: ISink[];\n  /** @internal */\n  private readonly _fatalSinks: ISink[];\n\n  /** @internal */\n  private readonly _scopedLoggers = createLookup<ILogger | undefined>();\n\n  /** @internal */\n  private readonly _factory: ILogEventFactory;\n\n  /* eslint-disable default-param-last */\n  public constructor(\n    /**\n     * The global logger configuration.\n     */\n    config = resolve(ILogConfig),\n    factory = resolve(ILogEventFactory),\n    sinks = resolve(all(ISink)),\n    /**\n     * The scopes that this logger was created for, if any.\n     */\n    public readonly scope: string[] = resolve(optional(ILogScopes)) ?? [],\n    parent: DefaultLogger | null = null,\n  ) {\n  /* eslint-enable default-param-last */\n    let traceSinks: ISink[];\n    let debugSinks: ISink[];\n    let infoSinks: ISink[];\n    let warnSinks: ISink[];\n    let errorSinks: ISink[];\n    let fatalSinks: ISink[];\n    this.config = config;\n    this._factory = factory;\n    this.sinks = sinks;\n    if (parent === null) {\n      this.root = this;\n      this.parent = this;\n\n      traceSinks = this._traceSinks = [];\n      debugSinks = this._debugSinks = [];\n      infoSinks = this._infoSinks = [];\n      warnSinks = this._warnSinks = [];\n      errorSinks = this._errorSinks = [];\n      fatalSinks = this._fatalSinks = [];\n      for (const $sink of sinks) {\n        const handles = LoggerSink.getHandles($sink);\n        if (handles?.includes(trace) ?? true) {\n          traceSinks.push($sink);\n        }\n        if (handles?.includes(debug) ?? true) {\n          debugSinks.push($sink);\n        }\n        if (handles?.includes(info) ?? true) {\n          infoSinks.push($sink);\n        }\n        if (handles?.includes(warn) ?? true) {\n          warnSinks.push($sink);\n        }\n        if (handles?.includes(error) ?? true) {\n          errorSinks.push($sink);\n        }\n        if (handles?.includes(fatal) ?? true) {\n          fatalSinks.push($sink);\n        }\n      }\n    } else {\n      this.root = parent.root;\n      this.parent = parent;\n\n      traceSinks = this._traceSinks = parent._traceSinks;\n      debugSinks = this._debugSinks = parent._debugSinks;\n      infoSinks = this._infoSinks = parent._infoSinks;\n      warnSinks = this._warnSinks = parent._warnSinks;\n      errorSinks = this._errorSinks = parent._errorSinks;\n      fatalSinks = this._fatalSinks = parent._fatalSinks;\n    }\n  }\n\n  /**\n   * Write to TRC output, if the configured `LogLevel` is set to `trace`.\n   *\n   * Intended for the most detailed information about internal app state.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public trace(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to TRC output, if the configured `LogLevel` is set to `trace`.\n   *\n   * Intended for the most detailed information about internal app state.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public trace(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public trace(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= trace) {\n      this._emit(this._traceSinks, trace, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to DBG output, if the configured `LogLevel` is set to `debug` or lower.\n   *\n   * Intended for information that is useful for debugging during development and has no long-term value.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public debug(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to DBG output, if the configured `LogLevel` is set to `debug` or lower.\n   *\n   * Intended for information that is useful for debugging during development and has no long-term value.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public debug(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public debug(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= debug) {\n      this._emit(this._debugSinks, debug, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to trace UBF, if the configured `LogLevel` is set to `info` or lower.\n   *\n   * Intended for information about the general flow of the application that has long-term value.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public info(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to trace UBF, if the configured `LogLevel` is set to `info` or lower.\n   *\n   * Intended for information about the general flow of the application that has long-term value.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public info(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public info(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= info) {\n      this._emit(this._infoSinks, info, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to WRN output, if the configured `LogLevel` is set to `warn` or lower.\n   *\n   * Intended for unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public warn(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to WRN output, if the configured `LogLevel` is set to `warn` or lower.\n   *\n   * Intended for unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public warn(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public warn(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= warn) {\n      this._emit(this._warnSinks, warn, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to ERR output, if the configured `LogLevel` is set to `error` or lower.\n   *\n   * Intended for unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public error(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to ERR output, if the configured `LogLevel` is set to `error` or lower.\n   *\n   * Intended for unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public error(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public error(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= error) {\n      this._emit(this._errorSinks, error, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to FTL output, if the configured `LogLevel` is set to `fatal` or lower.\n   *\n   * Intended for unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public fatal(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to FTL output, if the configured `LogLevel` is set to `fatal` or lower.\n   *\n   * Intended for unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public fatal(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public fatal(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= fatal) {\n      this._emit(this._fatalSinks, fatal, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Create a new logger with an additional permanent prefix added to the logging outputs.\n   * When chained, multiple scopes are separated by a dot.\n   *\n   * This is preliminary API and subject to change before alpha release.\n   *\n   * @example\n   *\n   * ```ts\n   * export class MyComponent {\n   *   constructor(@ILogger private logger: ILogger) {\n   *     this.logger.debug('before scoping');\n   *     // console output: '[DBG] before scoping'\n   *     this.logger = logger.scopeTo('MyComponent');\n   *     this.logger.debug('after scoping');\n   *     // console output: '[DBG MyComponent] after scoping'\n   *   }\n   *\n   *   public doStuff(): void {\n   *     const logger = this.logger.scopeTo('doStuff()');\n   *     logger.debug('doing stuff');\n   *     // console output: '[DBG MyComponent.doStuff()] doing stuff'\n   *   }\n   * }\n   * ```\n   */\n  public scopeTo(name: string): ILogger {\n    const scopedLoggers = this._scopedLoggers;\n    let scopedLogger = scopedLoggers[name];\n    if (scopedLogger === void 0) {\n      scopedLogger = scopedLoggers[name] = new DefaultLogger(this.config, this._factory, null!, this.scope.concat(name), this);\n    }\n    return scopedLogger;\n  }\n\n  /** @internal */\n  private _emit(sinks: ISink[], level: LogLevel, msgOrGetMsg: unknown, optionalParams: unknown[]): void {\n    const message = (isFunction(msgOrGetMsg) ? msgOrGetMsg() : msgOrGetMsg) as string;\n    const event = this._factory.createLogEvent(this, level, message, optionalParams);\n    for (let i = 0, ii = sinks.length; i < ii; ++i) {\n      sinks[i].handleEvent(event);\n    }\n  }\n}\n\n/**\n * A basic `ILogger` configuration that configures a single `console` sink based on provided options.\n *\n * NOTE: You *must* register the return value of `.create` with the container / au instance, not this `LoggerConfiguration` object itself.\n *\n * @example\n * ```ts\n * container.register(LoggerConfiguration.create());\n *\n * container.register(LoggerConfiguration.create({sinks: [ConsoleSink]}))\n *\n * container.register(LoggerConfiguration.create({sinks: [ConsoleSink], level: LogLevel.debug}))\n *\n * ```\n */\nexport const LoggerConfiguration = /*@__PURE__*/ toLookup({\n  /**\n   * @param $console - The `console` object to use. Can be the native `window.console` / `global.console`, but can also be a wrapper or mock that implements the same interface.\n   * @param level - The global `LogLevel` to configure. Defaults to `warn` or higher.\n   * @param colorOptions - Whether to use colors or not. Defaults to `noColors`. Colors are especially nice in nodejs environments but don't necessarily work (well) in all environments, such as browsers.\n   */\n  create(\n    {\n      level = warn,\n      colorOptions = 'no-colors',\n      sinks = [],\n    }: Partial<ILoggingConfigurationOptions> = {}\n  ): IRegistry {\n    return toLookup({\n      register(container: IContainer): IContainer {\n        container.register(\n          instanceRegistration(ILogConfig, new LogConfig(colorOptions, level)),\n        );\n        for (const $sink of sinks) {\n          if (isFunction($sink)) {\n            container.register(singletonRegistration(ISink, $sink));\n          } else {\n            container.register($sink);\n          }\n        }\n        return container;\n      },\n    });\n  },\n});\n", "import { createInterface } from './di';\nimport { resourceBaseName } from './resource';\nimport { getMetadata, isFunction } from './utilities';\nimport { ErrorNames, createMappedError } from './errors';\n\nimport type { IRegistry } from './di';\nimport type { Constructable, IDisposable, IIndexable } from './interfaces';\nimport type { ResourceDefinition } from './resource';\n\nexport interface IModule {\n  [key: string]: unknown;\n  default?: unknown;\n}\n\nexport interface IModuleLoader extends ModuleLoader {}\nexport const IModuleLoader = /*@__PURE__*/createInterface<IModuleLoader>(x => x.singleton(ModuleLoader));\n\nconst noTransform = <TRet = AnalyzedModule>(m: AnalyzedModule): TRet => m as unknown as TRet;\n\ntype TransformFn<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>> = (m: AnalyzedModule<TMod>) => TRet | Promise<TRet>;\n\nclass ModuleTransformer<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>> {\n  private readonly _promiseCache: Map<Promise<IModule>, unknown> = new Map<Promise<IModule>, unknown>();\n  private readonly _objectCache: Map<IModule, unknown> = new Map<IModule, unknown>();\n  private readonly _transform: TransformFn<TMod, TRet>;\n\n  public constructor(\n    transform: TransformFn<TMod, TRet>,\n  ) {\n    this._transform = transform;\n  }\n\n  public transform(objOrPromise: TMod | Promise<TMod>): Promise<TRet> | TRet {\n    if (objOrPromise instanceof Promise) {\n      return this._transformPromise(objOrPromise);\n    } else if (typeof objOrPromise === 'object' && objOrPromise !== null) {\n      return this._transformObject(objOrPromise);\n    } else {\n      throw createMappedError(ErrorNames.invalid_module_transform_input, objOrPromise);\n    }\n  }\n\n  /** @internal */\n  private _transformPromise(promise: Promise<TMod>): TRet | Promise<TRet> {\n    if (this._promiseCache.has(promise)) {\n      return this._promiseCache.get(promise) as TRet | Promise<TRet>;\n    }\n\n    const ret = promise.then(obj => {\n      return this._transformObject(obj);\n    });\n    this._promiseCache.set(promise, ret);\n    void ret.then(value => {\n      // make it synchronous for future requests\n      this._promiseCache.set(promise, value);\n    });\n    return ret;\n  }\n\n  /** @internal */\n  private _transformObject(obj: TMod): TRet | Promise<TRet> {\n    if (this._objectCache.has(obj)) {\n      return this._objectCache.get(obj) as TRet | Promise<TRet>;\n    }\n\n    const ret = this._transform(this._analyze(obj));\n    this._objectCache.set(obj, ret);\n    if (ret instanceof Promise) {\n      void ret.then(value => {\n        // make it synchronous for future requests\n        this._objectCache.set(obj, value);\n      });\n    }\n    return ret;\n  }\n\n  /** @internal */\n  private _analyze(m: TMod): AnalyzedModule<TMod> {\n    if (m == null) throw createMappedError(ErrorNames.invalid_module_transform_input, m);\n    if (typeof m !== 'object') return new AnalyzedModule(m, []);\n    let value: unknown;\n    let isRegistry: boolean;\n    let isConstructable: boolean;\n    let definition: ResourceDefinition | null;\n    const items: ModuleItem[] = [];\n\n    for (const key in m) {\n      switch (typeof (value = m[key])) {\n        case 'object':\n          if (value === null) {\n            continue;\n          }\n          isRegistry = isFunction((value as IIndexable).register);\n          isConstructable = false;\n          definition = null;\n          break;\n        case 'function':\n          isRegistry = isFunction((value as Constructable & IIndexable).register);\n          isConstructable = (value as Constructable).prototype !== void 0;\n          definition = getMetadata(resourceBaseName, value) ?? null;\n          break;\n        default:\n          continue;\n      }\n\n      items.push(new ModuleItem(\n        key,\n        value,\n        isRegistry,\n        isConstructable,\n        definition,\n      ));\n    }\n\n    return new AnalyzedModule(m, items as ITypedModuleItem_T[]);\n  }\n}\n\nexport class ModuleLoader implements IDisposable {\n  private readonly transformers: Map<TransformFn, ModuleTransformer> = new Map<TransformFn, ModuleTransformer>();\n\n  /**\n   * Await a module promise and then analyzes and transforms it. The result is cached, using the transform function + promise as the cache key.\n   *\n   * @param promise - A promise (returning a module, or an object resembling a module), e.g. the return value of a dynamic `import()` or `require()` call.\n   * @param transform - A transform function, e.g. to select the appropriate default or first non-default resource export.\n   * Note: The return value of `transform` is cached, so it is recommended to perform any processing here that is intended to happen only once per unique module promise.\n   *\n   * @returns The (cached) transformed result. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>>(promise: Promise<TMod>, transform: (m: AnalyzedModule<TMod>) => TRet | Promise<TRet>): Promise<TRet> | TRet;\n  /**\n   * Await a module promise and then analyzes it. The result is cached, using the transform function + promise as the cache key.\n   *\n   * @param promise - A promise (returning a module, or an object resembling a module), e.g. the return value of a dynamic `import()` or `require()` call.\n   *\n   * @returns The analyzed module. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule>(promise: Promise<TMod>): Promise<AnalyzedModule<TMod>> | AnalyzedModule<TMod>;\n  /**\n   * Analyzes and transforms a module-like object. The result is cached, using the transform function + object as the cache key.\n   *\n   * @param promise - A module-like object, e.g. the awaited return value of a dynamic `import()` or `require()` call, or a statically imported module such as `import * as Module from './my-module';`.\n   * @param transform - A transform function, e.g. to select the appropriate default or first non-default resource export.\n   * Note: The return value of `transform` is cached, so it is recommended to perform any processing here that is intended to happen only once per unique module promise.\n   *\n   * @returns The (cached) transformed result. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>>(obj: TMod, transform: (m: AnalyzedModule<TMod>) => TRet | Promise<TRet>): Promise<TRet> | TRet;\n  /**\n   * Analyzes a module-like object. The result is cached, using the transform function + object as the cache key.\n   *\n   * @param promise - A module-like object, e.g. the awaited return value of a dynamic `import()` or `require()` call, or a statically imported module such as `import * as Module from './my-module';`.\n   *\n   * @returns The analyzed module. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule>(obj: TMod): AnalyzedModule<TMod>;\n  /**\n   * Analyzes and transforms a module-like object or a promise thereof. The result is cached, using the transform function + object as the cache key.\n   *\n   * @param promise - A module-like object or a promise thereof, e.g. the (awaited) return value of a dynamic `import()` or `require()` call, or a statically imported module such as `import * as Module from './my-module';`.\n   * @param transform - A transform function, e.g. to select the appropriate default or first non-default resource export.\n   * Note: The return value of `transform` is cached, so it is recommended to perform any processing here that is intended to happen only once per unique module promise.\n   *\n   * @returns The (cached) transformed result. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>>(objOrPromise: TMod | Promise<TMod>, transform?: (m: AnalyzedModule<TMod>) => TRet | Promise<TRet>): Promise<TRet> | TRet;\n  public load<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>>(objOrPromise: TMod | Promise<TMod>, transform: (m: AnalyzedModule<TMod>) => TRet | Promise<TRet> = noTransform): Promise<TRet> | TRet {\n    const transformers = this.transformers as Map<TransformFn, ModuleTransformer> & Map<TransformFn<TMod, TRet>, ModuleTransformer<TMod, TRet>>;\n    let transformer = transformers.get(transform);\n    if (transformer === void 0) {\n      transformers.set(transform, transformer = new ModuleTransformer(transform));\n    }\n\n    return transformer.transform(objOrPromise);\n  }\n\n  public dispose(): void {\n    this.transformers.clear();\n  }\n}\n\nexport class AnalyzedModule<TMod extends IModule = IModule> {\n  public constructor(\n    public readonly raw: TMod,\n    public readonly items: readonly ITypedModuleItem_T[],\n  ) {}\n}\n\nexport interface ITypedModuleItem<\n  TisRegistry extends boolean,\n  TisConstructable extends boolean,\n  TValue\n> {\n  readonly key: string;\n  readonly value: TValue;\n  readonly isRegistry: TisRegistry;\n  readonly isConstructable: TisConstructable;\n  readonly definition: ResourceDefinition | null;\n}\nexport interface ITypedModuleItem_Unknown extends ITypedModuleItem<false, false, unknown> {}\nexport interface ITypedModuleItem_Registry extends ITypedModuleItem<true, false, IRegistry> {}\nexport interface ITypedModuleItem_Constructable extends ITypedModuleItem<false, true, Constructable> {}\nexport interface ITypedModuleItem_ConstructableRegistry extends ITypedModuleItem<true, true, Constructable & IRegistry> {}\nexport type ITypedModuleItem_T = (\n  ITypedModuleItem_Unknown |\n  ITypedModuleItem_Registry |\n  ITypedModuleItem_Constructable |\n  ITypedModuleItem_ConstructableRegistry\n);\nexport class ModuleItem {\n  public constructor(\n    public readonly key: string,\n    public readonly value: unknown,\n    public readonly isRegistry: boolean,\n    public readonly isConstructable: boolean,\n    public readonly definition: ResourceDefinition | null,\n  ) {}\n}\n\n/**\n * Iterate through the exports of a module and register aliases for resources respectively\n */\nexport const aliasedResourcesRegistry = (mod: IModule, mainKeyAlias: string | null | undefined, aliases: Record<string, string> = {}): IRegistry => {\n  return {\n    register(container) {\n      const analyzedModule = container.get(IModuleLoader).load(mod);\n      let mainAliasRegistered = false;\n      analyzedModule.items.forEach((item) => {\n        const definition = item.definition;\n\n        if (definition == null) {\n          container.register(item.value);\n          return;\n        }\n\n        if (!mainAliasRegistered && mainKeyAlias != null) {\n          mainAliasRegistered = true;\n          definition.register(container, mainKeyAlias);\n          return;\n        }\n\n        // cannot use item.key, since it could contain an uppercase letter\n        // while if import as is used in html, then it'll be lowercase letters only\n        // using definition name, however, comes with an issue, which is that it's not guaranteed to be unique\n        //\n        // for example: a module can export both an element and an attribute with the name \"foo\"\n        // but if that's the case, devs can always split the exports into two modules\n        const alias = aliases[definition.name];\n        definition.register(container, alias);\n      });\n    },\n  };\n};\n\n// or extract the registry part into a class?\n//\n// class AliasModuleKeysRegistry implements IRegistry {\n//   /** @internal */ private readonly _mod: IModule;\n//   /** @internal */ private readonly _mainKeyAlias: string | null;\n//   /** @internal */ private readonly _otherAliases: Record<string, string>;\n\n//   public constructor(\n//     mod: IModule,\n//     mainKeyAlias: string | null,\n//     aliases: Record<string, string>,\n//   ) {\n//     this._mod = mod;\n//     this._mainKeyAlias = mainKeyAlias;\n//     this._otherAliases = aliases;\n//   }\n\n//   /** @internal */\n//   private _getAliasedKeyForName(key: string, name: string): string {\n//     // replace the part after the last : with the name\n//     const parts = key.split(':');\n//     parts[parts.length - 1] = name;\n//     return parts.join(':');\n//   }\n\n//   public register(container: IContainer) {\n//     const analyzedModule = container.get(IModuleLoader).load(this._mod);\n//     let mainAliasRegistered = false;\n//     analyzedModule.items.forEach((item) => {\n//       const definition = item.definition;\n\n//       if (definition == null) {\n//         container.register(item.value);\n//         return;\n//       }\n\n//       if (!mainAliasRegistered && this._mainKeyAlias != null) {\n//         mainAliasRegistered = true;\n//         aliasToRegistration(definition.key, this._mainKeyAlias).register(container);\n//         return;\n//       }\n\n//       for (const aliasedExport in this._otherAliases) {\n//         const aliasName = this._otherAliases[aliasedExport];\n//         const aliasKey = this._getAliasedKeyForName(definition.key, aliasName);\n//         if (item.key === aliasedExport) {\n//           aliasToRegistration(definition.key, aliasKey).register(container);\n//         }\n//       }\n//     });\n//   }\n// }\n", "import { createInterface } from './di';\nimport { ErrorNames, createMappedError } from './errors';\nimport { Constructable, IDisposable } from './interfaces';\nimport { isString } from './utilities';\n\n/**\n * Represents a handler for an EventAggregator event.\n */\nclass Handler<T extends Constructable> {\n  public constructor(\n    private readonly type: T,\n    private readonly cb: (message: InstanceType<T>) => void,\n  ) {}\n\n  public handle(message: InstanceType<T>): void {\n    if (message instanceof this.type) {\n      this.cb.call(null, message);\n    }\n  }\n}\n\nexport const IEventAggregator = /*@__PURE__*/createInterface<IEventAggregator>('IEventAggregator', x => x.singleton(EventAggregator));\nexport interface IEventAggregator extends EventAggregator {}\n\n/**\n * Enables loosely coupled publish/subscribe messaging.\n */\nexport class EventAggregator {\n  /** @internal */\n  public readonly eventLookup: Record<string, ((message: unknown, channel: string) => void)[]> = {};\n  /** @internal */\n  public readonly messageHandlers: Handler<Constructable>[] = [];\n\n  /**\n   * Publishes a message.\n   *\n   * @param channel - The channel to publish to.\n   * @param message - The message to publish on the channel.\n   */\n  public publish<C extends string>(channel: C, message?: unknown): void;\n  /**\n   * Publishes a message.\n   *\n   * @param instance - The instance to publish.\n   */\n  public publish<T extends Constructable>(instance: InstanceType<T>): void;\n  public publish<T extends Constructable | string>(\n    channelOrInstance: T extends Constructable ? InstanceType<T> : T,\n    message?: unknown,\n  ): void {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (!channelOrInstance) {\n      throw createMappedError(ErrorNames.event_aggregator_publish_invalid_event_name, channelOrInstance);\n    }\n\n    if (isString(channelOrInstance)) {\n      let subscribers = this.eventLookup[channelOrInstance];\n      if (subscribers !== void 0) {\n        subscribers = subscribers.slice();\n        let i = subscribers.length;\n\n        while (i-- > 0) {\n          subscribers[i](message, channelOrInstance);\n        }\n      }\n    } else {\n      const subscribers = this.messageHandlers.slice();\n      let i = subscribers.length;\n\n      while (i-- > 0) {\n        subscribers[i].handle(channelOrInstance);\n      }\n    }\n  }\n\n  /**\n   * Subscribes to a message channel.\n   *\n   * @param channel - The event channel.\n   * @param callback - The callback to be invoked when the specified message is published.\n   */\n  public subscribe<T, C extends string = string>(\n    channel: C,\n    callback: (message: T, channel: C) => void,\n  ): IDisposable;\n  /**\n   * Subscribes to a message type.\n   *\n   * @param type - The event message type.\n   * @param callback - The callback to be invoked when the specified message is published.\n   */\n  public subscribe<T extends Constructable>(\n    type: T,\n    callback: (message: InstanceType<T>) => void,\n  ): IDisposable;\n  public subscribe(\n    channelOrType: string | Constructable,\n    callback: (...args: unknown[]) => void,\n  ): IDisposable {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (!channelOrType) {\n      throw createMappedError(ErrorNames.event_aggregator_subscribe_invalid_event_name, channelOrType);\n    }\n\n    let handler: unknown;\n    let subscribers: unknown[];\n\n    if (isString(channelOrType)) {\n      if (this.eventLookup[channelOrType] === void 0) {\n        this.eventLookup[channelOrType] = [];\n      }\n      handler = callback;\n      subscribers = this.eventLookup[channelOrType];\n    } else {\n      handler = new Handler(channelOrType, callback);\n\n      subscribers = this.messageHandlers;\n    }\n\n    subscribers.push(handler);\n\n    return {\n      dispose(): void {\n        const idx = subscribers.indexOf(handler);\n        if (idx !== -1) {\n          subscribers.splice(idx, 1);\n        }\n      }\n    };\n  }\n\n  /**\n   * Subscribes to a message channel, then disposes the subscription automatically after the first message is received.\n   *\n   * @param channel - The event channel.\n   * @param callback - The callback to be invoked when the specified message is published.\n   */\n  public subscribeOnce<T, C extends string>(\n    channel: C,\n    callback: (message: T, channel: C) => void,\n  ): IDisposable;\n  /**\n   * Subscribes to a message type, then disposes the subscription automatically after the first message is received.\n   *\n   * @param type - The event message type.\n   * @param callback - The callback to be invoked when the specified message is published.\n   */\n  public subscribeOnce<T extends Constructable>(\n    type: T,\n    callback: (message: InstanceType<T>) => void,\n  ): IDisposable;\n  public subscribeOnce(\n    channelOrType: string | Constructable,\n    callback: (...args: unknown[]) => void,\n  ): IDisposable {\n    const sub = this.subscribe(channelOrType as string, (message, event) => {\n      sub.dispose();\n      callback(message, event);\n    });\n\n    return sub;\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { emptyArray } from '@aurelia/kernel';\nimport type { IVisitor } from './ast.visitor';\n\n/** @internal */ export const ekAccessThis = 'AccessThis';\n/** @internal */ export const ekAccessBoundary = 'AccessBoundary';\n/** @internal */ export const ekAccessGlobal = 'AccessGlobal';\n/** @internal */ export const ekAccessScope = 'AccessScope';\n/** @internal */ export const ekArrayLiteral = 'ArrayLiteral';\n/** @internal */ export const ekObjectLiteral = 'ObjectLiteral';\n/** @internal */ export const ekPrimitiveLiteral = 'PrimitiveLiteral';\n/** @internal */ export const ekTemplate = 'Template';\n/** @internal */ export const ekUnary = 'Unary';\n/** @internal */ export const ekCallScope = 'CallScope';\n/** @internal */ export const ekCallMember = 'CallMember';\n/** @internal */ export const ekCallFunction = 'CallFunction';\n/** @internal */ export const ekCallGlobal = 'CallGlobal';\n/** @internal */ export const ekAccessMember = 'AccessMember';\n/** @internal */ export const ekAccessKeyed = 'AccessKeyed';\n/** @internal */ export const ekTaggedTemplate = 'TaggedTemplate';\n/** @internal */ export const ekBinary = 'Binary';\n/** @internal */ export const ekConditional = 'Conditional';\n/** @internal */ export const ekAssign = 'Assign';\n/** @internal */ export const ekArrowFunction = 'ArrowFunction';\n/** @internal */ export const ekValueConverter = 'ValueConverter';\n/** @internal */ export const ekBindingBehavior = 'BindingBehavior';\n/** @internal */ export const ekArrayBindingPattern = 'ArrayBindingPattern';\n/** @internal */ export const ekObjectBindingPattern = 'ObjectBindingPattern';\n/** @internal */ export const ekBindingIdentifier = 'BindingIdentifier';\n/** @internal */ export const ekForOfStatement = 'ForOfStatement';\n/** @internal */ export const ekInterpolation = 'Interpolation';\n/** @internal */ export const ekArrayDestructuring = 'ArrayDestructuring';\n/** @internal */ export const ekObjectDestructuring = 'ObjectDestructuring';\n/** @internal */ export const ekDestructuringAssignmentLeaf = 'DestructuringAssignmentLeaf';\n/** @internal */ export const ekCustom = 'Custom';\n\nexport type ExpressionKind =\n  | 'AccessThis'\n  | 'AccessGlobal'\n  | 'AccessBoundary'\n  | 'AccessScope'\n  | 'ArrayLiteral'\n  | 'ObjectLiteral'\n  | 'PrimitiveLiteral'\n  | 'Template'\n  | 'Unary'\n  | 'CallScope'\n  | 'CallMember'\n  | 'CallFunction'\n  | 'CallGlobal'\n  | 'AccessMember'\n  | 'AccessKeyed'\n  | 'TaggedTemplate'\n  | 'Binary'\n  | 'Conditional'\n  | 'Assign'\n  | 'ArrowFunction'\n  | 'ValueConverter'\n  | 'BindingBehavior'\n  | 'ArrayBindingPattern'\n  | 'ObjectBindingPattern'\n  | 'BindingIdentifier'\n  | 'ForOfStatement'\n  | 'Interpolation'\n  | 'ArrayDestructuring'\n  | 'ObjectDestructuring'\n  | 'DestructuringAssignmentLeaf'\n  | 'Custom';\n\nexport type UnaryOperator = 'void' | 'typeof' | '!' | '-' | '+' | '++' | '--';\n\nexport type BinaryOperator = '??' | '&&' | '||' | '==' | '===' | '!=' | '!==' | 'instanceof' | 'in' | '+' | '-' | '*' | '/' | '%' | '<' | '>' | '<=' | '>=';\nexport type AssignmentOperator = '=' | '/=' | '*=' | '+=' | '-=';\nexport type IsPrimary = AccessThisExpression | AccessBoundaryExpression | AccessScopeExpression | AccessGlobalExpression | ArrayLiteralExpression | ObjectLiteralExpression | PrimitiveLiteralExpression | TemplateExpression;\nexport type IsLiteral = ArrayLiteralExpression | ObjectLiteralExpression | PrimitiveLiteralExpression | TemplateExpression;\nexport type IsLeftHandSide = IsPrimary | CallGlobalExpression | CallFunctionExpression | CallMemberExpression | CallScopeExpression | AccessMemberExpression | AccessKeyedExpression | TaggedTemplateExpression;\nexport type IsUnary = IsLeftHandSide | UnaryExpression;\nexport type IsBinary = IsUnary | BinaryExpression;\nexport type IsConditional = IsBinary | ConditionalExpression;\nexport type IsAssign = IsConditional | AssignExpression | ArrowFunction;\nexport type IsValueConverter = IsAssign | ValueConverterExpression;\nexport type IsBindingBehavior = IsValueConverter | BindingBehaviorExpression;\nexport type IsAssignable = AccessScopeExpression | AccessKeyedExpression | AccessMemberExpression | AssignExpression;\nexport type IsExpression = IsBindingBehavior | Interpolation;\nexport type BindingIdentifierOrPattern = BindingIdentifier | ArrayBindingPattern | ObjectBindingPattern;\nexport type IsExpressionOrStatement = IsExpression | ForOfStatement | BindingIdentifierOrPattern | DestructuringAssignmentExpression | DestructuringAssignmentSingleExpression | DestructuringAssignmentRestExpression;\nexport type AnyBindingExpression<TCustom extends CustomExpression = CustomExpression> = Interpolation | ForOfStatement | TCustom | IsBindingBehavior;\n\nexport class CustomExpression {\n  public readonly $kind = ekCustom;\n  public constructor(\n    public readonly value: unknown,\n  ) {}\n\n  public evaluate(...params: unknown[]): unknown {\n    return this.value;\n  }\n\n  public assign(...params: unknown[]): unknown {\n    return params;\n  }\n\n  public bind(...params: unknown[]): void {\n    // empty\n  }\n\n  public unbind(...params: unknown[]): void {\n    // empty\n  }\n\n  public accept<T>(_visitor: IVisitor<T>): T {\n    return (void 0)!;\n  }\n}\n\nexport class BindingBehaviorExpression {\n  public readonly $kind = ekBindingBehavior;\n  /**\n   * The name of the property to store a binding behavior on the binding when binding\n   */\n  public readonly key: string;\n\n  public constructor(\n    public readonly expression: IsBindingBehavior,\n    public readonly name: string,\n    public readonly args: readonly IsAssign[],\n  ) {\n    this.key = `_bb_${name}`;\n  }\n}\n\nexport class ValueConverterExpression {\n  public readonly $kind = ekValueConverter;\n  public constructor(\n    public readonly expression: IsValueConverter,\n    public readonly name: string,\n    public readonly args: readonly IsAssign[],\n  ) {\n  }\n}\n\nexport class AssignExpression {\n  public readonly $kind = ekAssign;\n\n  public constructor(\n    public readonly target: IsAssignable,\n    public readonly value: IsAssign,\n    public readonly op: AssignmentOperator = '=',\n  ) {}\n}\n\nexport class ConditionalExpression {\n  public readonly $kind = ekConditional;\n  public constructor(\n    public readonly condition: IsBinary,\n    public readonly yes: IsAssign,\n    public readonly no: IsAssign,\n  ) {}\n}\n\nexport class AccessGlobalExpression {\n  public readonly $kind: 'AccessGlobal' = ekAccessGlobal;\n\n  public constructor(\n    public readonly name: string,\n  ) {}\n}\n\nexport class AccessThisExpression {\n  public readonly $kind: 'AccessThis' = ekAccessThis;\n\n  public constructor(\n    public readonly ancestor: number = 0,\n  ) {}\n}\n\nexport class AccessBoundaryExpression {\n  public readonly $kind: 'AccessBoundary' = ekAccessBoundary;\n}\n\nexport class AccessScopeExpression {\n  public readonly $kind = ekAccessScope;\n  public constructor(\n    public readonly name: string,\n    public readonly ancestor: number = 0,\n  ) {}\n}\n\nconst isAccessGlobal = (ast: IsLeftHandSide) => (\n  ast.$kind === ekAccessGlobal ||\n  (\n    ast.$kind === ekAccessMember ||\n    ast.$kind === ekAccessKeyed\n  ) && ast.accessGlobal\n);\n\nexport class AccessMemberExpression {\n  public readonly $kind: 'AccessMember' = ekAccessMember;\n  public readonly accessGlobal: boolean;\n  public constructor(\n    public readonly object: IsLeftHandSide,\n    public readonly name: string,\n    public readonly optional: boolean = false,\n  ) {\n    this.accessGlobal = isAccessGlobal(object);\n  }\n}\n\nexport class AccessKeyedExpression {\n  public readonly $kind = ekAccessKeyed;\n  public readonly accessGlobal: boolean;\n  public constructor(\n    public readonly object: IsLeftHandSide,\n    public readonly key: IsAssign,\n    public readonly optional: boolean = false,\n  ) {\n    this.accessGlobal = isAccessGlobal(object);\n  }\n}\n\nexport class CallScopeExpression {\n  public readonly $kind = ekCallScope;\n  public constructor(\n    public readonly name: string,\n    public readonly args: readonly IsAssign[],\n    public readonly ancestor: number = 0,\n    public readonly optional: boolean = false,\n  ) {}\n}\n\nexport class CallMemberExpression {\n  public readonly $kind = ekCallMember;\n  public constructor(\n    public readonly object: IsLeftHandSide,\n    public readonly name: string,\n    public readonly args: readonly IsAssign[],\n    public readonly optionalMember: boolean = false,\n    public readonly optionalCall: boolean = false,\n  ) {}\n}\n\nexport class CallFunctionExpression {\n  public readonly $kind = ekCallFunction;\n  public constructor(\n    public readonly func: IsLeftHandSide,\n    public readonly args: readonly IsAssign[],\n    public readonly optional: boolean = false,\n  ) {}\n}\n\nexport class CallGlobalExpression {\n  public readonly $kind = ekCallGlobal;\n  public constructor(\n    public readonly name: string,\n    public readonly args: readonly IsAssign[]\n  ) {}\n}\n\nexport class BinaryExpression {\n  public readonly $kind: 'Binary' = ekBinary;\n  public constructor(\n    public readonly operation: BinaryOperator,\n    public readonly left: IsBinary,\n    public readonly right: IsBinary,\n  ) {}\n}\n\nexport class UnaryExpression {\n  public readonly $kind = ekUnary;\n  public constructor(\n    public readonly operation: UnaryOperator,\n    public readonly expression: IsLeftHandSide,\n    public readonly pos: 0 | 1 = 0,\n  ) {}\n}\nexport class PrimitiveLiteralExpression<TValue extends null | undefined | number | boolean | string = null | undefined | number | boolean | string> {\n  public static readonly $undefined: PrimitiveLiteralExpression<undefined> = new PrimitiveLiteralExpression<undefined>(void 0);\n  public static readonly $null: PrimitiveLiteralExpression<null> = new PrimitiveLiteralExpression<null>(null);\n  public static readonly $true: PrimitiveLiteralExpression<true> = new PrimitiveLiteralExpression<true>(true);\n  public static readonly $false: PrimitiveLiteralExpression<false> = new PrimitiveLiteralExpression<false>(false);\n  public static readonly $empty: PrimitiveLiteralExpression<string> = new PrimitiveLiteralExpression<''>('');\n  public readonly $kind = ekPrimitiveLiteral;\n\n  public constructor(\n    public readonly value: TValue,\n  ) {}\n}\n\nexport class ArrayLiteralExpression {\n  public static readonly $empty: ArrayLiteralExpression = new ArrayLiteralExpression(emptyArray);\n  public readonly $kind = ekArrayLiteral;\n  public constructor(\n    public readonly elements: readonly IsAssign[],\n  ) {}\n}\n\nexport class ObjectLiteralExpression {\n  public static readonly $empty: ObjectLiteralExpression = new ObjectLiteralExpression(emptyArray, emptyArray);\n  public readonly $kind = ekObjectLiteral;\n  public constructor(\n    public readonly keys: readonly (number | string)[],\n    public readonly values: readonly IsAssign[],\n  ) {}\n}\n\nexport class TemplateExpression {\n  public static readonly $empty: TemplateExpression = new TemplateExpression(['']);\n  public readonly $kind = ekTemplate;\n  public constructor(\n    public readonly cooked: readonly string[],\n    public readonly expressions: readonly IsAssign[] = emptyArray,\n  ) {}\n}\n\nexport class TaggedTemplateExpression {\n  public readonly $kind = ekTaggedTemplate;\n  public constructor(\n    public readonly cooked: readonly string[] & { raw?: readonly string[] },\n    raw: readonly string[],\n    public readonly func: IsLeftHandSide,\n    public readonly expressions: readonly IsAssign[] = emptyArray,\n  ) {\n    cooked.raw = raw;\n  }\n}\n\nexport class ArrayBindingPattern {\n  public readonly $kind = ekArrayBindingPattern;\n  // We'll either have elements, or keys+values, but never all 3\n  public constructor(\n    public readonly elements: readonly IsAssign[],\n  ) {}\n}\n\nexport class ObjectBindingPattern {\n  public readonly $kind = ekObjectBindingPattern;\n  // We'll either have elements, or keys+values, but never all 3\n  public constructor(\n    public readonly keys: readonly (string | number)[],\n    public readonly values: readonly IsAssign[],\n  ) {}\n}\n\nexport class BindingIdentifier {\n  public readonly $kind = ekBindingIdentifier;\n  public constructor(\n    public readonly name: string,\n  ) {}\n}\n\n// https://tc39.github.io/ecma262/#sec-iteration-statements\n// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements\nexport class ForOfStatement {\n  public readonly $kind = ekForOfStatement;\n  public constructor(\n    public readonly declaration: BindingIdentifierOrPattern | DestructuringAssignmentExpression,\n    public readonly iterable: IsBindingBehavior,\n    public readonly semiIdx: number,\n  ) {}\n}\n\n/*\n* Note: this implementation is far simpler than the one in vCurrent and might be missing important stuff (not sure yet)\n* so while this implementation is identical to Template and we could reuse that one, we don't want to lock outselves in to potentially the wrong abstraction\n* but this class might be a candidate for removal if it turns out it does provide all we need\n*/\nexport class Interpolation {\n  public readonly $kind = ekInterpolation;\n  public readonly isMulti: boolean;\n  public readonly firstExpression: IsBindingBehavior;\n  public constructor(\n    public readonly parts: readonly string[],\n    public readonly expressions: readonly IsBindingBehavior[] = emptyArray,\n  ) {\n    this.isMulti = expressions.length > 1;\n    this.firstExpression = expressions[0];\n  }\n}\n\n// spec: https://tc39.es/ecma262/#sec-destructuring-assignment\n/** This is an internal API */\nexport class DestructuringAssignmentExpression {\n  public constructor(\n    public readonly $kind: 'ArrayDestructuring' | 'ObjectDestructuring',\n    public readonly list: readonly (DestructuringAssignmentExpression | DestructuringAssignmentSingleExpression | DestructuringAssignmentRestExpression)[],\n    public readonly source: AccessMemberExpression | AccessKeyedExpression | undefined,\n    public readonly initializer: IsBindingBehavior | undefined,\n  ) { }\n}\n\n/** This is an internal API */\nexport class DestructuringAssignmentSingleExpression {\n  public readonly $kind = ekDestructuringAssignmentLeaf;\n  public constructor(\n    public readonly target: AccessMemberExpression,\n    public readonly source: AccessMemberExpression | AccessKeyedExpression,\n    public readonly initializer: IsBindingBehavior | undefined,\n  ) { }\n}\n\n/** This is an internal API */\nexport class DestructuringAssignmentRestExpression {\n  public readonly $kind = ekDestructuringAssignmentLeaf;\n  public constructor(\n    public readonly target: AccessMemberExpression,\n    public readonly indexOrProperties: string[] | number,\n  ) { }\n}\n\nexport class ArrowFunction {\n  public readonly $kind = ekArrowFunction;\n  public constructor(\n    public args: BindingIdentifier[],\n    public body: IsAssign,\n    public rest: boolean = false,\n  ) {}\n}\n", "/** @internal */\nexport const createError = (message: string) => new Error(message);\n\n/** @internal */\nexport const isString = (v: unknown): v is string => typeof v === 'string';\n\n// this is used inside template literal, since TS errs without String(...value)\n/** @internal */ export const safeString = String;\n\n/** @internal */ export const createLookup = <T>(): Record<string, T> => Object.create(null) as Record<string, T>;\n", "import {\n  CustomExpression,\n  ekAccessBoundary,\n  ekAccessKeyed,\n  ekAccessMember,\n  ekAccessScope,\n  ekAccessThis,\n  ekArrayBindingPattern,\n  ekArrayDestructuring,\n  ekArrayLiteral,\n  ekArrowFunction,\n  ekAssign,\n  ekBinary,\n  ekBindingBehavior,\n  ekBindingIdentifier,\n  ekCallFunction,\n  ekCallMember,\n  ekCallScope,\n  ekConditional,\n  ekCustom,\n  ekDestructuringAssignmentLeaf,\n  ekForOfStatement,\n  ekInterpolation,\n  ekObjectBindingPattern,\n  ekObjectDestructuring,\n  ekObjectLiteral,\n  ekPrimitiveLiteral,\n  ekTaggedTemplate,\n  ekTemplate,\n  ekUnary,\n  ekValueConverter,\n} from './ast';\nimport {\n  createError,\n  isString,\n  safeString,\n} from './utilities';\n\nimport type {\n  AccessBoundaryExpression,\n  AccessKeyedExpression,\n  AccessMemberExpression,\n  AccessScopeExpression,\n  AccessThisExpression,\n  ArrayBindingPattern,\n  ArrayLiteralExpression,\n  ArrowFunction,\n  AssignExpression,\n  BinaryExpression,\n  BindingBehaviorExpression,\n  BindingIdentifier,\n  CallFunctionExpression,\n  CallMemberExpression,\n  CallScopeExpression,\n  ConditionalExpression,\n  DestructuringAssignmentExpression,\n  DestructuringAssignmentRestExpression,\n  DestructuringAssignmentSingleExpression,\n  ForOfStatement,\n  Interpolation,\n  IsBindingBehavior,\n  IsExpressionOrStatement,\n  ObjectBindingPattern,\n  ObjectLiteralExpression,\n  PrimitiveLiteralExpression,\n  TaggedTemplateExpression,\n  TemplateExpression,\n  UnaryExpression,\n  ValueConverterExpression,\n} from './ast';\n\nexport interface IVisitor<T = unknown, TCustom extends CustomExpression = CustomExpression> {\n  visitAccessKeyed(expr: AccessKeyedExpression): T;\n  visitAccessMember(expr: AccessMemberExpression): T;\n  visitAccessScope(expr: AccessScopeExpression): T;\n  visitAccessThis(expr: AccessThisExpression): T;\n  visitAccessBoundary(expr: AccessBoundaryExpression): T;\n  visitArrayBindingPattern(expr: ArrayBindingPattern): T;\n  visitArrayLiteral(expr: ArrayLiteralExpression): T;\n  visitArrowFunction(expr: ArrowFunction): T;\n  visitAssign(expr: AssignExpression): T;\n  visitBinary(expr: BinaryExpression): T;\n  visitBindingBehavior(expr: BindingBehaviorExpression): T;\n  visitBindingIdentifier(expr: BindingIdentifier): T;\n  visitCallFunction(expr: CallFunctionExpression): T;\n  visitCallMember(expr: CallMemberExpression): T;\n  visitCallScope(expr: CallScopeExpression): T;\n  visitConditional(expr: ConditionalExpression): T;\n  visitForOfStatement(expr: ForOfStatement): T;\n  visitInterpolation(expr: Interpolation): T;\n  visitObjectBindingPattern(expr: ObjectBindingPattern): T;\n  visitObjectLiteral(expr: ObjectLiteralExpression): T;\n  visitPrimitiveLiteral(expr: PrimitiveLiteralExpression): T;\n  visitTaggedTemplate(expr: TaggedTemplateExpression): T;\n  visitTemplate(expr: TemplateExpression): T;\n  visitUnary(expr: UnaryExpression): T;\n  visitValueConverter(expr: ValueConverterExpression): T;\n  visitDestructuringAssignmentExpression(expr: DestructuringAssignmentExpression): T;\n  visitDestructuringAssignmentSingleExpression(expr: DestructuringAssignmentSingleExpression): T;\n  visitDestructuringAssignmentRestExpression(expr: DestructuringAssignmentRestExpression): T;\n  visitCustom(expr: TCustom): T;\n}\n\nexport const astVisit = <T, TCustom extends CustomExpression>(ast: TCustom | IsExpressionOrStatement, visitor: IVisitor<T, TCustom>) => {\n  switch (ast.$kind) {\n    case ekAccessKeyed: return visitor.visitAccessKeyed(ast);\n    case ekAccessMember: return visitor.visitAccessMember(ast);\n    case ekAccessScope: return visitor.visitAccessScope(ast);\n    case ekAccessThis: return visitor.visitAccessThis(ast);\n    case ekAccessBoundary: return visitor.visitAccessBoundary(ast);\n    case ekArrayBindingPattern: return visitor.visitArrayBindingPattern(ast);\n    case ekArrayDestructuring: return visitor.visitDestructuringAssignmentExpression(ast);\n    case ekArrayLiteral: return visitor.visitArrayLiteral(ast);\n    case ekArrowFunction: return visitor.visitArrowFunction(ast);\n    case ekAssign: return visitor.visitAssign(ast);\n    case ekBinary: return visitor.visitBinary(ast);\n    case ekBindingBehavior: return visitor.visitBindingBehavior(ast);\n    case ekBindingIdentifier: return visitor.visitBindingIdentifier(ast);\n    case ekCallFunction: return visitor.visitCallFunction(ast);\n    case ekCallMember: return visitor.visitCallMember(ast);\n    case ekCallScope: return visitor.visitCallScope(ast);\n    case ekConditional: return visitor.visitConditional(ast);\n    case ekDestructuringAssignmentLeaf: return visitor.visitDestructuringAssignmentSingleExpression(ast as DestructuringAssignmentSingleExpression);\n    case ekForOfStatement: return visitor.visitForOfStatement(ast);\n    case ekInterpolation: return visitor.visitInterpolation(ast);\n    case ekObjectBindingPattern: return visitor.visitObjectBindingPattern(ast);\n    case ekObjectDestructuring: return visitor.visitDestructuringAssignmentExpression(ast);\n    case ekObjectLiteral: return visitor.visitObjectLiteral(ast);\n    case ekPrimitiveLiteral: return visitor.visitPrimitiveLiteral(ast);\n    case ekTaggedTemplate: return visitor.visitTaggedTemplate(ast);\n    case ekTemplate: return visitor.visitTemplate(ast);\n    case ekUnary: return visitor.visitUnary(ast);\n    case ekValueConverter: return visitor.visitValueConverter(ast);\n    case ekCustom: return visitor.visitCustom(ast);\n    default: {\n      throw createError(`Trying to visit unknown ast node ${JSON.stringify(ast)}`);\n    }\n  }\n};\n\nexport class Unparser implements IVisitor<void> {\n  public text: string = '';\n\n  public static unparse(expr: IsExpressionOrStatement): string {\n    const visitor = new Unparser();\n    astVisit(expr, visitor);\n    return visitor.text;\n  }\n\n  public visitAccessMember(expr: AccessMemberExpression): void {\n    astVisit(expr.object, this);\n    this.text += `${expr.optional ? '?' : ''}.${expr.name}`;\n  }\n\n  public visitAccessKeyed(expr: AccessKeyedExpression): void {\n    astVisit(expr.object, this);\n    this.text += `${expr.optional ? '?.' : ''}[`;\n    astVisit(expr.key, this);\n    this.text += ']';\n  }\n\n  public visitAccessThis(expr: AccessThisExpression): void {\n    if (expr.ancestor === 0) {\n      this.text += '$this';\n      return;\n    }\n    this.text += '$parent';\n    let i = expr.ancestor - 1;\n    while (i--) {\n      this.text += '.$parent';\n    }\n  }\n\n  public visitAccessBoundary(_expr: AccessBoundaryExpression): void {\n    this.text += 'this';\n  }\n\n  public visitAccessScope(expr: AccessScopeExpression): void {\n    let i = expr.ancestor;\n    while (i--) {\n      this.text += '$parent.';\n    }\n    this.text += expr.name;\n  }\n\n  public visitArrayLiteral(expr: ArrayLiteralExpression): void {\n    const elements = expr.elements;\n    this.text += '[';\n    for (let i = 0, length = elements.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      astVisit(elements[i], this);\n    }\n    this.text += ']';\n  }\n\n  public visitArrowFunction(expr: ArrowFunction): void {\n    const args = expr.args;\n    const ii = args.length;\n    let i = 0;\n    let text = '(';\n    let name: string;\n    for (; i < ii; ++i) {\n      name = args[i].name;\n      if (i > 0) {\n        text += ', ';\n      }\n      if (i < ii - 1) {\n        text += name;\n      } else {\n        text += expr.rest ? `...${name}` : name;\n      }\n    }\n    this.text += `${text}) => `;\n    astVisit(expr.body, this);\n  }\n\n  public visitObjectLiteral(expr: ObjectLiteralExpression): void {\n    const keys = expr.keys;\n    const values = expr.values;\n    this.text += '{';\n    for (let i = 0, length = keys.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      this.text += `'${keys[i]}':`;\n      astVisit(values[i], this);\n    }\n    this.text += '}';\n  }\n\n  public visitPrimitiveLiteral(expr: PrimitiveLiteralExpression): void {\n    this.text += '(';\n    if (isString(expr.value)) {\n      const escaped = expr.value.replace(/'/g, '\\\\\\'');\n      this.text += `'${escaped}'`;\n    } else {\n      this.text += `${expr.value}`;\n    }\n    this.text += ')';\n  }\n\n  public visitCallFunction(expr: CallFunctionExpression): void {\n    this.text += '(';\n    astVisit(expr.func, this);\n    this.text += expr.optional ? '?.' : '';\n    this.writeArgs(expr.args);\n    this.text += ')';\n  }\n\n  public visitCallMember(expr: CallMemberExpression): void {\n    this.text += '(';\n    astVisit(expr.object, this);\n    this.text += `${expr.optionalMember ? '?.' : ''}.${expr.name}${expr.optionalCall ? '?.' : ''}`;\n    this.writeArgs(expr.args);\n    this.text += ')';\n  }\n\n  public visitCallScope(expr: CallScopeExpression): void {\n    this.text += '(';\n    let i = expr.ancestor;\n    while (i--) {\n      this.text += '$parent.';\n    }\n    this.text += `${expr.name}${expr.optional ? '?.' : ''}`;\n    this.writeArgs(expr.args);\n    this.text += ')';\n  }\n\n  public visitTemplate(expr: TemplateExpression): void {\n    const { cooked, expressions } = expr;\n    const length = expressions.length;\n    this.text += '`';\n    this.text += cooked[0];\n    for (let i = 0; i < length; i++) {\n      astVisit(expressions[i], this);\n      this.text += cooked[i + 1];\n    }\n    this.text += '`';\n  }\n\n  public visitTaggedTemplate(expr: TaggedTemplateExpression): void {\n    const { cooked, expressions } = expr;\n    const length = expressions.length;\n    astVisit(expr.func, this);\n    this.text += '`';\n    this.text += cooked[0];\n    for (let i = 0; i < length; i++) {\n      astVisit(expressions[i], this);\n      this.text += cooked[i + 1];\n    }\n    this.text += '`';\n  }\n\n  public visitUnary(expr: UnaryExpression): void {\n    this.text += `(${expr.operation}`;\n    if (expr.operation.charCodeAt(0) >= /* a */97) {\n      this.text += ' ';\n    }\n    astVisit(expr.expression, this);\n    this.text += ')';\n  }\n\n  public visitBinary(expr: BinaryExpression): void {\n    this.text += '(';\n    astVisit(expr.left, this);\n    if (expr.operation.charCodeAt(0) === /* i */105) {\n      this.text += ` ${expr.operation} `;\n    } else {\n      this.text += expr.operation;\n    }\n    astVisit(expr.right, this);\n    this.text += ')';\n  }\n\n  public visitConditional(expr: ConditionalExpression): void {\n    this.text += '(';\n    astVisit(expr.condition, this);\n    this.text += '?';\n    astVisit(expr.yes, this);\n    this.text += ':';\n    astVisit(expr.no, this);\n    this.text += ')';\n  }\n\n  public visitAssign(expr: AssignExpression): void {\n    this.text += '(';\n    astVisit(expr.target, this);\n    this.text += '=';\n    astVisit(expr.value, this);\n    this.text += ')';\n  }\n\n  public visitValueConverter(expr: ValueConverterExpression): void {\n    const args = expr.args;\n    astVisit(expr.expression, this);\n    this.text += `|${expr.name}`;\n    for (let i = 0, length = args.length; i < length; ++i) {\n      this.text += ':';\n      astVisit(args[i], this);\n    }\n  }\n\n  public visitBindingBehavior(expr: BindingBehaviorExpression): void {\n    const args = expr.args;\n    astVisit(expr.expression, this);\n    this.text += `&${expr.name}`;\n    for (let i = 0, length = args.length; i < length; ++i) {\n      this.text += ':';\n      astVisit(args[i], this);\n    }\n  }\n\n  public visitArrayBindingPattern(expr: ArrayBindingPattern): void {\n    const elements = expr.elements;\n    this.text += '[';\n    for (let i = 0, length = elements.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      astVisit(elements[i], this);\n    }\n    this.text += ']';\n  }\n\n  public visitObjectBindingPattern(expr: ObjectBindingPattern): void {\n    const keys = expr.keys;\n    const values = expr.values;\n    this.text += '{';\n    for (let i = 0, length = keys.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      this.text += `'${keys[i]}':`;\n      astVisit(values[i], this);\n    }\n    this.text += '}';\n  }\n\n  public visitBindingIdentifier(expr: BindingIdentifier): void {\n    this.text += expr.name;\n  }\n\n  public visitForOfStatement(expr: ForOfStatement): void {\n    astVisit(expr.declaration, this);\n    this.text += ' of ';\n    astVisit(expr.iterable, this);\n  }\n\n  public visitInterpolation(expr: Interpolation): void {\n    const { parts, expressions } = expr;\n    const length = expressions.length;\n    this.text += '${';\n    this.text += parts[0];\n    for (let i = 0; i < length; i++) {\n      astVisit(expressions[i], this);\n      this.text += parts[i + 1];\n    }\n    this.text += '}';\n  }\n\n  public visitDestructuringAssignmentExpression(expr: DestructuringAssignmentExpression): void {\n    const $kind = expr.$kind;\n    const isObjDes = $kind === ekObjectDestructuring;\n    this.text += isObjDes ? '{' : '[';\n    const list = expr.list;\n    const len = list.length;\n    let i: number;\n    let item: DestructuringAssignmentExpression | DestructuringAssignmentSingleExpression | DestructuringAssignmentRestExpression;\n    for(i = 0; i< len; i++) {\n      item = list[i];\n      switch(item.$kind) {\n        case ekDestructuringAssignmentLeaf:\n          astVisit(item, this);\n          break;\n        case ekArrayDestructuring:\n        case ekObjectDestructuring: {\n          const source = item.source;\n          if(source) {\n            astVisit(source, this);\n            this.text += ':';\n          }\n          astVisit(item, this);\n          break;\n        }\n      }\n    }\n    this.text += isObjDes ? '}' : ']';\n  }\n\n  public visitDestructuringAssignmentSingleExpression(expr: DestructuringAssignmentSingleExpression): void {\n    astVisit(expr.source, this);\n    this.text += ':';\n    astVisit(expr.target, this);\n    const initializer = expr.initializer;\n    if(initializer !== void 0) {\n      this.text +='=';\n      astVisit(initializer, this);\n    }\n  }\n\n  public visitDestructuringAssignmentRestExpression(expr: DestructuringAssignmentRestExpression): void {\n    this.text += '...';\n    astVisit(expr.target, this);\n  }\n\n  public visitCustom(expr: CustomExpression): void {\n    this.text += safeString(expr.value);\n  }\n\n  private writeArgs(args: readonly IsBindingBehavior[]): void {\n    this.text += '(';\n    for (let i = 0, length = args.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      astVisit(args[i], this);\n    }\n    this.text += ')';\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable prefer-template */\n\nimport { safeString } from './utilities';\n\n/** @internal */\nexport const createMappedError: CreateError = __DEV__\n  ? (code: ErrorNames, ...details: unknown[]) => new Error(`AUR${safeString(code).padStart(4, '0')}: ${getMessageByCode(code, ...details)}`)\n  : (code: ErrorNames, ...details: unknown[]) => new Error(`AUR${safeString(code).padStart(4, '0')}:${details.map(safeString)}`);\n\n_START_CONST_ENUM();\n/** @internal */\nexport const enum ErrorNames {\n  method_not_implemented = 99,\n\n  ast_behavior_not_found = 101,\n  ast_behavior_duplicated = 102,\n  ast_converter_not_found = 103,\n  ast_$host_not_found = 105,\n  ast_no_assign_$host = 106,\n  ast_not_a_function = 107,\n  ast_unknown_binary_operator = 108,\n  ast_unknown_unary_operator = 109,\n  ast_tagged_not_a_function = 110,\n  ast_name_is_not_a_function = 111,\n  ast_destruct_null = 112,\n\n  parse_invalid_start = 151,\n  parse_no_spread = 152,\n  parse_expected_identifier = 153,\n  parse_invalid_member_expr = 154,\n  parse_unexpected_end = 155,\n  parse_unconsumed_token = 156,\n  parse_invalid_empty = 157,\n  parse_left_hand_side_not_assignable = 158,\n  parse_expected_converter_identifier = 159,\n  parse_expected_behavior_identifier = 160,\n  parse_unexpected_keyword_of = 161,\n  parse_unexpected_keyword_import = 162,\n  parse_invalid_identifier_in_forof = 163,\n  parse_invalid_identifier_object_literal_key = 164,\n  parse_unterminated_string = 165,\n  parse_unterminated_template_string = 166,\n  parse_missing_expected_token = 167,\n  parse_unexpected_character = 168,\n  parse_unexpected_token_destructuring = 170,\n  parse_unexpected_token_optional_chain = 171,\n  parse_invalid_tag_in_optional_chain = 172,\n  parse_invalid_arrow_params = 173,\n  parse_no_arrow_param_default_value = 174,\n  parse_no_arrow_param_destructuring = 175,\n  parse_rest_must_be_last = 176,\n  parse_no_arrow_fn_body = 178,\n  parse_unexpected_double_dot = 179,\n}\n_END_CONST_ENUM();\n\nconst errorsMap: Record<ErrorNames, string> = {\n  [ErrorNames.method_not_implemented]: 'Method {{0}} not implemented',\n\n  [ErrorNames.ast_behavior_not_found]: `Ast eval error: binding behavior \"{{0}}\" could not be found. Did you forget to register it as a dependency?`,\n  [ErrorNames.ast_behavior_duplicated]: `Ast eval error: binding behavior \"{{0}}\" already applied.`,\n  [ErrorNames.ast_converter_not_found]: `Ast eval error: value converter \"{{0}}\" could not be found. Did you forget to register it as a dependency?`,\n  [ErrorNames.ast_$host_not_found]: `Ast eval error: unable to find $host context. Did you forget [au-slot] attribute?`,\n  [ErrorNames.ast_no_assign_$host]: `Ast eval error: invalid assignment. \"$host\" is a reserved keyword.`,\n  [ErrorNames.ast_not_a_function]: `Ast eval error: expression is not a function.`,\n  [ErrorNames.ast_unknown_unary_operator]: `Ast eval error: unknown unary operator: \"{{0}}\"`,\n  [ErrorNames.ast_unknown_binary_operator]: `Ast eval error: unknown binary operator: \"{{0}}\"`,\n  [ErrorNames.ast_tagged_not_a_function]: `Ast eval error: left-hand side of tagged template expression is not a function.`,\n  [ErrorNames.ast_name_is_not_a_function]: `Ast eval error: expected \"{{0}}\" to be a function`,\n  [ErrorNames.ast_destruct_null]: `Ast eval error: cannot use non-object value for destructuring assignment.`,\n\n  [ErrorNames.parse_invalid_start]: `Expression error: invalid start: \"{{0}}\"`,\n  [ErrorNames.parse_no_spread]: `Expression error: spread operator is not supported: \"{{0}}\"`,\n  [ErrorNames.parse_expected_identifier]: `Expression error: expected identifier: \"{{0}}\"`,\n  [ErrorNames.parse_invalid_member_expr]: `Expression error: invalid member expression: \"{{0}}\"`,\n  [ErrorNames.parse_unexpected_end]: `Expression error: unexpected end of expression: \"{{0}}\"`,\n  [ErrorNames.parse_unconsumed_token]: `Expression error: unconsumed token: \"{{0}}\" at position {{1}} of \"{{2}}\"`,\n  [ErrorNames.parse_invalid_empty]: `Expression error: invalid empty expression. Empty expression is only valid in event bindings (trigger, delegate, capture etc...)`,\n  [ErrorNames.parse_left_hand_side_not_assignable]: `Expression error: left hand side of expression is not assignable: \"{{0}}\"`,\n  [ErrorNames.parse_expected_converter_identifier]: `Expression error: expected identifier to come after value converter operator: \"{{0}}\"`,\n  [ErrorNames.parse_expected_behavior_identifier]: `Expression error: expected identifier to come after binding behavior operator: {{0}}`,\n  [ErrorNames.parse_unexpected_keyword_of]: `Expression error: unexpected keyword \"of\": \"{{0}}\"`,\n  [ErrorNames.parse_unexpected_keyword_import]: `Expression error: unexpected keyword \"import\": \"{{0}}\"`,\n  [ErrorNames.parse_invalid_identifier_in_forof]: `Expression error: invalid BindingIdentifier at left hand side of \"of\": \"{{0}}\" | kind: {{1}}`,\n  [ErrorNames.parse_invalid_identifier_object_literal_key]: `Expression error: invalid or unsupported property definition in object literal: \"{{0}}\"`,\n  [ErrorNames.parse_unterminated_string]: `Expression error: unterminated quote in string literal: \"{{0}}\"`,\n  [ErrorNames.parse_unterminated_template_string]: `Expression error: unterminated template string: \"{{0}}\"`,\n  [ErrorNames.parse_missing_expected_token]: `Expression error: missing expected token \"{{0}}\" in \"{{1}}\"`,\n  [ErrorNames.parse_unexpected_character]: `Expression error: unexpected character: \"{{0}}\"`,\n  [ErrorNames.parse_unexpected_token_destructuring]: `Expression error: unexpected \"{{0}}\" at position \"{{1}}\" for destructuring assignment in \"{{2}}\"`,\n  [ErrorNames.parse_unexpected_token_optional_chain]: `Expression error: unexpected {{0}} at position \"{{1}}\" for optional chain in \"{{2}}\"`,\n  [ErrorNames.parse_invalid_tag_in_optional_chain]: `Expression error: invalid tagged template on optional chain in \"{{1}}\"`,\n  [ErrorNames.parse_invalid_arrow_params]: `Expression error: invalid arrow parameter list in \"{{0}}\"`,\n  [ErrorNames.parse_no_arrow_param_default_value]: `Expression error: arrow function with default parameters is not supported: \"{{0}}\"`,\n  [ErrorNames.parse_no_arrow_param_destructuring]: `Expression error: arrow function with destructuring parameters is not supported: \"{{0}}\"`,\n  [ErrorNames.parse_rest_must_be_last]: `Expression error: rest parameter must be last formal parameter in arrow function: \"{{0}}\"`,\n  [ErrorNames.parse_no_arrow_fn_body]: `Expression error: arrow function with function body is not supported: \"{{0}}\"`,\n  [ErrorNames.parse_unexpected_double_dot]: `Expression error: unexpected token '.' at position \"{{1}}\" in \"{{0}}\"`,\n\n};\n\nconst getMessageByCode = (name: ErrorNames, ...details: unknown[]) => {\n  let cooked: string = errorsMap[name];\n  for (let i = 0; i < details.length; ++i) {\n    const regex = new RegExp(`{{${i}(:.*)?}}`, 'g');\n    let matches = regex.exec(cooked);\n    while (matches != null) {\n      const method = matches[1]?.slice(1);\n      let value = details[i] as any;\n      if (value != null) {\n        switch (method) {\n          case 'toString': value = Object.prototype.toString.call(value); break;\n          case 'join(!=)': value = (value as unknown[]).join('!='); break;\n          case 'element': value = value === '*' ? 'all elements' : `<${value} />`; break;\n          default: {\n            // property access\n            if (method?.startsWith('.')) {\n              value = safeString(value[method.slice(1)]);\n            } else {\n              value = safeString(value);\n            }\n          }\n        }\n      }\n      cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);\n      matches = regex.exec(cooked);\n    }\n  }\n  return cooked;\n};\n\ntype CreateError = (code: ErrorNames, ...details: unknown[]) => Error;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction pleaseHelpCreateAnIssue(title: string, body?: string) {\n  return `\\nThis is likely an issue with Aurelia.\\n Please help create an issue by clicking the following link\\n`\n    + `https://github.com/aurelia/aurelia/issues/new?title=${encodeURIComponent(title)}`\n    + (body != null ? `&body=${encodeURIComponent(body)}` : '&template=bug_report.md');\n}\n", "/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */\nimport {\n  AccessKeyedExpression,\n  AccessMemberExpression,\n  AccessScopeExpression,\n  AccessThisExpression,\n  ArrayBindingPattern,\n  ArrayLiteralExpression,\n  AssignExpression,\n  BinaryExpression,\n  BindingBehaviorExpression,\n  BindingIdentifier,\n  CallFunctionExpression,\n  CallMemberExpression,\n  CallScopeExpression,\n  ConditionalExpression,\n  CustomExpression,\n  ForOfStatement,\n  Interpolation,\n  ObjectBindingPattern,\n  ObjectLiteralExpression,\n  PrimitiveLiteralExpression,\n  TaggedTemplateExpression,\n  TemplateExpression,\n  UnaryExpression,\n  ValueConverterExpression,\n  AnyBindingExpression,\n  BinaryOperator,\n  BindingIdentifierOrPattern,\n  IsAssign,\n  IsAssignable,\n  IsBinary,\n  IsBindingBehavior,\n  IsExpressionOrStatement,\n  IsLeftHandSide,\n  IsValueConverter,\n  UnaryOperator,\n  DestructuringAssignmentSingleExpression as DASE,\n  DestructuringAssignmentExpression as DAE,\n  ArrowFunction,\n  AccessGlobalExpression,\n  CallGlobalExpression,\n  type ExpressionKind,\n  ekAccessThis,\n  ekAccessGlobal,\n  ekAccessMember,\n  ekAccessScope,\n  ekArrayDestructuring,\n  ekArrayBindingPattern,\n  ekObjectBindingPattern,\n  ekBindingIdentifier,\n  ekObjectDestructuring,\n  AccessBoundaryExpression,\n  AssignmentOperator,\n} from './ast';\nimport { createLookup } from './utilities';\nimport { ErrorNames, createMappedError } from './errors';\nimport { createImplementationRegister, DI } from '@aurelia/kernel';\n\nexport interface IExpressionParser<TCustom extends CustomExpression = CustomExpression> {\n  parse(expression: string, expressionType: 'IsIterator'): ForOfStatement;\n  parse(expression: string, expressionType: 'Interpolation'): Interpolation;\n  parse(expression: string, expressionType: Exclude<ExpressionType, 'IsIterator' | 'Interpolation'>): IsBindingBehavior;\n  parse(expression: string, expressionType: ExpressionType): AnyBindingExpression<TCustom>;\n}\nexport const IExpressionParser = /*@__PURE__*/DI.createInterface<IExpressionParser>('IExpressionParser');\n\n/**\n * A default implementation of the IExpressionParser interface\n */\nexport class ExpressionParser<TCustom extends CustomExpression = CustomExpression> implements IExpressionParser<TCustom> {\n  public static readonly register = createImplementationRegister(IExpressionParser);\n\n  /** @internal */ private readonly _expressionLookup: Record<string, IsBindingBehavior> = createLookup();\n  /** @internal */ private readonly _forOfLookup: Record<string, ForOfStatement> = createLookup();\n  /** @internal */ private readonly _interpolationLookup: Record<string, Interpolation> = createLookup();\n\n  public parse(expression: string, expressionType: 'IsIterator'): ForOfStatement;\n  public parse(expression: string, expressionType: 'Interpolation'): Interpolation;\n  public parse(expression: string, expressionType: Exclude<ExpressionType, 'IsIterator' | 'Interpolation'>): IsBindingBehavior;\n  public parse(expression: string, expressionType: ExpressionType): AnyBindingExpression;\n  public parse(expression: string, expressionType: ExpressionType): AnyBindingExpression {\n    let found: AnyBindingExpression;\n    switch (expressionType) {\n      case etIsCustom:\n        return new CustomExpression(expression) as AnyBindingExpression;\n      case etInterpolation:\n        found = this._interpolationLookup[expression];\n        if (found === void 0) {\n          found = this._interpolationLookup[expression] = this.$parse(expression, expressionType);\n        }\n        return found;\n      case etIsIterator:\n        found = this._forOfLookup[expression];\n        if (found === void 0) {\n          found = this._forOfLookup[expression] = this.$parse(expression, expressionType);\n        }\n        return found;\n      default: {\n        if (expression.length === 0) {\n          if (expressionType === etIsFunction || expressionType === etIsProperty) {\n            return PrimitiveLiteralExpression.$empty;\n          }\n          throw invalidEmptyExpression();\n        }\n        found = this._expressionLookup[expression];\n        if (found === void 0) {\n          found = this._expressionLookup[expression] = this.$parse(expression, expressionType);\n        }\n        return found;\n      }\n    }\n  }\n\n  /** @internal */\n  private $parse(expression: string, expressionType: 'IsIterator'): ForOfStatement;\n  /** @internal */\n  private $parse(expression: string, expressionType: 'Interpolation'): Interpolation;\n  /** @internal */\n  private $parse(expression: string, expressionType: Exclude<ExpressionType, 'IsIterator' | 'Interpolation'>): IsBindingBehavior;\n  /** @internal */\n  private $parse(expression: string, expressionType: ExpressionType): AnyBindingExpression {\n    $input = expression;\n    $index = 0;\n    $length = expression.length;\n    $scopeDepth = 0;\n    $startIndex = 0;\n    $currentToken = Token.EOF;\n    $tokenValue = '';\n    $currentChar = $charCodeAt(0);\n    $assignable = true;\n    $optional = false;\n    $accessGlobal = true;\n    $semicolonIndex = -1;\n    return parse(Precedence.Variadic, expressionType === void 0 ? etIsProperty : expressionType);\n  }\n}\n\n_START_CONST_ENUM();\nconst enum Char {\n  Null           = 0x00,\n  Backspace      = 0x08,\n  Tab            = 0x09,\n  LineFeed       = 0x0A,\n  VerticalTab    = 0x0B,\n  FormFeed       = 0x0C,\n  CarriageReturn = 0x0D,\n  Space          = 0x20,\n  Exclamation    = 0x21,\n  DoubleQuote    = 0x22,\n  Dollar         = 0x24,\n  Percent        = 0x25,\n  Ampersand      = 0x26,\n  SingleQuote    = 0x27,\n  OpenParen      = 0x28,\n  CloseParen     = 0x29,\n  Asterisk       = 0x2A,\n  Plus           = 0x2B,\n  Comma          = 0x2C,\n  Minus          = 0x2D,\n  Dot            = 0x2E,\n  Slash          = 0x2F,\n  Semicolon      = 0x3B,\n  Backtick       = 0x60,\n  OpenBracket    = 0x5B,\n  Backslash      = 0x5C,\n  CloseBracket   = 0x5D,\n  Caret          = 0x5E,\n  Underscore     = 0x5F,\n  OpenBrace      = 0x7B,\n  Bar            = 0x7C,\n  CloseBrace     = 0x7D,\n  Colon          = 0x3A,\n  LessThan       = 0x3C,\n  Equals         = 0x3D,\n  GreaterThan    = 0x3E,\n  Question       = 0x3F,\n\n  Zero   = 0x30,\n  One    = 0x31,\n  Two    = 0x32,\n  Three  = 0x33,\n  Four   = 0x34,\n  Five   = 0x35,\n  Six    = 0x36,\n  Seven  = 0x37,\n  Eight  = 0x38,\n  Nine   = 0x39,\n\n  UpperA = 0x41,\n  UpperB = 0x42,\n  UpperC = 0x43,\n  UpperD = 0x44,\n  UpperE = 0x45,\n  UpperF = 0x46,\n  UpperG = 0x47,\n  UpperH = 0x48,\n  UpperI = 0x49,\n  UpperJ = 0x4A,\n  UpperK = 0x4B,\n  UpperL = 0x4C,\n  UpperM = 0x4D,\n  UpperN = 0x4E,\n  UpperO = 0x4F,\n  UpperP = 0x50,\n  UpperQ = 0x51,\n  UpperR = 0x52,\n  UpperS = 0x53,\n  UpperT = 0x54,\n  UpperU = 0x55,\n  UpperV = 0x56,\n  UpperW = 0x57,\n  UpperX = 0x58,\n  UpperY = 0x59,\n  UpperZ = 0x5A,\n\n  LowerA  = 0x61,\n  LowerB  = 0x62,\n  LowerC  = 0x63,\n  LowerD  = 0x64,\n  LowerE  = 0x65,\n  LowerF  = 0x66,\n  LowerG  = 0x67,\n  LowerH  = 0x68,\n  LowerI  = 0x69,\n  LowerJ  = 0x6A,\n  LowerK  = 0x6B,\n  LowerL  = 0x6C,\n  LowerM  = 0x6D,\n  LowerN  = 0x6E,\n  LowerO  = 0x6F,\n  LowerP  = 0x70,\n  LowerQ  = 0x71,\n  LowerR  = 0x72,\n  LowerS  = 0x73,\n  LowerT  = 0x74,\n  LowerU  = 0x75,\n  LowerV  = 0x76,\n  LowerW  = 0x77,\n  LowerX  = 0x78,\n  LowerY  = 0x79,\n  LowerZ  = 0x7A\n}\n_END_CONST_ENUM();\n\nfunction unescapeCode(code: number): number {\n  switch (code) {\n    case Char.LowerB: return Char.Backspace;\n    case Char.LowerT: return Char.Tab;\n    case Char.LowerN: return Char.LineFeed;\n    case Char.LowerV: return Char.VerticalTab;\n    case Char.LowerF: return Char.FormFeed;\n    case Char.LowerR: return Char.CarriageReturn;\n    case Char.DoubleQuote: return Char.DoubleQuote;\n    case Char.SingleQuote: return Char.SingleQuote;\n    case Char.Backslash: return Char.Backslash;\n    default: return code;\n  }\n}\n\n_START_CONST_ENUM();\nconst enum Precedence {\n  Variadic                = 0b0000_111101,\n  Assign                  = 0b0000_111110,\n  Conditional             = 0b0000_111111,\n  Assignment              = 0b0001_000000,\n  NullishCoalescing       = 0b0010_000000,\n  LogicalOR               = 0b0011_000000,\n  LogicalAND              = 0b0100_000000,\n  Equality                = 0b0101_000000,\n  Relational              = 0b0110_000000,\n  Additive                = 0b0111_000000,\n  Multiplicative          = 0b1000_000000,\n  Binary                  = 0b1000_000001,\n  LeftHandSide            = 0b1000_000010,\n  Primary                 = 0b1000_000011,\n  Unary                   = 0b1000_000100,\n}\n_END_CONST_ENUM();\n\n_START_CONST_ENUM();\nconst enum Token {\n  EOF                     = 0b1100000000000_0000_000000,\n  ExpressionTerminal      = 0b1000000000000_0000_000000,\n  AccessScopeTerminal     = 0b0100000000000_0000_000000,\n  ClosingToken            = 0b0010000000000_0000_000000,\n  OpeningToken            = 0b0001000000000_0000_000000,\n  BinaryOp                = 0b0000100000000_0000_000000,\n  UnaryOp                 = 0b0000010000000_0000_000000,\n  LeftHandSide            = 0b0000001000000_0000_000000,\n  StringOrNumericLiteral  = 0b0000000110000_0000_000000,\n  NumericLiteral          = 0b0000000100000_0000_000000,\n  StringLiteral           = 0b0000000010000_0000_000000,\n  IdentifierName          = 0b0000000001100_0000_000000,\n  // Keyword                 = 0b0000000001000_0000_000000,\n  Identifier              = 0b0000000000100_0000_000000,\n  Contextual              = 0b0000000000010_0000_000000,\n  OptionalSuffix          = 0b0000000001101_0000_000000,\n  Precedence              = 0b0000000000000_1111_000000,\n  Type                    = 0b0000000000000_0000_111111,\n  FalseKeyword            = 0b0000000001000_0000_000000,\n  TrueKeyword             = 0b0000000001000_0000_000001,\n  NullKeyword             = 0b0000000001000_0000_000010,\n  UndefinedKeyword        = 0b0000000001000_0000_000011,\n  ThisScope               = 0b0000000001100_0000_000100,\n  AccessBoundary          = 0b0000000001100_0000_000101,\n  // HostScope            = 0b0000000001100_0000_000110,\n  ParentScope             = 0b0000000001100_0000_000111,\n  OpenParen               = 0b0101001000001_0000_001000,\n  OpenBrace               = 0b0001000000000_0000_001001,\n  Dot                     = 0b0000001000000_0000_001010,\n  DotDot                  = 0b0000000000000_0000_001011,\n  DotDotDot               = 0b0000000000000_0000_001100,\n  QuestionDot             = 0b0100001000000_0000_001101,\n  CloseBrace              = 0b1110000000000_0000_001110,\n  CloseParen              = 0b1110000000000_0000_001111,\n  Comma                   = 0b1100000000000_0000_010000,\n  OpenBracket             = 0b0101001000001_0000_010011,\n  CloseBracket            = 0b1110000000000_0000_010100,\n  Colon                   = 0b1100000000000_0000_010101,\n  Semicolon               = 0b1100000000000_0000_010110,\n  Question                = 0b1100000000000_0000_010111,\n  Ampersand               = 0b1100000000000_0000_011000,\n  Bar                     = 0b1100000000000_0000_011001,\n  QuestionQuestion        = 0b1100100000000_0010_011010,\n  BarBar                  = 0b1100100000000_0011_011011,\n  AmpersandAmpersand      = 0b1100100000000_0100_011100,\n  EqualsEquals            = 0b1100100000000_0101_011101,\n  ExclamationEquals       = 0b1100100000000_0101_011110,\n  EqualsEqualsEquals      = 0b1100100000000_0101_011111,\n  ExclamationEqualsEquals = 0b1100100000000_0101_100000,\n  LessThan                = 0b1100100000000_0110_100001,\n  GreaterThan             = 0b1100100000000_0110_100010,\n  LessThanEquals          = 0b1100100000000_0110_100011,\n  GreaterThanEquals       = 0b1100100000000_0110_100100,\n  InKeyword               = 0b1100100001000_0110_100101,\n  InstanceOfKeyword       = 0b1100100001000_0110_100110,\n  Plus                    = 0b0100110000000_0111_100111,\n  Minus                   = 0b0100110000000_0111_101000,\n  TypeofKeyword           = 0b0000010001000_0000_101001,\n  VoidKeyword             = 0b0000010001000_0000_101010,\n  Asterisk                = 0b1100100000000_1000_101011,\n  Percent                 = 0b1100100000000_1000_101100,\n  Slash                   = 0b1100100000000_1000_101101,\n  Equals                  = 0b1000000000000_0000_101110,\n  Exclamation             = 0b0000010000000_0000_101111,\n  TemplateTail            = 0b0100001000001_0000_110000,\n  TemplateContinuation    = 0b0100001000001_0000_110001,\n  OfKeyword               = 0b1000000001010_0000_110010,\n  Arrow                   = 0b0000000000000_0000_110011,\n  PlusEquals              = 0b1000000000000_0000_110100,\n  MinusEquals             = 0b1000000000000_0000_110101,\n  AsteriskEquals          = 0b1000000000000_0000_110110,\n  SlashEquals             = 0b1000000000000_0000_110111,\n  PlusPlus                = 0b0100010000000_0000_111000,\n  MinusMinus              = 0b0100010000000_0000_111001,\n}\n_END_CONST_ENUM();\n\nconst $false = PrimitiveLiteralExpression.$false;\nconst $true = PrimitiveLiteralExpression.$true;\nconst $null = PrimitiveLiteralExpression.$null;\nconst $undefined = PrimitiveLiteralExpression.$undefined;\nconst $this = new AccessThisExpression(0);\nconst $parent = new AccessThisExpression(1);\nconst boundary = new AccessBoundaryExpression();\n\nconst etNone = 'None';\nconst etInterpolation = 'Interpolation';\nconst etIsIterator = 'IsIterator';\nconst etIsChainable = 'IsChainable';\nconst etIsFunction = 'IsFunction';\nconst etIsProperty = 'IsProperty';\nconst etIsCustom = 'IsCustom';\nexport type ExpressionType = 'None' | 'Interpolation' | 'IsIterator' | 'IsChainable' | 'IsFunction' | 'IsProperty' | 'IsCustom';\n\nlet $input: string = '';\nlet $index: number = 0;\nlet $length: number = 0;\nlet $scopeDepth: number = 0;\nlet $startIndex: number = 0;\nlet $currentToken: Token = Token.EOF;\nlet $tokenValue: string | number = '';\nlet $currentChar: number;\nlet $assignable: boolean = true;\nlet $optional: boolean = false;\nlet $accessGlobal: boolean = true;\nlet $semicolonIndex: number = -1;\n\nconst stringFromCharCode = String.fromCharCode;\nconst $charCodeAt = (index: number) => $input.charCodeAt(index);\n\nconst $tokenRaw = (): string => $input.slice($startIndex, $index);\n\nconst globalNames =\n  ('Infinity NaN isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent' +\n  ' Array BigInt Boolean Date Map Number Object RegExp Set String JSON Math Intl').split(' ');\n\nexport function parseExpression(input: string, expressionType?: ExpressionType): AnyBindingExpression {\n  $input = input;\n  $index = 0;\n  $length = input.length;\n  $scopeDepth = 0;\n  $startIndex = 0;\n  $currentToken = Token.EOF;\n  $tokenValue = '';\n  $currentChar = $charCodeAt(0);\n  $assignable = true;\n  $optional = false;\n  $accessGlobal = true;\n  $semicolonIndex = -1;\n  return parse(Precedence.Variadic, expressionType === void 0 ? etIsProperty : expressionType);\n}\n\n// This is performance-critical code which follows a subset of the well-known ES spec.\n// Knowing the spec, or parsers in general, will help with understanding this code and it is therefore not the\n// single source of information for being able to figure it out.\n// It generally does not need to change unless the spec changes or spec violations are found, or optimization\n// opportunities are found (which would likely not fix these warnings in any case).\n// It's therefore not considered to have any tangible impact on the maintainability of the code base.\n// For reference, most of the parsing logic is based on: https://tc39.github.io/ecma262/#sec-ecmascript-language-expressions\n// eslint-disable-next-line max-lines-per-function\nexport function parse(minPrecedence: Precedence, expressionType: ExpressionType): AnyBindingExpression {\n  if (expressionType === etIsCustom) {\n    return new CustomExpression($input);\n  }\n\n  if ($index === 0) {\n    if (expressionType === etInterpolation) {\n      return parseInterpolation();\n    }\n    nextToken();\n    if ($currentToken & Token.ExpressionTerminal) {\n      throw invalidStartOfExpression();\n    }\n  }\n\n  $assignable = Precedence.Binary > minPrecedence;\n  $optional = false;\n  $accessGlobal = Precedence.LeftHandSide > minPrecedence;\n  let optionalThisTail = false;\n  let result = void 0 as unknown as IsExpressionOrStatement;\n  let ancestor = 0;\n\n  if ($currentToken & Token.UnaryOp) {\n    /**\n     * parseUnaryExpression\n     *\n     * https://tc39.github.io/ecma262/#sec-unary-operators\n     *\n     * UnaryExpression :\n     * 1. LeftHandSideExpression\n     * 2. void UnaryExpression\n     * 3. typeof UnaryExpression\n     * 4. + UnaryExpression\n     * 5. - UnaryExpression\n     * 6. ! UnaryExpression\n     * 7. ++ UnaryExpression\n     * 8. -- UnaryExpression\n     *\n     * IsValidAssignmentTarget\n     * 2,3,4,5,6,7,8 = false\n     * 1 = see parseLeftHandSideExpression\n     *\n     * Note: technically we should throw on +++ / ---, but there's nothing to gain from that\n     */\n    const op = TokenValues[$currentToken & Token.Type] as UnaryOperator;\n    nextToken();\n    result = new UnaryExpression(op, parse(Precedence.LeftHandSide, expressionType) as IsLeftHandSide);\n    $assignable = false;\n  } else {\n    /**\n     * parsePrimaryExpression\n     *\n     * https://tc39.github.io/ecma262/#sec-primary-expression\n     *\n     * PrimaryExpression :\n     * 1. this\n     * 2. IdentifierName\n     * 3. Literal\n     * 4. ArrayLiteralExpression\n     * 5. ObjectLiteralExpression\n     * 6. TemplateLiteral\n     * 7. ParenthesizedExpression\n     *\n     * Literal :\n     * NullLiteral\n     * BooleanLiteral\n     * NumericLiteral\n     * StringLiteral\n     *\n     * ParenthesizedExpression :\n     * ( AssignmentExpression )\n     *\n     * IsValidAssignmentTarget\n     * 1,3,4,5,6,7 = false\n     * 2 = true\n     */\n    primary: switch ($currentToken) {\n      case Token.ParentScope: // $parent\n        ancestor = $scopeDepth;\n        $assignable = false;\n        $accessGlobal = false;\n        do {\n          nextToken();\n          ++ancestor;\n          switch (($currentToken as Token)) {\n            case Token.Dot:\n              nextToken();\n              if (($currentToken & Token.IdentifierName) === 0) {\n                throw expectedIdentifier();\n              }\n              break;\n            case Token.DotDot:\n            case Token.DotDotDot:\n              throw expectedIdentifier();\n            case Token.QuestionDot:\n              $optional = true;\n              nextToken();\n              if (($currentToken & Token.IdentifierName) === 0) {\n                result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new AccessThisExpression(ancestor);\n                optionalThisTail = true;\n                break primary;\n              }\n              break;\n            default:\n              if ($currentToken & Token.AccessScopeTerminal) {\n                result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new AccessThisExpression(ancestor);\n                break primary;\n              }\n              throw invalidMemberExpression();\n          }\n        } while ($currentToken === Token.ParentScope);\n        // falls through\n      case Token.Identifier: { // identifier\n        const id = $tokenValue as string;\n        if (expressionType === etIsIterator) {\n          result = new BindingIdentifier(id);\n        } else if ($accessGlobal && globalNames.includes(id as (typeof globalNames)[number])) {\n          result = new AccessGlobalExpression(id);\n        } else if ($accessGlobal && id === 'import') {\n          throw unexpectedImportKeyword();\n        } else {\n          result = new AccessScopeExpression(id, ancestor);\n        }\n        $assignable = !$optional;\n        nextToken();\n        if (consumeOpt(Token.Arrow)) {\n          if (($currentToken as Token) === Token.OpenBrace) {\n            throw functionBodyInArrowFn();\n          }\n          const _optional = $optional;\n          const _scopeDepth = $scopeDepth;\n          ++$scopeDepth;\n          const body = parse(Precedence.Assign, etNone) as IsAssign;\n          $optional = _optional;\n          $scopeDepth = _scopeDepth;\n          $assignable = false;\n          result = new ArrowFunction([new BindingIdentifier(id)], body);\n        }\n        break;\n      }\n      case Token.DotDot:\n        throw unexpectedDoubleDot();\n      case Token.DotDotDot:\n        throw invalidSpreadOp();\n      case Token.ThisScope: // $this\n        $assignable = false;\n        nextToken();\n        switch ($scopeDepth) {\n          case 0:\n            result = $this;\n            break;\n          case 1:\n            result = $parent;\n            break;\n          default:\n            result = new AccessThisExpression($scopeDepth);\n            break;\n        }\n        break;\n      case Token.AccessBoundary: // this\n        $assignable = false;\n        nextToken();\n        result = boundary;\n        break;\n      case Token.OpenParen:\n        result = parseCoverParenthesizedExpressionAndArrowParameterList(expressionType);\n        break;\n      case Token.OpenBracket:\n        result = $input.search(/\\s+of\\s+/) > $index ? parseArrayDestructuring() : parseArrayLiteralExpression(expressionType);\n        break;\n      case Token.OpenBrace:\n        result = parseObjectLiteralExpression(expressionType);\n        break;\n      case Token.TemplateTail:\n        result = new TemplateExpression([$tokenValue as string]);\n        $assignable = false;\n        nextToken();\n        break;\n      case Token.TemplateContinuation:\n        result = parseTemplate(expressionType, result as IsLeftHandSide, false);\n        break;\n      case Token.StringLiteral:\n      case Token.NumericLiteral:\n        result = new PrimitiveLiteralExpression($tokenValue);\n        $assignable = false;\n        nextToken();\n        break;\n      case Token.NullKeyword:\n      case Token.UndefinedKeyword:\n      case Token.TrueKeyword:\n      case Token.FalseKeyword:\n        result = TokenValues[$currentToken & Token.Type] as PrimitiveLiteralExpression;\n        $assignable = false;\n        nextToken();\n        break;\n      default:\n        if ($index >= $length) {\n          throw unexpectedEndOfExpression();\n        } else {\n          throw unconsumedToken();\n        }\n    }\n\n    if (expressionType === etIsIterator) {\n      return parseForOfStatement(result as BindingIdentifierOrPattern);\n    }\n    switch ($currentToken as Token) {\n      case Token.PlusPlus:\n      case Token.MinusMinus:\n        result = new UnaryExpression(TokenValues[$currentToken & Token.Type] as UnaryOperator, result as IsLeftHandSide, 1);\n        nextToken();\n        $assignable = false;\n        break;\n    }\n    if (Precedence.LeftHandSide < minPrecedence) {\n      return result as any;\n    }\n\n    if (($currentToken as Token) === Token.DotDot || ($currentToken as Token) === Token.DotDotDot) {\n      throw expectedIdentifier();\n    }\n\n    if (result.$kind === ekAccessThis) {\n      switch ($currentToken as Token) {\n        case Token.QuestionDot:\n          $optional = true;\n          $assignable = false;\n          nextToken();\n          if (($currentToken & Token.OptionalSuffix) === 0) {\n            throw unexpectedTokenInOptionalChain();\n          }\n\n          if ($currentToken & Token.IdentifierName) {\n            result = new AccessScopeExpression($tokenValue as string, result.ancestor);\n            nextToken();\n          } else if (($currentToken as Token) === Token.OpenParen) {\n            result = new CallFunctionExpression(result as IsLeftHandSide, parseArguments(), true);\n          } else if (($currentToken as Token) === Token.OpenBracket) {\n            result = parseKeyedExpression(result, true);\n          } else {\n            throw invalidTaggedTemplateOnOptionalChain();\n          }\n          break;\n        case Token.Dot:\n          $assignable = !$optional;\n          nextToken();\n          if (($currentToken & Token.IdentifierName) === 0) {\n            throw expectedIdentifier();\n          }\n          result = new AccessScopeExpression($tokenValue as string, result.ancestor);\n          nextToken();\n          break;\n        case Token.DotDot:\n        case Token.DotDotDot:\n          throw expectedIdentifier();\n        case Token.OpenParen:\n          result = new CallFunctionExpression(result as IsLeftHandSide, parseArguments(), optionalThisTail);\n          break;\n        case Token.OpenBracket:\n          result = parseKeyedExpression(result, optionalThisTail);\n          break;\n        case Token.TemplateTail:\n          result = createTemplateTail(result as IsLeftHandSide);\n          break;\n        case Token.TemplateContinuation:\n          result = parseTemplate(expressionType, result as IsLeftHandSide, true);\n          break;\n      }\n    }\n\n    /**\n     * parseMemberExpression (Token.Dot, Token.OpenBracket, Token.TemplateContinuation)\n     *\n     * MemberExpression :\n     * 1. PrimaryExpression\n     * 2. MemberExpression [ AssignmentExpression ]\n     * 3. MemberExpression . IdentifierName\n     * 4. MemberExpression TemplateLiteral\n     *\n     * IsValidAssignmentTarget\n     * 1,4 = false\n     * 2,3 = true\n     *\n     *\n     * parseCallExpression (Token.OpenParen)\n     * CallExpression :\n     * 1. MemberExpression Arguments\n     * 2. CallExpression Arguments\n     * 3. CallExpression [ AssignmentExpression ]\n     * 4. CallExpression . IdentifierName\n     * 5. CallExpression TemplateLiteral\n     *\n     * IsValidAssignmentTarget\n     * 1,2,5 = false\n     * 3,4 = true\n     */\n    while (($currentToken & Token.LeftHandSide) > 0) {\n      switch (($currentToken as Token)) {\n        case Token.QuestionDot:\n          result = parseOptionalChainLHS(result as IsLeftHandSide);\n          break;\n        case Token.Dot:\n          nextToken();\n          if (($currentToken & Token.IdentifierName) === 0) {\n            throw expectedIdentifier();\n          }\n          result = parseMemberExpressionLHS(result as IsLeftHandSide, false);\n          break;\n        case Token.DotDot:\n        case Token.DotDotDot:\n          throw expectedIdentifier();\n        case Token.OpenParen:\n          if (result.$kind === ekAccessScope) {\n            result = new CallScopeExpression(result.name, parseArguments(), result.ancestor, false);\n          } else if (result.$kind === ekAccessMember) {\n            result = new CallMemberExpression(result.object, result.name, parseArguments(), result.optional, false);\n          } else if (result.$kind === ekAccessGlobal) {\n            result = new CallGlobalExpression(result.name, parseArguments());\n          } else {\n            result = new CallFunctionExpression(result as IsLeftHandSide, parseArguments(), false);\n          }\n          break;\n        case Token.OpenBracket:\n          result = parseKeyedExpression(result as IsLeftHandSide, false);\n          break;\n        case Token.TemplateTail:\n          if ($optional) {\n            throw invalidTaggedTemplateOnOptionalChain();\n          }\n          result = createTemplateTail(result as IsLeftHandSide);\n          break;\n        case Token.TemplateContinuation:\n          if ($optional) {\n            throw invalidTaggedTemplateOnOptionalChain();\n          }\n          result = parseTemplate(expressionType, result as IsLeftHandSide, true);\n          break;\n      }\n    }\n  }\n\n  if (($currentToken as Token) === Token.DotDot || ($currentToken as Token) === Token.DotDotDot) {\n    throw expectedIdentifier();\n  }\n\n  if (Precedence.Binary < minPrecedence) {\n    return result as any;\n  }\n\n  /**\n   * parseBinaryExpression\n   *\n   * https://tc39.github.io/ecma262/#sec-multiplicative-operators\n   *\n   * MultiplicativeExpression : (local precedence 6)\n   * UnaryExpression\n   * MultiplicativeExpression * / % UnaryExpression\n   *\n   * AdditiveExpression : (local precedence 5)\n   * MultiplicativeExpression\n   * AdditiveExpression + - MultiplicativeExpression\n   *\n   * RelationalExpression : (local precedence 4)\n   * AdditiveExpression\n   * RelationalExpression < > <= >= instanceof in AdditiveExpression\n   *\n   * EqualityExpression : (local precedence 3)\n   * RelationalExpression\n   * EqualityExpression == != === !== RelationalExpression\n   *\n   * LogicalANDExpression : (local precedence 2)\n   * EqualityExpression\n   * LogicalANDExpression && EqualityExpression\n   *\n   * LogicalORExpression : (local precedence 1)\n   * LogicalANDExpression\n   * LogicalORExpression || LogicalANDExpression\n   *\n   * CoalesceExpression :\n   * CoalesceExpressionHead ?? BitwiseORExpression\n   *\n   * CoalesceExpressionHead :\n   * CoelesceExpression\n   * BitwiseORExpression\n   *\n   * ShortCircuitExpression :\n   * LogicalORExpression\n   * CoalesceExpression\n   */\n  while (($currentToken & Token.BinaryOp) > 0) {\n    const opToken = $currentToken;\n    if ((opToken & Token.Precedence) <= minPrecedence) {\n      break;\n    }\n    nextToken();\n    result = new BinaryExpression(TokenValues[opToken & Token.Type] as BinaryOperator, result as IsBinary, parse(opToken & Token.Precedence, expressionType) as IsBinary);\n    $assignable = false;\n  }\n  if (Precedence.Conditional < minPrecedence) {\n    return result as any;\n  }\n\n  /**\n   * parseConditionalExpression\n   * https://tc39.github.io/ecma262/#prod-ConditionalExpression\n   *\n   * ConditionalExpression :\n   * 1. ShortCircuitExpression\n   * 2. ShortCircuitExpression ? AssignmentExpression : AssignmentExpression\n   *\n   * IsValidAssignmentTarget\n   * 1,2 = false\n   */\n\n  if (consumeOpt(Token.Question)) {\n    const yes = parse(Precedence.Assign, expressionType) as IsAssign;\n    consume(Token.Colon);\n    result = new ConditionalExpression(result as IsBinary, yes, parse(Precedence.Assign, expressionType) as IsAssign);\n    $assignable = false;\n  }\n  if (Precedence.Assign < minPrecedence) {\n    return result as any;\n  }\n\n  /**\n   * parseAssignmentExpression\n   *\n   * https://tc39.github.io/ecma262/#prod-AssignmentExpression\n   * Note: AssignmentExpression here is equivalent to ES Expression because we don't parse the comma operator\n   *\n   * AssignmentExpression :\n   * 1. ConditionalExpression\n   * 2. LeftHandSideExpression = AssignmentExpression\n   * 3. LeftHandSideExpression AssignmentOperator AssignmentExpression\n   *\n   * IsValidAssignmentTarget\n   * 1,2 = false\n   */\n\n  switch ($currentToken as Token) {\n    case Token.Equals:\n    case Token.PlusEquals:\n    case Token.MinusEquals:\n    case Token.AsteriskEquals:\n    case Token.SlashEquals: {\n      if (!$assignable) {\n        throw lhsNotAssignable();\n      }\n      const op = TokenValues[$currentToken & Token.Type] as AssignmentOperator;\n      nextToken();\n      result = new AssignExpression(result as IsAssignable, parse(Precedence.Assign, expressionType) as IsAssign, op);\n      break;\n    }\n  }\n  if (Precedence.Variadic < minPrecedence) {\n    return result as any;\n  }\n\n  /**\n   * parseValueConverter\n   */\n  while (consumeOpt(Token.Bar)) {\n    if ($currentToken === Token.EOF) {\n      throw expectedValueConverterIdentifier();\n    }\n    const name = $tokenValue as string;\n    nextToken();\n    const args = new Array<IsAssign>();\n    while (consumeOpt(Token.Colon)) {\n      args.push(parse(Precedence.Assign, expressionType) as IsAssign);\n    }\n    result = new ValueConverterExpression(result as IsValueConverter, name, args);\n  }\n\n  /**\n   * parseBindingBehavior\n   */\n  while (consumeOpt(Token.Ampersand)) {\n    if ($currentToken === Token.EOF) {\n      throw expectedBindingBehaviorIdentifier();\n    }\n    const name = $tokenValue as string;\n    nextToken();\n    const args = new Array<IsAssign>();\n    while (consumeOpt(Token.Colon)) {\n      args.push(parse(Precedence.Assign, expressionType) as IsAssign);\n    }\n    result = new BindingBehaviorExpression(result as IsBindingBehavior, name, args);\n  }\n\n  if ($currentToken !== Token.EOF) {\n    if (expressionType === etInterpolation && $currentToken === Token.CloseBrace) {\n      return result as any;\n    }\n    if (expressionType === etIsChainable && $currentToken === Token.Semicolon) {\n      if ($index === $length) {\n        throw unconsumedToken();\n      }\n      $semicolonIndex = $index - 1;\n      return result as any;\n    }\n    if ($tokenRaw() === 'of') {\n      throw unexpectedOfKeyword();\n    }\n    throw unconsumedToken();\n  }\n  return result as any;\n}\n\n/**\n * [key,]\n * [key]\n * [,value]\n * [key,value]\n */\nfunction parseArrayDestructuring(): DAE {\n  const items: DASE[] = [];\n  const dae = new DAE(ekArrayDestructuring, items, void 0, void 0);\n  let target: string = '';\n  let $continue = true;\n  let index = 0;\n  while ($continue) {\n    nextToken();\n    switch ($currentToken) {\n      case Token.CloseBracket:\n        $continue = false;\n        addItem();\n        break;\n      case Token.Comma:\n        addItem();\n        break;\n      case Token.Identifier:\n        target = $tokenRaw();\n        break;\n      default:\n        throw unexpectedTokenInDestructuring();\n    }\n  }\n  consume(Token.CloseBracket);\n  return dae;\n\n  function addItem() {\n    if (target !== '') {\n      items.push(new DASE(new AccessMemberExpression($this, target), new AccessKeyedExpression($this, new PrimitiveLiteralExpression(index++)), void 0));\n      target = '';\n    } else {\n      index++;\n    }\n  }\n}\n\nfunction parseArguments() {\n  const _optional = $optional;\n\n  nextToken();\n  const args: IsAssign[] = [];\n  while (($currentToken as Token) !== Token.CloseParen) {\n    args.push(parse(Precedence.Assign, etNone) as IsAssign);\n    if (!consumeOpt(Token.Comma)) {\n      break;\n    }\n  }\n  consume(Token.CloseParen);\n\n  $assignable = false;\n  $optional = _optional;\n\n  return args;\n}\n\nfunction parseKeyedExpression(result: IsLeftHandSide, optional: boolean) {\n  const _optional = $optional;\n\n  nextToken();\n  result = new AccessKeyedExpression(result, parse(Precedence.Assign, etNone) as IsAssign, optional);\n  consume(Token.CloseBracket);\n\n  $assignable = !_optional;\n  $optional = _optional;\n\n  return result;\n}\n\nfunction parseOptionalChainLHS(lhs: IsLeftHandSide) {\n  $optional = true;\n  $assignable = false;\n  nextToken();\n  if (($currentToken & Token.OptionalSuffix) === 0) {\n    throw unexpectedTokenInOptionalChain();\n  }\n\n  if ($currentToken & Token.IdentifierName) {\n    return parseMemberExpressionLHS(lhs, true);\n  }\n\n  if (($currentToken as Token) === Token.OpenParen) {\n    if (lhs.$kind === ekAccessScope) {\n      return new CallScopeExpression(lhs.name, parseArguments(), lhs.ancestor, true);\n    } else if (lhs.$kind === ekAccessMember) {\n      return new CallMemberExpression(lhs.object, lhs.name, parseArguments(), lhs.optional, true);\n    } else {\n      return new CallFunctionExpression(lhs, parseArguments(), true);\n    }\n  }\n\n  if (($currentToken as Token) === Token.OpenBracket) {\n    return parseKeyedExpression(lhs, true);\n  }\n\n  throw invalidTaggedTemplateOnOptionalChain();\n}\n\nfunction parseMemberExpressionLHS(lhs: IsLeftHandSide, optional: boolean) {\n  const rhs = $tokenValue as string;\n  switch (($currentToken as Token)) {\n    case Token.QuestionDot: {\n      $optional = true;\n      $assignable = false;\n\n      const indexSave = $index;\n      const startIndexSave = $startIndex;\n      const currentTokenSave = $currentToken;\n      const currentCharSave = $currentChar;\n      const tokenValueSave = $tokenValue;\n      const assignableSave = $assignable;\n      const optionalSave = $optional;\n\n      nextToken();\n      if (($currentToken & Token.OptionalSuffix) === 0) {\n        throw unexpectedTokenInOptionalChain();\n      }\n\n      if (($currentToken as Token) === Token.OpenParen) {\n        return new CallMemberExpression(lhs, rhs, parseArguments(), optional, true);\n      }\n\n      $index = indexSave;\n      $startIndex = startIndexSave;\n      $currentToken = currentTokenSave;\n      $currentChar = currentCharSave;\n      $tokenValue = tokenValueSave;\n      $assignable = assignableSave;\n      $optional = optionalSave;\n\n      return new AccessMemberExpression(lhs, rhs, optional);\n    }\n    case Token.OpenParen: {\n      $assignable = false;\n      return new CallMemberExpression(lhs, rhs, parseArguments(), optional, false);\n    }\n    default: {\n      $assignable = !$optional;\n      nextToken();\n      return new AccessMemberExpression(lhs, rhs, optional);\n    }\n  }\n}\n\n_START_CONST_ENUM();\nconst enum ArrowFnParams {\n  Valid         = 1,\n  Invalid       = 2,\n  Default       = 3,\n  Destructuring = 4,\n}\n_END_CONST_ENUM();\n\n/**\n * https://tc39.es/ecma262/#prod-CoverParenthesizedExpressionAndArrowParameterList\n * CoverParenthesizedExpressionAndArrowParameterList :\n * ( Expression )\n * ( )\n * ( BindingIdentifier )\n * ( Expression , BindingIdentifier )\n */\nfunction parseCoverParenthesizedExpressionAndArrowParameterList(expressionType: ExpressionType): IsAssign {\n  nextToken();\n\n  const indexSave = $index;\n  const startIndexSave = $startIndex;\n  const currentTokenSave = $currentToken;\n  const currentCharSave = $currentChar;\n  const tokenValueSave = $tokenValue;\n  const optionalSave = $optional;\n\n  const arrowParams: BindingIdentifier[] = [];\n  let paramsState = ArrowFnParams.Valid;\n  let isParamList = false;\n\n  // eslint-disable-next-line no-constant-condition\n  loop: while (true) {\n    if (($currentToken as Token) === Token.DotDotDot) {\n      nextToken();\n      if (($currentToken as Token) !== Token.Identifier) {\n        throw expectedIdentifier();\n      }\n      arrowParams.push(new BindingIdentifier($tokenValue as string));\n\n      nextToken();\n      if (($currentToken as Token) === Token.Comma) {\n        throw restParamsMustBeLastParam();\n      }\n\n      if (($currentToken as Token) !== Token.CloseParen) {\n        throw invalidSpreadOp();\n      }\n\n      nextToken();\n      if (($currentToken as Token) !== Token.Arrow) {\n        throw invalidSpreadOp();\n      }\n\n      nextToken();\n      const _optional = $optional;\n      const _scopeDepth = $scopeDepth;\n      ++$scopeDepth;\n      const body = parse(Precedence.Assign, etNone) as IsAssign;\n      $optional = _optional;\n      $scopeDepth = _scopeDepth;\n      $assignable = false;\n      return new ArrowFunction(arrowParams, body, true);\n    }\n\n    switch ($currentToken as Token) {\n      case Token.Identifier:\n        arrowParams.push(new BindingIdentifier($tokenValue as string));\n        nextToken();\n        break;\n      case Token.CloseParen:\n        // ()     - only valid if followed directly by an arrow\n        nextToken();\n        break loop;\n      /* eslint-disable */\n      case Token.OpenBrace:\n        // ({     - may be a valid parenthesized expression\n      case Token.OpenBracket:\n        // ([     - may be a valid parenthesized expression\n        nextToken();\n        paramsState = ArrowFnParams.Destructuring;\n        break;\n      /* eslint-enable */\n      case Token.Comma:\n        // (,     - never valid\n        // (a,,   - never valid\n        paramsState = ArrowFnParams.Invalid;\n        isParamList = true;\n        break loop;\n      case Token.OpenParen:\n        // ((     - may be a valid nested parenthesized expression or arrow fn\n        // (a,(   - never valid\n        paramsState = ArrowFnParams.Invalid;\n        break loop;\n      default:\n        nextToken();\n        paramsState = ArrowFnParams.Invalid;\n        break;\n    }\n\n    switch ($currentToken) {\n      case Token.Comma:\n        nextToken();\n        isParamList = true;\n        if (paramsState === ArrowFnParams.Valid) {\n          break;\n        }\n        // ([something invalid],   - treat as arrow fn / invalid arrow params\n        break loop;\n      case Token.CloseParen:\n        nextToken();\n        break loop;\n      case Token.Equals:\n        // (a=a     - may be a valid parenthesized expression\n        if (paramsState === ArrowFnParams.Valid) {\n          paramsState = ArrowFnParams.Default;\n        }\n        break loop;\n      case Token.Arrow:\n        // (a,a=>  - never valid\n        if (isParamList) {\n          throw invalidArrowParameterList();\n        }\n        // (a=>    - may be a valid parenthesized expression with nested arrow fn\n        nextToken();\n        paramsState = ArrowFnParams.Invalid;\n        break loop;\n      default:\n        if (paramsState === ArrowFnParams.Valid) {\n          paramsState = ArrowFnParams.Invalid;\n        }\n        break loop;\n    }\n  }\n\n  if ($currentToken === Token.Arrow) {\n    if (paramsState === ArrowFnParams.Valid) {\n      nextToken();\n      if (($currentToken as Token) === Token.OpenBrace) {\n        throw functionBodyInArrowFn();\n      }\n      const _optional = $optional;\n      const _scopeDepth = $scopeDepth;\n      ++$scopeDepth;\n      const body = parse(Precedence.Assign, etNone) as IsAssign;\n      $optional = _optional;\n      $scopeDepth = _scopeDepth;\n      $assignable = false;\n      return new ArrowFunction(arrowParams, body);\n    }\n    throw invalidArrowParameterList();\n  } else if (paramsState === ArrowFnParams.Valid && arrowParams.length === 0) {\n    // ()    - never valid as a standalone expression\n    throw missingExpectedToken(Token.Arrow);\n  }\n\n  if (isParamList) {\n    // ([something invalid],   - treat as arrow fn / invalid arrow params\n    switch (paramsState) {\n      case ArrowFnParams.Invalid:\n        throw invalidArrowParameterList();\n      case ArrowFnParams.Default:\n        throw defaultParamsInArrowFn();\n      case ArrowFnParams.Destructuring:\n        throw destructuringParamsInArrowFn();\n    }\n  }\n\n  $index = indexSave;\n  $startIndex = startIndexSave;\n  $currentToken = currentTokenSave;\n  $currentChar = currentCharSave;\n  $tokenValue = tokenValueSave;\n  $optional = optionalSave;\n\n  const _optional = $optional;\n  const expr = parse(Precedence.Assign, expressionType) as IsAssign;\n  $optional = _optional;\n  consume(Token.CloseParen);\n\n  if ($currentToken === Token.Arrow) {\n    // we only get here if there was a valid parenthesized expression which was not valid as arrow fn params\n    switch (paramsState) {\n      case ArrowFnParams.Invalid:\n        throw invalidArrowParameterList();\n      case ArrowFnParams.Default:\n        throw defaultParamsInArrowFn();\n      case ArrowFnParams.Destructuring:\n        throw destructuringParamsInArrowFn();\n    }\n  }\n\n  return expr;\n}\n\n/**\n * parseArrayLiteralExpression\n * https://tc39.github.io/ecma262/#prod-ArrayLiteralExpression\n *\n * ArrayLiteralExpression :\n * [ Elision(opt) ]\n * [ ElementList ]\n * [ ElementList, Elision(opt) ]\n *\n * ElementList :\n * Elision(opt) AssignmentExpression\n * ElementList, Elision(opt) AssignmentExpression\n *\n * Elision :\n * ,\n * Elision ,\n */\nfunction parseArrayLiteralExpression(expressionType: ExpressionType): ArrayBindingPattern | ArrayLiteralExpression {\n  const _optional = $optional;\n\n  nextToken();\n  const elements = new Array<IsAssign>();\n  while ($currentToken !== Token.CloseBracket) {\n    if (consumeOpt(Token.Comma)) {\n      elements.push($undefined);\n      if (($currentToken as Token) === Token.CloseBracket) {\n        break;\n      }\n    } else {\n      elements.push(parse(Precedence.Assign, expressionType === etIsIterator ? etNone : expressionType) as IsAssign);\n      if (consumeOpt(Token.Comma)) {\n        if (($currentToken as Token) === Token.CloseBracket) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n  $optional = _optional;\n\n  consume(Token.CloseBracket);\n  if (expressionType === etIsIterator) {\n    return new ArrayBindingPattern(elements);\n  } else {\n    $assignable = false;\n    return new ArrayLiteralExpression(elements);\n  }\n}\n\nconst allowedForExprKinds: ExpressionKind[] = [ekArrayBindingPattern, ekObjectBindingPattern, ekBindingIdentifier, ekArrayDestructuring, ekObjectDestructuring];\nfunction parseForOfStatement(result: BindingIdentifierOrPattern): ForOfStatement {\n  if (!allowedForExprKinds.includes(result.$kind)) {\n    throw invalidLHSBindingIdentifierInForOf(result.$kind);\n  }\n  if ($currentToken !== Token.OfKeyword) {\n    throw invalidLHSBindingIdentifierInForOf(result.$kind);\n  }\n  nextToken();\n  const declaration = result;\n  const statement = parse(Precedence.Variadic, etIsChainable);\n  return new ForOfStatement(declaration, statement as IsBindingBehavior, $semicolonIndex);\n}\n\n/**\n * parseObjectLiteralExpression\n * https://tc39.github.io/ecma262/#prod-Literal\n *\n * ObjectLiteralExpression :\n * { }\n * { PropertyDefinitionList }\n *\n * PropertyDefinitionList :\n * PropertyDefinition\n * PropertyDefinitionList, PropertyDefinition\n *\n * PropertyDefinition :\n * IdentifierName\n * PropertyName : AssignmentExpression\n *\n * PropertyName :\n * IdentifierName\n * StringLiteral\n * NumericLiteral\n */\nfunction parseObjectLiteralExpression(expressionType: ExpressionType): ObjectBindingPattern | ObjectLiteralExpression {\n  const _optional = $optional;\n\n  const keys = new Array<string | number>();\n  const values = new Array<IsAssign>();\n  nextToken();\n  while ($currentToken !== Token.CloseBrace) {\n    keys.push($tokenValue);\n    // Literal = mandatory colon\n    if ($currentToken & Token.StringOrNumericLiteral) {\n      nextToken();\n      consume(Token.Colon);\n      values.push(parse(Precedence.Assign, expressionType === etIsIterator ? etNone : expressionType) as IsAssign);\n    } else if ($currentToken & Token.IdentifierName) {\n      // IdentifierName = optional colon\n      const currentChar = $currentChar;\n      const currentToken = $currentToken;\n      const index = $index;\n      nextToken();\n      if (consumeOpt(Token.Colon)) {\n        values.push(parse(Precedence.Assign, expressionType === etIsIterator ? etNone : expressionType) as IsAssign);\n      } else {\n        // Shorthand\n        $currentChar = currentChar;\n        $currentToken = currentToken;\n        $index = index;\n        values.push(parse(Precedence.Primary, expressionType === etIsIterator ? etNone : expressionType) as IsAssign);\n      }\n    } else {\n      throw invalidPropDefInObjLiteral();\n    }\n    if (($currentToken as Token) !== Token.CloseBrace) {\n      consume(Token.Comma);\n    }\n  }\n\n  $optional = _optional;\n\n  consume(Token.CloseBrace);\n  if (expressionType === etIsIterator) {\n    return new ObjectBindingPattern(keys, values);\n  } else {\n    $assignable = false;\n    return new ObjectLiteralExpression(keys, values);\n  }\n}\n\nfunction parseInterpolation(): Interpolation {\n  const parts = [];\n  const expressions: (IsBindingBehavior | Interpolation)[] = [];\n  const length = $length;\n  let result = '';\n  while ($index < length) {\n    switch ($currentChar) {\n      case Char.Dollar:\n        if ($charCodeAt($index + 1) === Char.OpenBrace) {\n          parts.push(result);\n          result = '';\n\n          $index += 2;\n          $currentChar = $charCodeAt($index);\n          nextToken();\n          const expression = parse(Precedence.Variadic, etInterpolation) as IsBindingBehavior | Interpolation;\n          expressions.push(expression);\n          continue;\n        } else {\n          result += '$';\n        }\n        break;\n      case Char.Backslash:\n        result += stringFromCharCode(unescapeCode(nextChar()));\n        break;\n      default:\n        result += stringFromCharCode($currentChar);\n    }\n    nextChar();\n  }\n  if (expressions.length) {\n    parts.push(result);\n    return new Interpolation(parts, expressions as IsBindingBehavior[]);\n  }\n  return null!;\n}\n\n/**\n * parseTemplateLiteralExpression\n * https://tc39.github.io/ecma262/#prod-Literal\n *\n * TemplateExpression :\n * NoSubstitutionTemplate\n * TemplateHead\n *\n * NoSubstitutionTemplate :\n * ` TemplateCharacters(opt) `\n *\n * TemplateHead :\n * ` TemplateCharacters(opt) ${\n *\n * TemplateSubstitutionTail :\n * TemplateMiddle\n * TemplateTail\n *\n * TemplateMiddle :\n * } TemplateCharacters(opt) ${\n *\n * TemplateTail :\n * } TemplateCharacters(opt) `\n *\n * TemplateCharacters :\n * TemplateCharacter TemplateCharacters(opt)\n *\n * TemplateCharacter :\n * $ [lookahead ≠ {]\n * \\ EscapeSequence\n * SourceCharacter (but not one of ` or \\ or $)\n */\nfunction parseTemplate(expressionType: ExpressionType, result: IsLeftHandSide, tagged: boolean): TaggedTemplateExpression | TemplateExpression {\n  const _optional = $optional;\n\n  const cooked = [$tokenValue as string];\n  // TODO: properly implement raw parts / decide whether we want this\n  consume(Token.TemplateContinuation);\n  const expressions = [parse(Precedence.Assign, expressionType) as IsAssign];\n  while (($currentToken = scanTemplateTail()) !== Token.TemplateTail) {\n    cooked.push($tokenValue as string);\n    consume(Token.TemplateContinuation);\n    expressions.push(parse(Precedence.Assign, expressionType) as IsAssign);\n  }\n  cooked.push($tokenValue as string);\n\n  $assignable = false;\n  $optional = _optional;\n  if (tagged) {\n    nextToken();\n    return new TaggedTemplateExpression(cooked, cooked, result, expressions);\n  } else {\n    nextToken();\n    return new TemplateExpression(cooked, expressions);\n  }\n}\n\nfunction createTemplateTail(result: IsLeftHandSide) {\n  $assignable = false;\n  const strings = [$tokenValue as string];\n  nextToken();\n  return new TaggedTemplateExpression(strings, strings, result);\n}\n\nfunction nextToken(): void {\n  while ($index < $length) {\n    $startIndex = $index;\n    if (($currentToken = (CharScanners[$currentChar]()) as Token) != null) { // a null token means the character must be skipped\n      return;\n    }\n  }\n  $currentToken = Token.EOF;\n}\n\nfunction nextChar(): number {\n  return $currentChar = $charCodeAt(++$index);\n}\n\nfunction scanIdentifier(): Token {\n  // run to the next non-idPart\n  while (IdParts[nextChar()]);\n\n  const token: Token|undefined = KeywordLookup[$tokenValue = $tokenRaw()];\n  // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n  return token === undefined ? Token.Identifier : token;\n}\n\nfunction scanNumber(isFloat: boolean): Token {\n  let char = $currentChar;\n  if (isFloat === false) {\n    do {\n      char = nextChar();\n    } while (char <= Char.Nine && char >= Char.Zero);\n\n    if (char !== Char.Dot) {\n      $tokenValue = parseInt($tokenRaw(), 10);\n      return Token.NumericLiteral;\n    }\n    // past this point it's always a float\n    char = nextChar();\n    if ($index >= $length) {\n      // unless the number ends with a dot - that behaves a little different in native ES expressions\n      // but in our AST that behavior has no effect because numbers are always stored in variables\n      $tokenValue = parseInt($tokenRaw().slice(0, -1), 10);\n      return Token.NumericLiteral;\n    }\n  }\n\n  if (char <= Char.Nine && char >= Char.Zero) {\n    do {\n      char = nextChar();\n    } while (char <= Char.Nine && char >= Char.Zero);\n  } else {\n    $currentChar = $charCodeAt(--$index);\n  }\n\n  $tokenValue = parseFloat($tokenRaw());\n  return Token.NumericLiteral;\n}\n\nfunction scanString(): Token {\n  const quote = $currentChar;\n  nextChar(); // Skip initial quote.\n\n  let unescaped = 0;\n  const buffer = new Array<string>();\n  let marker = $index;\n\n  while ($currentChar !== quote) {\n    if ($currentChar === Char.Backslash) {\n      buffer.push($input.slice(marker, $index));\n      nextChar();\n      unescaped = unescapeCode($currentChar);\n      nextChar();\n      buffer.push(stringFromCharCode(unescaped));\n      marker = $index;\n    } else if ($index >= $length) {\n      throw unterminatedStringLiteral();\n    } else {\n      nextChar();\n    }\n  }\n\n  const last = $input.slice(marker, $index);\n  nextChar(); // Skip terminating quote.\n\n  // Compute the unescaped string value.\n  buffer.push(last);\n  const unescapedStr = buffer.join('');\n\n  $tokenValue = unescapedStr;\n  return Token.StringLiteral;\n}\n\nfunction scanTemplate(): Token {\n  let tail = true;\n  let result = '';\n\n  while (nextChar() !== Char.Backtick) {\n    if ($currentChar === Char.Dollar) {\n      if (($index + 1) < $length && $charCodeAt($index + 1) === Char.OpenBrace) {\n        $index++;\n        tail = false;\n        break;\n      } else {\n        result += '$';\n      }\n    } else if ($currentChar === Char.Backslash) {\n      result += stringFromCharCode(unescapeCode(nextChar()));\n    } else {\n      if ($index >= $length) {\n        throw unterminatedTemplateLiteral();\n      }\n      result += stringFromCharCode($currentChar);\n    }\n  }\n\n  nextChar();\n  $tokenValue = result;\n  if (tail) {\n    return Token.TemplateTail;\n  }\n  return Token.TemplateContinuation;\n}\n\nconst scanTemplateTail = (): Token => {\n  if ($index >= $length) {\n    throw unterminatedTemplateLiteral();\n  }\n  $index--;\n  return scanTemplate();\n};\n\nconst consumeOpt = (token: Token): boolean => {\n  if ($currentToken === token) {\n    nextToken();\n    return true;\n  }\n\n  return false;\n};\n\nconst consume = (token: Token): void => {\n  if ($currentToken === token) {\n    nextToken();\n  } else {\n    throw missingExpectedToken(token);\n  }\n};\n\n// #region errors\n\nconst invalidStartOfExpression = () => createMappedError(ErrorNames.parse_invalid_start, $input);\n\nconst invalidSpreadOp = () => createMappedError(ErrorNames.parse_no_spread, $input);\n\nconst expectedIdentifier = () => createMappedError(ErrorNames.parse_expected_identifier, $input);\n\nconst invalidMemberExpression = () => createMappedError(ErrorNames.parse_invalid_member_expr, $input);\n\nconst unexpectedEndOfExpression = () => createMappedError(ErrorNames.parse_unexpected_end, $input);\n\nconst unconsumedToken = () => createMappedError(ErrorNames.parse_unconsumed_token, $tokenRaw(), $index, $input);\n\nconst invalidEmptyExpression = () => createMappedError(ErrorNames.parse_invalid_empty);\n\nconst lhsNotAssignable = () => createMappedError(ErrorNames.parse_left_hand_side_not_assignable, $input);\n\nconst expectedValueConverterIdentifier = () => createMappedError(ErrorNames.parse_expected_converter_identifier, $input);\n\nconst expectedBindingBehaviorIdentifier = () => createMappedError(ErrorNames.parse_expected_behavior_identifier, $input);\n\nconst unexpectedOfKeyword = () => createMappedError(ErrorNames.parse_unexpected_keyword_of, $input);\n\nconst unexpectedImportKeyword = () => createMappedError(ErrorNames.parse_unexpected_keyword_import, $input);\n\nconst invalidLHSBindingIdentifierInForOf = (kind: unknown) => createMappedError(ErrorNames.parse_invalid_identifier_in_forof, $input, kind);\n\nconst invalidPropDefInObjLiteral = () => createMappedError(ErrorNames.parse_invalid_identifier_object_literal_key, $input);\n\nconst unterminatedStringLiteral = () => createMappedError(ErrorNames.parse_unterminated_string, $input);\n\nconst unterminatedTemplateLiteral = () => createMappedError(ErrorNames.parse_unterminated_template_string, $input);\n\nconst missingExpectedToken = (token: Token) =>\n  __DEV__\n    ? createMappedError(ErrorNames.parse_missing_expected_token, TokenValues[token & Token.Type], $input)\n    : createMappedError(ErrorNames.parse_missing_expected_token, $input);\n\nconst unexpectedTokenInDestructuring = () =>\n  __DEV__\n    ? createMappedError(ErrorNames.parse_unexpected_token_destructuring, $tokenRaw(), $index, $input)\n    : createMappedError(ErrorNames.parse_unexpected_token_destructuring, $input);\n\nconst unexpectedTokenInOptionalChain = () =>\n  __DEV__\n    ? createMappedError(ErrorNames.parse_unexpected_token_optional_chain, $tokenRaw(), $index - 1, $input)\n    : createMappedError(ErrorNames.parse_unexpected_token_optional_chain, $input);\n\nconst invalidTaggedTemplateOnOptionalChain = () => createMappedError(ErrorNames.parse_invalid_tag_in_optional_chain, $input);\n\nconst invalidArrowParameterList = () => createMappedError(ErrorNames.parse_invalid_arrow_params, $input);\n\nconst defaultParamsInArrowFn = () => createMappedError(ErrorNames.parse_no_arrow_param_default_value, $input);\n\nconst destructuringParamsInArrowFn = () => createMappedError(ErrorNames.parse_no_arrow_param_destructuring, $input);\n\nconst restParamsMustBeLastParam = () => createMappedError(ErrorNames.parse_rest_must_be_last, $input);\n\nconst functionBodyInArrowFn = () => createMappedError(ErrorNames.parse_no_arrow_fn_body, $input);\n\nconst unexpectedDoubleDot = () =>\n  __DEV__\n    ? createMappedError(ErrorNames.parse_unexpected_double_dot, $index - 1, $input)\n    : createMappedError(ErrorNames.parse_unexpected_double_dot, $input);\n\n// #endregion\n\n/**\n * Array for mapping tokens to token values. The indices of the values\n * correspond to the token bits 0-38.\n * For this to work properly, the values in the array must be kept in\n * the same order as the token bits.\n * Usage: TokenValues[token & Token.Type]\n */\nconst TokenValues = [\n  $false, $true, $null, $undefined, 'this', '$this', null/* '$host' */, '$parent',\n\n  '(', '{', '.', '..', '...', '?.', '}', ')', ',', '[', ']', ':', ';', '?', '\\'', '\"',\n\n  '&', '|', '??', '||', '&&', '==', '!=', '===', '!==', '<', '>',\n  '<=', '>=', 'in', 'instanceof', '+', '-', 'typeof', 'void', '*', '%', '/', '=', '!',\n  Token.TemplateTail, Token.TemplateContinuation,\n  'of', '=>', '+=', '-=', '*=', '/=', '++', '--'\n];\n\nconst KeywordLookup: Record<string, Token> = /*@__PURE__*/ Object.assign(createLookup<Token>(), {\n  true: Token.TrueKeyword,\n  null: Token.NullKeyword,\n  false: Token.FalseKeyword,\n  undefined: Token.UndefinedKeyword,\n  this: Token.AccessBoundary,\n  $this: Token.ThisScope,\n  $parent: Token.ParentScope,\n  in: Token.InKeyword,\n  instanceof: Token.InstanceOfKeyword,\n  typeof: Token.TypeofKeyword,\n  void: Token.VoidKeyword,\n  of: Token.OfKeyword,\n});\n\n// Character scanning function lookup\nconst {\n  CharScanners,\n  IdParts,\n} = /*@__PURE__*/ (() => {\n  type CharScanner = (() => Token | null) & { notMapped?: boolean };\n\n  const unexpectedCharacter: CharScanner = () => {\n    throw createMappedError(ErrorNames.parse_unexpected_character, $input);\n  };\n  unexpectedCharacter.notMapped = true;\n\n  /**\n   * Ranges of code points in pairs of 2 (eg 0x41-0x5B, 0x61-0x7B, ...) where the second value is not inclusive (5-7 means 5 and 6)\n   * Single values are denoted by the second value being a 0\n   *\n   * Copied from output generated with \"node build/generate-unicode.js\"\n   *\n   * See also: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF\n   */\n  const codes = {\n    /* [$0-9A-Za_a-z] */\n    AsciiIdPart: [0x24, 0, 0x30, 0x3A, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B],\n    IdStart: /* IdentifierStart */[0x24, 0, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B, 0xAA, 0, 0xBA, 0, 0xC0, 0xD7, 0xD8, 0xF7, 0xF8, 0x2B9, 0x2E0, 0x2E5, 0x1D00, 0x1D26, 0x1D2C, 0x1D5D, 0x1D62, 0x1D66, 0x1D6B, 0x1D78, 0x1D79, 0x1DBF, 0x1E00, 0x1F00, 0x2071, 0, 0x207F, 0, 0x2090, 0x209D, 0x212A, 0x212C, 0x2132, 0, 0x214E, 0, 0x2160, 0x2189, 0x2C60, 0x2C80, 0xA722, 0xA788, 0xA78B, 0xA7AF, 0xA7B0, 0xA7B8, 0xA7F7, 0xA800, 0xAB30, 0xAB5B, 0xAB5C, 0xAB65, 0xFB00, 0xFB07, 0xFF21, 0xFF3B, 0xFF41, 0xFF5B],\n    Digit: /* DecimalNumber */[0x30, 0x3A],\n    Skip: /* Skippable */[0, 0x21, 0x7F, 0xA1]\n  };\n\n  /**\n   * Decompress the ranges into an array of numbers so that the char code\n   * can be used as an index to the lookup\n   */\n  const decompress = (lookup: (CharScanner | number)[] | null, $set: Set<number> | null, compressed: number[], value: CharScanner | number | boolean): void => {\n    const rangeCount = compressed.length;\n    for (let i = 0; i < rangeCount; i += 2) {\n      const start = compressed[i];\n      let end = compressed[i + 1];\n      end = end > 0 ? end : start + 1;\n      if (lookup) {\n        lookup.fill(value as CharScanner | number, start, end);\n      }\n      if ($set) {\n        for (let ch = start; ch < end; ch++) {\n          $set.add(ch);\n        }\n      }\n    }\n  };\n\n  // // ASCII IdentifierPart lookup\n  // const AsciiIdParts = ((AsciiIdParts) => {\n  //   decompress(null, AsciiIdParts, codes.AsciiIdPart, true);\n  //   return AsciiIdParts;\n  // })(new Set<number>());\n\n  // IdentifierPart lookup\n  const IdParts = /*@__PURE__*/ ((IdParts) => {\n    decompress(IdParts as any, null, codes.IdStart, 1);\n    decompress(IdParts as any, null, codes.Digit, 1);\n    return IdParts;\n  })(new Uint8Array(0xFFFF));\n\n  // CharFuncLookup functions\n  const returnToken = (token: Token): () => Token =>\n    () => {\n      nextChar();\n      return token;\n    };\n\n  const CharScanners = new Array<CharScanner>(0xFFFF);\n  CharScanners.fill(unexpectedCharacter, 0, 0xFFFF);\n\n  decompress(CharScanners, null, codes.Skip, () => {\n    nextChar();\n    return null;\n  });\n  decompress(CharScanners, null, codes.IdStart, scanIdentifier);\n  decompress(CharScanners, null, codes.Digit, () => scanNumber(false));\n\n  CharScanners[Char.DoubleQuote] =\n  CharScanners[Char.SingleQuote] = () => {\n    return scanString();\n  };\n  CharScanners[Char.Backtick] = () => {\n    return scanTemplate();\n  };\n\n  // !, !=, !==\n  CharScanners[Char.Exclamation] = () => {\n    if (nextChar() !== Char.Equals) {\n      return Token.Exclamation;\n    }\n    if (nextChar() !== Char.Equals) {\n      return Token.ExclamationEquals;\n    }\n    nextChar();\n    return Token.ExclamationEqualsEquals;\n  };\n\n  // =, ==, ===, =>\n  CharScanners[Char.Equals] =  () => {\n    if (nextChar() === Char.GreaterThan) {\n      nextChar();\n      return Token.Arrow;\n    }\n    if ($currentChar !== Char.Equals) {\n      return Token.Equals;\n    }\n    if (nextChar() !== Char.Equals) {\n      return Token.EqualsEquals;\n    }\n    nextChar();\n    return Token.EqualsEqualsEquals;\n  };\n\n  // &, &&\n  CharScanners[Char.Ampersand] = () => {\n    if (nextChar() !== Char.Ampersand) {\n      return Token.Ampersand;\n    }\n    nextChar();\n    return Token.AmpersandAmpersand;\n  };\n\n  // |, ||\n  CharScanners[Char.Bar] = () => {\n    if (nextChar() !== Char.Bar) {\n      return Token.Bar;\n    }\n    nextChar();\n    return Token.BarBar;\n  };\n\n  // ?, ??, ?.\n  CharScanners[Char.Question] = () => {\n    if (nextChar() === Char.Dot) {\n      const peek = $charCodeAt($index + 1);\n      if (peek <= Char.Zero || peek >= Char.Nine) {\n        nextChar();\n        return Token.QuestionDot;\n      }\n      return Token.Question;\n    }\n    if ($currentChar !== Char.Question) {\n      return Token.Question;\n    }\n    nextChar();\n    return Token.QuestionQuestion;\n  };\n\n  // ., ...\n  CharScanners[Char.Dot] = () => {\n    if (nextChar() <= Char.Nine && $currentChar >= Char.Zero) {\n      return scanNumber(true);\n    }\n    if ($currentChar === Char.Dot) {\n      if (nextChar() !== Char.Dot) {\n        return Token.DotDot;\n      }\n      nextChar();\n      return Token.DotDotDot;\n    }\n    return Token.Dot;\n  };\n\n  // <, <=\n  CharScanners[Char.LessThan] =  () => {\n    if (nextChar() !== Char.Equals) {\n      return Token.LessThan;\n    }\n    nextChar();\n    return Token.LessThanEquals;\n  };\n\n  // >, >=\n  CharScanners[Char.GreaterThan] =  () => {\n    if (nextChar() !== Char.Equals) {\n      return Token.GreaterThan;\n    }\n    nextChar();\n    return Token.GreaterThanEquals;\n  };\n\n  CharScanners[Char.Percent]      = returnToken(Token.Percent);\n  CharScanners[Char.OpenParen]    = returnToken(Token.OpenParen);\n  CharScanners[Char.CloseParen]   = returnToken(Token.CloseParen);\n\n  // *, *=\n  CharScanners[Char.Asterisk] =  () => {\n    if (nextChar() !== Char.Equals) {\n      return Token.Asterisk;\n    }\n    nextChar();\n    return Token.AsteriskEquals;\n  };\n\n  // +, +=, ++\n  CharScanners[Char.Plus] =  () => {\n    if (nextChar() === Char.Plus) {\n      nextChar();\n      return Token.PlusPlus;\n    }\n    if ($currentChar !== Char.Equals) {\n      return Token.Plus;\n    }\n    nextChar();\n    return Token.PlusEquals;\n  };\n\n  CharScanners[Char.Comma]        = returnToken(Token.Comma);\n\n  // -, -=, --\n  CharScanners[Char.Minus] =  () => {\n    if (nextChar() === Char.Minus) {\n      nextChar();\n      return Token.MinusMinus;\n    }\n    if ($currentChar !== Char.Equals) {\n      return Token.Minus;\n    }\n    nextChar();\n    return Token.MinusEquals;\n  };\n\n  // /, /=\n  CharScanners[Char.Slash] =  () => {\n    if (nextChar() !== Char.Equals) {\n      return Token.Slash;\n    }\n    nextChar();\n    return Token.SlashEquals;\n  };\n\n  CharScanners[Char.Colon]        = returnToken(Token.Colon);\n  CharScanners[Char.Semicolon]    = returnToken(Token.Semicolon);\n  CharScanners[Char.OpenBracket]  = returnToken(Token.OpenBracket);\n  CharScanners[Char.CloseBracket] = returnToken(Token.CloseBracket);\n  CharScanners[Char.OpenBrace]    = returnToken(Token.OpenBrace);\n  CharScanners[Char.CloseBrace]   = returnToken(Token.CloseBrace);\n\n  return { CharScanners, IdParts };\n})();\n", "const tsPending = 'pending' as const;\nconst tsRunning = 'running' as const;\nconst tsCompleted = 'completed' as const;\nconst tsCanceled = 'canceled' as const;\nexport type TaskStatus = typeof tsPending | typeof tsRunning | typeof tsCompleted | typeof tsCanceled;\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst lookup = new Map<object, Platform>();\n\nconst notImplemented = (name: string): (...args: any[]) => any => {\n  return () => {\n    throw __DEV__\n      ? createError(`AUR1005: The PLATFORM did not receive a valid reference to the global function '${name}'.`) // TODO: link to docs describing how to fix this issue\n      : createError(`AUR1005:${name}`);\n  };\n};\n\nexport class Platform<TGlobal extends typeof globalThis = typeof globalThis> {\n  // http://www.ecma-international.org/ecma-262/#sec-value-properties-of-the-global-object\n  public readonly globalThis: TGlobal;\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-properties-of-the-global-object\n  public readonly decodeURI!: TGlobal['decodeURI'];\n  public readonly decodeURIComponent!: TGlobal['decodeURIComponent'];\n  public readonly encodeURI!: TGlobal['encodeURI'];\n  public readonly encodeURIComponent!: TGlobal['encodeURIComponent'];\n\n  // http://www.ecma-international.org/ecma-262/#sec-constructor-properties-of-the-global-object\n  public readonly Date!: TGlobal['Date'];\n\n  // http://www.ecma-international.org/ecma-262/#sec-other-properties-of-the-global-object\n  public readonly Reflect!: TGlobal['Reflect'];\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope\n  // Note: we're essentially assuming that all of these are available, even if we aren't even\n  // in a browser environment. They are available in major envs as well (NodeJS, NativeScript, etc),\n  // or can otherwise be mocked fairly easily. If not, things probably won't work anyway.\n  public readonly clearInterval!: TGlobal['clearInterval'];\n  public readonly clearTimeout!: TGlobal['clearTimeout'];\n  public readonly queueMicrotask!: TGlobal['queueMicrotask'];\n  public readonly setInterval!: TGlobal['setInterval'];\n  public readonly setTimeout!: TGlobal['setTimeout'];\n  public readonly console!: TGlobal['console'];\n\n  public readonly performanceNow: () => number;\n\n  public readonly taskQueue: TaskQueue;\n\n  public constructor(g: TGlobal, overrides: Partial<Exclude<Platform, 'globalThis'>> = {}) {\n    this.globalThis = g;\n    'decodeURI decodeURIComponent encodeURI encodeURIComponent Date Reflect console'.split(' ').forEach(prop => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      (this as any)[prop] = prop in overrides ? overrides[prop as keyof typeof overrides] : g[prop as keyof typeof g];\n    });\n\n    'clearInterval clearTimeout queueMicrotask setInterval setTimeout'.split(' ').forEach(method => {\n      // eslint-disable-next-line\n      (this as any)[method] = method in overrides ? overrides[method as keyof typeof overrides] : (g as any)[method]?.bind(g) ?? notImplemented(method);\n    });\n\n    this.performanceNow = 'performanceNow' in overrides ? overrides.performanceNow! : g.performance?.now?.bind(g.performance) ?? notImplemented('performance.now');\n\n    this.flushMacroTask = this.flushMacroTask.bind(this);\n    this.taskQueue = new TaskQueue(this, this.requestMacroTask.bind(this), this.cancelMacroTask.bind(this));\n  }\n\n  public static getOrCreate<TGlobal extends typeof globalThis = typeof globalThis>(\n    g: TGlobal,\n    overrides: Partial<Exclude<Platform, 'globalThis'>> = {},\n  ): Platform<TGlobal> {\n    let platform = lookup.get(g);\n    if (platform === void 0) {\n      lookup.set(g, platform = new Platform(g, overrides));\n    }\n    return platform as Platform<TGlobal>;\n  }\n\n  public static set(g: typeof globalThis, platform: Platform): void {\n    lookup.set(g, platform);\n  }\n\n  protected macroTaskRequested: boolean = false;\n  protected macroTaskHandle: number = -1;\n  protected requestMacroTask(): void {\n    this.macroTaskRequested = true;\n    if (this.macroTaskHandle === -1) {\n      this.macroTaskHandle = this.setTimeout(this.flushMacroTask, 0);\n    }\n  }\n  protected cancelMacroTask(): void {\n    this.macroTaskRequested = false;\n    if (this.macroTaskHandle > -1) {\n      this.clearTimeout(this.macroTaskHandle);\n      this.macroTaskHandle = -1;\n    }\n  }\n  protected flushMacroTask(): void {\n    this.macroTaskHandle = -1;\n    if (this.macroTaskRequested === true) {\n      this.macroTaskRequested = false;\n      this.taskQueue.flush();\n    }\n  }\n}\n\ntype TaskCallback<T = any> = (delta: number) => T;\n\nexport class TaskQueue {\n\n  /** @internal */ public _suspenderTask: Task | undefined = void 0;\n  /** @internal */ public _pendingAsyncCount: number = 0;\n\n  /** @internal */\n  public _processing: Task[] = [];\n\n  /** @internal */\n  public _pending: Task[] = [];\n\n  /** @internal */\n  public _delayed: Task[] = [];\n\n  /** @internal */\n  public _flushRequested: boolean = false;\n\n  /** @internal */\n  private _yieldPromise: ExposedPromise | undefined = void 0;\n\n  /** @internal */\n  private _lastRequest: number = 0;\n\n  /** @internal */\n  private _lastFlush: number = 0;\n\n  /** @internal */\n  private readonly _now: () => number;\n\n  public get isEmpty(): boolean {\n    return (\n      this._pendingAsyncCount === 0 &&\n      this._processing.length === 0 &&\n      this._pending.length === 0 &&\n      this._delayed.length === 0\n    );\n  }\n\n  /**\n   * Persistent tasks will re-queue themselves indefinitely until they are explicitly canceled,\n   * so we consider them 'infinite work' whereas non-persistent (one-off) tasks are 'finite work'.\n   *\n   * This `hasNoMoreFiniteWork` getters returns true if either all remaining tasks are persistent, or if there are no more tasks.\n   *\n   * If that is the case, we can resolve the promise that was created when `yield()` is called.\n   *\n   * @internal\n   */\n  private get _hasNoMoreFiniteWork(): boolean {\n    return (\n      this._pendingAsyncCount === 0 &&\n      this._processing.every(isPersistent) &&\n      this._pending.every(isPersistent) &&\n      this._delayed.every(isPersistent)\n    );\n  }\n\n  /** @internal */ private readonly _tracer: Tracer;\n  public constructor(\n    public readonly platform: Platform,\n    private readonly $request: () => void,\n    private readonly $cancel: () => void,\n  ) {\n    this._now = platform.performanceNow;\n    this._tracer = new Tracer(platform.console);\n  }\n\n  public flush(now: number = this._now()): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'flush'); }\n\n    this._flushRequested = false;\n    this._lastFlush = now;\n\n    // Only process normally if we are *not* currently waiting for an async task to finish\n    if (this._suspenderTask === void 0) {\n      let curr: Task;\n      if (this._pending.length > 0) {\n        this._processing.push(...this._pending);\n        this._pending.length = 0;\n      }\n      if (this._delayed.length > 0) {\n        for (let i = 0; i < this._delayed.length; ++i) {\n          curr = this._delayed[i];\n          if (curr.queueTime <= now) {\n            this._processing.push(curr);\n            this._delayed.splice(i--, 1);\n          }\n        }\n      }\n\n      let cur: Task;\n      while (this._processing.length > 0) {\n        (cur = this._processing.shift()!).run();\n        // If it's still running, it can only be an async task\n        if (cur.status === tsRunning) {\n          if (cur.suspend === true) {\n            this._suspenderTask = cur;\n            this._requestFlush();\n\n            if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'flush early async'); }\n\n            return;\n          } else {\n            ++this._pendingAsyncCount;\n          }\n        }\n      }\n\n      if (this._pending.length > 0) {\n        this._processing.push(...this._pending);\n        this._pending.length = 0;\n      }\n      if (this._delayed.length > 0) {\n        for (let i = 0; i < this._delayed.length; ++i) {\n          curr = this._delayed[i];\n          if (curr.queueTime <= now) {\n            this._processing.push(curr);\n            this._delayed.splice(i--, 1);\n          }\n        }\n      }\n\n      if (this._processing.length > 0 || this._delayed.length > 0 || this._pendingAsyncCount > 0) {\n        this._requestFlush();\n      }\n\n      if (\n        this._yieldPromise !== void 0 &&\n        this._hasNoMoreFiniteWork\n      ) {\n        const p = this._yieldPromise;\n        this._yieldPromise = void 0;\n        p.resolve();\n      }\n    } else {\n      // If we are still waiting for an async task to finish, just schedule the next flush and do nothing else.\n      // Should the task finish before the next flush is invoked,\n      // the callback to `completeAsyncTask` will have reset `this.suspenderTask` back to undefined so processing can return back to normal next flush.\n      this._requestFlush();\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'flush full'); }\n  }\n\n  /**\n   * Cancel the next flush cycle (and/or the macrotask that schedules the next flush cycle, in case this is a microtask queue), if it was requested.\n   *\n   * This operation is idempotent and will do nothing if no flush is scheduled.\n   */\n  public cancel(): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'cancel'); }\n\n    if (this._flushRequested) {\n      this.$cancel();\n      this._flushRequested = false;\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'cancel'); }\n  }\n\n  /**\n   * Returns a promise that, when awaited, resolves when:\n   * - all *non*-persistent (including async) tasks have finished;\n   * - the last-added persistent task has run exactly once;\n   *\n   * This operation is idempotent: the same promise will be returned until it resolves.\n   *\n   * If `yield()` is called multiple times in a row when there are one or more persistent tasks in the queue, each call will await exactly one cycle of those tasks.\n   */\n  public async yield(): Promise<void> {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'yield'); }\n\n    if (this.isEmpty) {\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'yield empty'); }\n    } else {\n      if (this._yieldPromise === void 0) {\n        if (__DEV__ && this._tracer.enabled) { this._tracer.trace(this, 'yield - creating promise'); }\n        this._yieldPromise = createExposedPromise();\n      }\n\n      await this._yieldPromise;\n\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'yield task'); }\n    }\n  }\n\n  public queueTask<T = any>(callback: TaskCallback<T>, opts?: QueueTaskOptions): Task<T> {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'queueTask'); }\n\n    const { delay, preempt, persistent, suspend } = { ...defaultQueueTaskOptions, ...opts };\n\n    if (preempt) {\n      if (delay > 0) {\n        throw preemptDelayComboError();\n      }\n      if (persistent) {\n        throw preemptyPersistentComboError();\n      }\n    }\n\n    if (this._processing.length === 0) {\n      this._requestFlush();\n    }\n\n    const time = this._now();\n\n    const task = new Task(this._tracer, this, time, time + delay, preempt, persistent, suspend, callback);\n\n    if (preempt) {\n      this._processing[this._processing.length] = task;\n    } else if (delay === 0) {\n      this._pending[this._pending.length] = task;\n    } else {\n      this._delayed[this._delayed.length] = task;\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'queueTask'); }\n\n    return task;\n  }\n\n  /**\n   * Remove the task from this queue.\n   */\n  public remove<T = any>(task: Task<T>): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'remove'); }\n\n    let idx = this._processing.indexOf(task);\n    if (idx > -1) {\n      this._processing.splice(idx, 1);\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'remove processing'); }\n      return;\n    }\n    idx = this._pending.indexOf(task);\n    if (idx > -1) {\n      this._pending.splice(idx, 1);\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'remove pending'); }\n      return;\n    }\n    idx = this._delayed.indexOf(task);\n    if (idx > -1) {\n      this._delayed.splice(idx, 1);\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'remove delayed'); }\n      return;\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'remove error'); }\n\n    throw createError(`Task #${task.id} could not be found`);\n  }\n\n  /**\n   * Reset the persistent task back to its pending state, preparing it for being invoked again on the next flush.\n   *\n   * @internal\n   */\n  public _resetPersistentTask(task: Task): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'resetPersistentTask'); }\n\n    task.reset(this._now());\n\n    if (task.createdTime === task.queueTime) {\n      this._pending[this._pending.length] = task;\n    } else {\n      this._delayed[this._delayed.length] = task;\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'resetPersistentTask'); }\n  }\n\n  /**\n   * Notify the queue that this async task has had its promise resolved, so that the queue can proceed with consecutive tasks on the next flush.\n   *\n   * @internal\n   */\n  public _completeAsyncTask(task: Task): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'completeAsyncTask'); }\n\n    if (task.suspend === true) {\n      if (this._suspenderTask !== task) {\n        if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'completeAsyncTask error'); }\n\n        throw createError(`Async task completion mismatch: suspenderTask=${this._suspenderTask?.id}, task=${task.id}`);\n      }\n\n      this._suspenderTask = void 0;\n    } else {\n      --this._pendingAsyncCount;\n    }\n\n    if (\n      this._yieldPromise !== void 0 &&\n      this._hasNoMoreFiniteWork\n    ) {\n      const p = this._yieldPromise;\n      this._yieldPromise = void 0;\n      p.resolve();\n    }\n\n    if (this.isEmpty) {\n      this.cancel();\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'completeAsyncTask'); }\n  }\n\n  /** @internal */\n  private readonly _requestFlush: () => void = () => {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'requestFlush'); }\n\n    if (!this._flushRequested) {\n      this._flushRequested = true;\n      this._lastRequest = this._now();\n      this.$request();\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'requestFlush'); }\n  };\n}\n\nexport class TaskAbortError<T = any> extends Error {\n  public constructor(public task: Task<T>) {\n    super('Task was canceled.');\n  }\n}\n\nlet id: number = 0;\n\ntype UnwrapPromise<T> = T extends Promise<infer R> ? R : T;\n\nexport interface ITask<T = any> {\n  readonly result: Promise<UnwrapPromise<T>>;\n  readonly status: TaskStatus;\n  run(): void;\n  cancel(): boolean;\n}\n\nexport class Task<T = any> implements ITask {\n  public readonly id: number = ++id;\n\n  /** @internal */ private _resolve: PResolve<UnwrapPromise<T>> | undefined = void 0;\n  /** @internal */ private _reject: PReject<TaskAbortError<T>> | undefined = void 0;\n\n  /** @internal */\n  private _result: Promise<UnwrapPromise<T>> | undefined = void 0;\n  public get result(): Promise<UnwrapPromise<T>> {\n    const result = this._result;\n    if (result === void 0) {\n      switch (this._status) {\n        case tsPending: {\n          const promise = this._result = createExposedPromise();\n          this._resolve = promise.resolve;\n          this._reject = promise.reject;\n          return promise;\n        }\n        /* istanbul ignore next */\n        case tsRunning:\n          throw createError('Trying to await task from within task will cause a deadlock.');\n        case tsCompleted:\n          return this._result = Promise.resolve() as unknown as Promise<UnwrapPromise<T>>;\n        case tsCanceled:\n          return this._result = Promise.reject(new TaskAbortError(this));\n      }\n    }\n    return result;\n  }\n\n  /** @internal */\n  private _status: TaskStatus = tsPending;\n  public get status(): TaskStatus {\n    return this._status;\n  }\n\n  /** @internal */\n  private readonly _tracer: Tracer;\n\n  public constructor(\n    tracer: Tracer,\n    public readonly taskQueue: TaskQueue,\n    public createdTime: number,\n    public queueTime: number,\n    public preempt: boolean,\n    public persistent: boolean,\n    public suspend: boolean,\n    public callback: TaskCallback<T>,\n  ) {\n    this._tracer = tracer;\n  }\n\n  public run(time: number = this.taskQueue.platform.performanceNow()): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'run'); }\n\n    if (this._status !== tsPending) {\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'run error'); }\n\n      throw createError(`Cannot run task in ${this._status} state`);\n    }\n\n    // this.persistent could be changed while the task is running (this can only be done by the task itself if canceled, and is a valid way of stopping a loop)\n    // so we deliberately reference this.persistent instead of the local variable, but we keep it around to know whether the task *was* persistent before running it,\n    // so we can set the correct cancelation state.\n    const {\n      persistent,\n      taskQueue,\n      callback,\n      _resolve: resolve,\n      _reject: reject,\n      createdTime,\n    } = this;\n    let ret: unknown;\n\n    this._status = tsRunning;\n\n    try {\n      ret = callback(time - createdTime);\n      if (ret instanceof Promise) {\n        ret.then($ret => {\n          if (this.persistent) {\n            taskQueue._resetPersistentTask(this);\n          } else {\n            if (persistent) {\n              // Persistent tasks never reach completed status. They're either pending, running, or canceled.\n              this._status = tsCanceled;\n            } else {\n              this._status = tsCompleted;\n            }\n\n            this.dispose();\n          }\n\n          taskQueue._completeAsyncTask(this);\n\n          if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'run async then'); }\n\n          if (resolve !== void 0) {\n            resolve($ret as UnwrapPromise<T>);\n          }\n        })\n        .catch((err: TaskAbortError<T>) => {\n          if (!this.persistent) {\n            this.dispose();\n          }\n\n          taskQueue._completeAsyncTask(this);\n\n          if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'run async catch'); }\n\n          if (reject !== void 0) {\n            reject(err);\n          } else {\n            throw err;\n          }\n        });\n      } else {\n        if (this.persistent) {\n          taskQueue._resetPersistentTask(this);\n        } else {\n          if (persistent) {\n            // Persistent tasks never reach completed status. They're either pending, running, or canceled.\n            this._status = tsCanceled;\n          } else {\n            this._status = tsCompleted;\n          }\n\n          this.dispose();\n        }\n\n        if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'run sync success'); }\n\n        if (resolve !== void 0) {\n          resolve(ret as UnwrapPromise<T>);\n        }\n      }\n    } catch (err) {\n      if (!this.persistent) {\n        this.dispose();\n      }\n\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'run sync error'); }\n\n      if (reject !== void 0) {\n        reject(err as TaskAbortError<T>);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  public cancel(): boolean {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'cancel'); }\n\n    if (this._status === tsPending) {\n      const taskQueue = this.taskQueue;\n      const reject = this._reject;\n\n      taskQueue.remove(this);\n\n      if (taskQueue.isEmpty) {\n        taskQueue.cancel();\n      }\n\n      this._status = tsCanceled;\n\n      this.dispose();\n\n      if (reject !== void 0) {\n        reject(new TaskAbortError(this));\n      }\n\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'cancel true =pending'); }\n\n      return true;\n    } else if (this._status === tsRunning && this.persistent) {\n      this.persistent = false;\n\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'cancel true =running+persistent'); }\n\n      return true;\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'cancel false'); }\n\n    return false;\n  }\n\n  public reset(time: number): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'reset'); }\n\n    const delay = this.queueTime - this.createdTime;\n    this.createdTime = time;\n    this.queueTime = time + delay;\n    this._status = tsPending;\n\n    this._resolve = void 0;\n    this._reject = void 0;\n    this._result = void 0;\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'reset'); }\n  }\n\n  public dispose(): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.trace(this, 'dispose'); }\n\n    this.callback = (void 0)!;\n    this._resolve = void 0;\n    this._reject = void 0;\n    this._result = void 0;\n  }\n}\n\nexport type QueueTaskOptions = {\n  /**\n   * The number of milliseconds to wait before queueing the task.\n   *\n   * NOTE: just like `setTimeout`, there is no guarantee that the task will actually run\n   * after the specified delay. It is merely a *minimum* delay.\n   *\n   * Defaults to `0`\n   */\n  delay?: number;\n  /**\n   * If `true`, the task will be run synchronously if it is the same priority as the\n   * `TaskQueue` that is currently flushing. Otherwise, it will be run on the next tick.\n   *\n   * Defaults to `false`\n   */\n  preempt?: boolean;\n  /**\n   * If `true`, the task will be added back onto the queue after it finished running, indefinitely, until manually canceled.\n   *\n   * Defaults to `false`\n   */\n  persistent?: boolean;\n  /**\n   * If `true`, and the task callback returns a promise, that promise will be awaited before consecutive tasks are run.\n   *\n   * Defaults to `false`.\n   */\n  suspend?: boolean;\n};\n\nclass Tracer {\n  public enabled: boolean = false;\n  private depth: number = 0;\n  public constructor(private readonly console: Platform['console']) {}\n\n  public enter(obj: TaskQueue | Task, method: string): void {\n    this.log(`${'  '.repeat(this.depth++)}> `, obj, method);\n  }\n  public leave(obj: TaskQueue | Task, method: string): void {\n    this.log(`${'  '.repeat(--this.depth)}< `, obj, method);\n  }\n  public trace(obj: TaskQueue | Task, method: string): void {\n    this.log(`${'  '.repeat(this.depth)}- `, obj, method);\n  }\n\n  private log(prefix: string, obj: TaskQueue | Task, method: string): void {\n    if (obj instanceof TaskQueue) {\n      const processing = obj._processing.length;\n      const pending = obj._pending.length;\n      const delayed = obj._delayed.length;\n      const flushReq = obj._flushRequested;\n      const susTask = !!obj._suspenderTask;\n\n      const info = `processing=${processing} pending=${pending} delayed=${delayed} flushReq=${flushReq} susTask=${susTask}`;\n      this.console.log(`${prefix}[Q.${method}] ${info}`);\n    } else {\n      const id = obj['id'];\n      const created = Math.round(obj['createdTime'] * 10) / 10;\n      const queue = Math.round(obj['queueTime'] * 10) / 10;\n      const preempt = obj['preempt'];\n      const persistent = obj['persistent'];\n      const suspend = obj['suspend'];\n      const status = obj['_status'];\n\n      const info = `id=${id} created=${created} queue=${queue} preempt=${preempt} persistent=${persistent} status=${status} suspend=${suspend}`;\n      this.console.log(`${prefix}[T.${method}] ${info}`);\n    }\n  }\n}\n\nconst defaultQueueTaskOptions: Required<QueueTaskOptions> = {\n  delay: 0,\n  preempt: false,\n  persistent: false,\n  suspend: false,\n};\n\ntype PResolve<T> = (value: T | PromiseLike<T>) => void;\ntype PReject<T = any> = (reason?: T) => void;\nlet $resolve: PResolve<any>;\nlet $reject: PReject;\nconst executor = <T>(resolve: PResolve<T>, reject: PReject): void => {\n  $resolve = resolve;\n  $reject = reject;\n};\n\ntype ExposedPromise<T = void> = Promise<T> & {\n  resolve: PResolve<T>;\n  reject: PReject;\n};\n\n/**\n * Efficiently create a promise where the `resolve` and `reject` functions are stored as properties on the prommise itself.\n */\nconst createExposedPromise = <T>(): ExposedPromise<T> => {\n  const p = new Promise<T>(executor) as ExposedPromise<T>;\n  p.resolve = $resolve;\n  p.reject = $reject;\n  return p;\n};\n\nconst isPersistent = (task: Task): boolean => task.persistent;\n\nconst preemptDelayComboError = () =>\n  __DEV__\n    ? createError(`AUR1006: Invalid arguments: preempt cannot be combined with a greater-than-zero delay`)\n    : createError(`AUR1006`);\nconst preemptyPersistentComboError = () =>\n  __DEV__\n    ? createError(`AUR1007: Invalid arguments: preempt cannot be combined with persistent`)\n    : createError(`AUR1007`);\n\nconst createError = (msg: string) => new Error(msg);\n\n/**\n * Retrieve internal tasks information of a TaskQueue\n */\nexport const reportTaskQueue = (taskQueue: TaskQueue) => {\n  const processing = taskQueue._processing;\n  const pending = taskQueue._pending;\n  const delayed = taskQueue._delayed;\n  const flushReq = taskQueue._flushRequested;\n\n  return { processing, pending, delayed, flushRequested: flushReq };\n};\n\n/**\n * Flush a taskqueue and cancel all the tasks that are queued by the flush\n * Mainly for debugging purposes\n */\nexport const ensureEmpty = (taskQueue: TaskQueue) => {\n  taskQueue.flush();\n  taskQueue._pending.forEach((x: ITask) => x.cancel());\n};\n", "/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n", "import { TaskQueue } from '@aurelia/platform';\nimport { IDisposable, IServiceLocator } from '@aurelia/kernel';\nimport { type Scope } from '@aurelia/runtime';\nimport { BindingMode } from '@aurelia/template-compiler';\nimport { State } from '../templating/controller';\n\n/** @internal */ export const { default: defaultMode, oneTime, toView, fromView, twoWay } = BindingMode;\nexport { BindingMode } from '@aurelia/template-compiler';\n\nexport interface IBindingController {\n  readonly state: State;\n}\n\nexport interface IBinding {\n  readonly isBound: boolean;\n  bind(scope: Scope): void;\n  unbind(): void;\n  get: IServiceLocator['get'];\n  useScope?(scope: Scope): void;\n  limit?(opts: IRateLimitOptions): IDisposable;\n}\n\nexport interface IRateLimitOptions {\n  type: 'throttle' | 'debounce';\n  delay: number;\n  queue: TaskQueue;\n  now: () => number;\n  signals: string[];\n}\n", "import { Metadata } from '@aurelia/metadata';\nimport { Protocol } from '@aurelia/kernel';\n\n/** @internal */ export const getMetadata = Metadata.get;\n/** @internal */ export const hasMetadata = Metadata.has;\n/** @internal */ export const defineMetadata = Metadata.define;\n\nconst { annotation } = Protocol;\n/** @internal */ export const getAnnotationKeyFor = annotation.keyFor;\n", "import { AccessorType, type ISubscriber } from '@aurelia/runtime';\nimport { type ISVGAnalyzer } from './observation/svg-analyzer';\nimport { type ISignaler } from './signaler';\nimport { createLookup, isString } from '@aurelia/kernel';\n\nconst O = Object;\n\n/** @internal */ export const safeString = String;\n\n/** @internal */ export const baseObjectPrototype = O.prototype;\n\n/** @internal */ export const hasOwnProperty = baseObjectPrototype.hasOwnProperty;\n\n/** @internal */ export const objectFreeze = O.freeze;\n\n/** @internal */ export const objectAssign = O.assign;\n\n/** @internal */ export const getOwnPropertyNames = O.getOwnPropertyNames;\n\n/** @internal */ export const objectKeys = O.keys;\n\nconst IsDataAttribute: Record<string, boolean> = /*@__PURE__*/createLookup();\n\n/** @internal */ export const isDataAttribute = (obj: Node, key: PropertyKey, svgAnalyzer: ISVGAnalyzer): boolean => {\n  if (IsDataAttribute[key as string] === true) {\n    return true;\n  }\n  if (!isString(key)) {\n    return false;\n  }\n  const prefix = key.slice(0, 5);\n  // https://html.spec.whatwg.org/multipage/dom.html#wai-aria\n  // https://html.spec.whatwg.org/multipage/dom.html#custom-data-attribute\n  return IsDataAttribute[key] =\n    prefix === 'aria-' ||\n    prefix === 'data-' ||\n    svgAnalyzer.isStandardSvgAttribute(obj, key);\n};\n\n/** @internal */ export const rethrow = (err: unknown) => { throw err; };\n\n/** @internal */\nexport const def = Reflect.defineProperty;\n\n/** @internal */\nexport const defineHiddenProp = <T>(obj: object, key: PropertyKey, value: T): T => {\n  def(obj, key, {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value\n  });\n  return value;\n};\n\n/** @internal */\nexport const addSignalListener = (signaler: ISignaler, signal: string, listener: ISubscriber) => signaler.addSignalListener(signal, listener);\n/** @internal */\nexport const removeSignalListener = (signaler: ISignaler, signal: string, listener: ISubscriber) => signaler.removeSignalListener(signal, listener);\n\n/** ExpressionType */\n/** @internal */ export const etInterpolation = 'Interpolation' as const;\n/** @internal */ export const etIsIterator = 'IsIterator' as const;\n/** @internal */ export const etIsFunction = 'IsFunction' as const;\n/** @internal */ export const etIsProperty = 'IsProperty' as const;\n\n/** TaskStatus */\n/** @internal */ export const tsPending = 'pending' as const;\n/** @internal */ export const tsRunning = 'running' as const;\n\n/** AccessorType */\n/** @internal */ export const atObserver: AccessorType = AccessorType.Observer;\n/** @internal */ export const atNode: AccessorType = AccessorType.Node;\n/** @internal */ export const atLayout: AccessorType = AccessorType.Layout;\n", "/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable prefer-template */\n\nimport { safeString } from './utilities';\n\n/** @internal */\nexport const createMappedError: CreateError = __DEV__\n  ? (code: ErrorNames, ...details: unknown[]) => new Error(`AUR${safeString(code).padStart(4, '0')}: ${getMessageByCode(code, ...details)}`)\n  : (code: ErrorNames, ...details: unknown[]) => new Error(`AUR${safeString(code).padStart(4, '0')}:${details.map(safeString)}`);\n\n_START_CONST_ENUM();\n/** @internal */\nexport const enum ErrorNames {\n  method_not_implemented = 99,\n\n  ast_behavior_not_found = 101,\n  ast_behavior_duplicated = 102,\n  ast_converter_not_found = 103,\n  ast_$host_not_found = 105,\n  ast_no_assign_$host = 106,\n  ast_not_a_function = 107,\n  ast_unknown_binary_operator = 108,\n  ast_unknown_unary_operator = 109,\n  ast_tagged_not_a_function = 110,\n  ast_name_is_not_a_function = 111,\n  ast_destruct_null = 112,\n  ast_increment_infinite_loop = 113,\n  ast_nullish_member_access = 114,\n  ast_nullish_keyed_access = 115,\n  ast_nullish_assignment = 116,\n\n  binding_behavior_def_not_found = 151,\n  value_converter_def_not_found = 152,\n  element_existed = 153,\n  attribute_existed = 154,\n  value_converter_existed = 155,\n  binding_behavior_existed = 156,\n  binding_command_existed = 157,\n\n  null_scope = 203,\n  create_scope_with_null_context = 204,\n\n  invalid_bindable_decorator_usage_symbol = 227,\n  invalid_bindable_decorator_usage_class_without_configuration = 228,\n  invalid_bindable_decorator_usage_class_without_property_name_configuration = 229,\n\n  controller_cached_not_found = 500,\n  controller_no_shadow_on_containerless = 501,\n  controller_activating_disposed = 502,\n  controller_activation_unexpected_state = 503,\n  controller_activation_synthetic_no_scope = 504,\n  controller_deactivation_unexpected_state = 505,\n  controller_watch_invalid_callback = 506,\n  controller_property_not_coercible = 507,\n  controller_property_no_change_handler = 508,\n\n  node_observer_strategy_not_found = 652,\n  node_observer_mapping_existed = 653,\n  select_observer_array_on_non_multi_select = 654,\n\n  compiler_primary_already_existed = 714,\n  compiler_attr_mapper_duplicate_mapping = 719,\n  root_not_found = 767,\n  aurelia_instance_existed_in_container = 768,\n  invalid_platform_impl = 769,\n  no_composition_root = 770,\n  invalid_dispose_call = 771,\n\n  not_supported_view_ref_api = 750,\n  ref_not_found = 751,\n\n  element_res_not_found = 752,\n  attribute_res_not_found = 753,\n  attribute_tc_res_not_found = 754,\n  view_factory_provider_not_ready = 755,\n  view_factory_invalid_name = 756,\n\n  rendering_mismatch_length = 757,\n\n  attribute_def_not_found = 759,\n  element_def_not_found = 760,\n  element_only_name = 761,\n  node_is_not_a_host = 762,\n  node_is_not_a_host2 = 763,\n  node_is_not_part_of_aurelia_app = 764,\n  node_is_not_part_of_aurelia_app2 = 765,\n  invalid_process_content_hook = 766,\n\n  watch_null_config = 772,\n  watch_invalid_change_handler = 773,\n  watch_non_method_decorator_usage = 774,\n\n  repeat_invalid_key_binding_command = 775,\n  repeat_extraneous_binding = 776,\n  repeat_non_iterable = 777,\n  repeat_non_countable = 778,\n  repeat_mismatch_length = 814,\n\n  portal_invalid_insert_position = 779,\n\n  self_behavior_invalid_usage = 801,\n  update_trigger_behavior_no_triggers = 802,\n  update_trigger_invalid_usage = 803,\n  au_compose_invalid_scope_behavior = 805,\n  au_compose_component_name_not_found = 806,\n  au_compose_invalid_run = 807,\n  au_compose_duplicate_deactivate = 808,\n  else_without_if = 810,\n  portal_query_empty = 811,\n  portal_no_target = 812,\n  promise_invalid_usage = 813,\n  switch_invalid_usage = 815,\n  switch_no_multiple_default = 816,\n\n  signal_behavior_invalid_usage = 817,\n  signal_behavior_no_signals = 818,\n\n  spreading_bindable_onto_non_component = 819,\n  spreading_invalid_target = 820,\n\n  no_spread_scope_context_found = 9999,\n  no_spread_template_controller = 9998,\n  marker_malformed = 9997,\n  binding_already_has_rate_limited = 9996,\n  binding_already_has_target_subscriber = 9995,\n  attr_behavior_invalid_binding = 9994,\n  update_trigger_behavior_not_supported = 9993,\n  update_trigger_behavior_node_property_not_observable = 9992,\n\n  children_decorator_invalid_usage = 9991,\n  slotted_decorator_invalid_usage = 9990,\n  children_invalid_query = 9989,\n}\n_END_CONST_ENUM();\n\nconst errorsMap: Record<ErrorNames, string> = {\n  [ErrorNames.method_not_implemented]: 'Method {{0}} not implemented',\n\n  [ErrorNames.ast_behavior_not_found]: `Ast eval error: binding behavior \"{{0}}\" could not be found. Did you forget to register it as a dependency?`,\n  [ErrorNames.ast_behavior_duplicated]: `Ast eval error: binding behavior \"{{0}}\" already applied.`,\n  [ErrorNames.ast_converter_not_found]: `Ast eval error: value converter \"{{0}}\" could not be found. Did you forget to register it as a dependency?`,\n  [ErrorNames.ast_$host_not_found]: `Ast eval error: unable to find $host context. Did you forget [au-slot] attribute?`,\n  [ErrorNames.ast_no_assign_$host]: `Ast eval error: invalid assignment. \"$host\" is a reserved keyword.`,\n  [ErrorNames.ast_not_a_function]: `Ast eval error: expression is not a function.`,\n  [ErrorNames.ast_unknown_unary_operator]: `Ast eval error: unknown unary operator: \"{{0}}\"`,\n  [ErrorNames.ast_unknown_binary_operator]: `Ast eval error: unknown binary operator: \"{{0}}\"`,\n  [ErrorNames.ast_tagged_not_a_function]: `Ast eval error: left-hand side of tagged template expression is not a function.`,\n  [ErrorNames.ast_name_is_not_a_function]: `Ast eval error: expected \"{{0}}\" to be a function`,\n  [ErrorNames.ast_destruct_null]: `Ast eval error: cannot use non-object value for destructuring assignment.`,\n  [ErrorNames.ast_increment_infinite_loop]: `Ast eval error: infinite loop detected. Increment operators should only be used in event handlers.`,\n  [ErrorNames.ast_nullish_member_access]: `Ast eval error: cannot access property \"{{0}}\" of {{1}}.`,\n  [ErrorNames.ast_nullish_keyed_access]: `Ast eval error: cannot access key \"{{0}}\" of {{1}}.`,\n  [ErrorNames.ast_nullish_assignment]: `Ast eval error: cannot assign value to property \"{{0}}\" of null/undefined.`,\n\n  [ErrorNames.binding_behavior_def_not_found]: `No binding behavior definition found for type {{0:name}}`,\n  [ErrorNames.value_converter_def_not_found]: `No value converter definition found for type {{0:name}}`,\n  [ErrorNames.element_existed]: `Element \"{{0}}\" has already been registered.`,\n  [ErrorNames.attribute_existed]: `Attribute \"{{0}}\" has already been registered.`,\n  [ErrorNames.value_converter_existed]: `Value converter {{0}} has already been registered.`,\n  [ErrorNames.binding_behavior_existed]: `Binding behavior {{0}} has already been registered.`,\n  [ErrorNames.binding_command_existed]: `Binding command {{0}} has already been registered.`,\n\n  [ErrorNames.null_scope]: `Trying to retrieve a property or build a scope from a null/undefined scope`,\n  [ErrorNames.create_scope_with_null_context]: 'Trying to create a scope with null/undefined binding context',\n\n  [ErrorNames.invalid_bindable_decorator_usage_symbol]: `@bindable is not supported for properties that uses a symbol for name. Use a string for the property name instead.`,\n  [ErrorNames.invalid_bindable_decorator_usage_class_without_configuration]: `@bindable cannot be used as a class decorator when no configuration object is supplied.`,\n  [ErrorNames.invalid_bindable_decorator_usage_class_without_property_name_configuration]: `@bindable cannot be used as a class decorator when no property name is supplied in the configuration object.`,\n\n  [ErrorNames.controller_cached_not_found]: `There is no cached controller for the provided ViewModel: {{0}}`,\n  [ErrorNames.controller_no_shadow_on_containerless]: `Invalid combination: cannot combine the containerless custom element option with Shadow DOM.`,\n  [ErrorNames.controller_activating_disposed]: `Trying to activate a disposed controller: {{0}}.`,\n  [ErrorNames.controller_activation_unexpected_state]: `Controller at {{0}} is in an unexpected state: {{1}} during activation.`,\n  [ErrorNames.controller_activation_synthetic_no_scope]: `Synthetic view at {{0}} is being activated with null/undefined scope.`,\n  [ErrorNames.controller_deactivation_unexpected_state]: `Controller at {{0}} is in an unexpected state: {{1}} during deactivation.`,\n  [ErrorNames.controller_watch_invalid_callback]: `Invalid callback for @watch decorator: {{0}}`,\n  [ErrorNames.controller_property_not_coercible]: `Observer for bindable property {{0}} does not support coercion.`,\n  [ErrorNames.controller_property_no_change_handler]: `Observer for property {{0}} does not support change handler.`,\n\n  [ErrorNames.attribute_def_not_found]: `No attribute definition found for type {{0:name}}`,\n  [ErrorNames.element_def_not_found]: `No element definition found for type {{0:name}}`,\n  [ErrorNames.element_only_name]: `Cannot create a custom element definition with only a name and no type: {{0}}`,\n  [ErrorNames.node_is_not_a_host]: `Trying to retrieve a custom element controller from a node, but the provided node <{{0:nodeName}} /> is not a custom element or containerless host.`,\n  [ErrorNames.node_is_not_a_host2]: `Trying to retrieve a custom element controller from a node, but the provided node <{{0:nodeName}} /> is not a custom element or containerless host.`,\n  [ErrorNames.node_is_not_part_of_aurelia_app]: `Trying to retrieve a custom element controller from a node.`\n    + ` But the provided node <{{0:nodeName}} /> does not appear to be part of an Aurelia app DOM tree,`\n    + ` or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`,\n  [ErrorNames.node_is_not_part_of_aurelia_app2]: `Trying to retrieve a custom element controller from a node.`\n    + ` But the provided node <{{0:nodeName}} /> does not appear to be part of an Aurelia app DOM tree,`\n    + ` or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`,\n  [ErrorNames.invalid_process_content_hook]: `Invalid @processContent hook. Expected the hook to be a function (when defined in a class, it needs to be a static function) but got a {{0:typeof}}.`,\n\n  [ErrorNames.node_observer_strategy_not_found]: `Aurelia is unable to observe property {{0}}. Register observation mapping with .useConfig().`,\n  [ErrorNames.node_observer_mapping_existed]: `Mapping for property {{0}} of <{{1}} /> already exists`,\n  [ErrorNames.select_observer_array_on_non_multi_select]: `Array values can only be bound to a multi-select.`,\n\n  [ErrorNames.compiler_primary_already_existed]: `Template compilation error: primary already exists on element/attribute \"{{0}}\"`,\n  [ErrorNames.compiler_attr_mapper_duplicate_mapping]: `Attribute {{0}} has been already registered for {{1:element}}`,\n\n  [ErrorNames.root_not_found]: `Aurelia.root was accessed without a valid root.`,\n  [ErrorNames.aurelia_instance_existed_in_container]: `An instance of Aurelia is already registered with the container or an ancestor of it.`,\n  [ErrorNames.invalid_platform_impl]: `Failed to initialize the platform object. The host element's ownerDocument does not have a defaultView, did you create the host from a DOMParser and forget to call adoptNode()?`,\n  [ErrorNames.no_composition_root]: `Aurelia.start() was called without a composition root`,\n  [ErrorNames.invalid_dispose_call]: `The aurelia instance must be fully stopped before it can be disposed`,\n  [ErrorNames.not_supported_view_ref_api]: `view.ref is not supported. If you are migrating from v1, this can be understood as the controller.`,\n  [ErrorNames.ref_not_found]: `Attempted to reference \"{{0}}\", but it was not found amongst the target's API.`,\n  [ErrorNames.element_res_not_found]: `Element {{0:.res}} is not registered in {{1:name}}.`,\n  [ErrorNames.attribute_res_not_found]: `Attribute {{0:.res}} is not registered in {{1:name}}.`,\n  [ErrorNames.attribute_tc_res_not_found]: `Attribute {{0:.res}} is not registered in {{1:name}}.`,\n  [ErrorNames.view_factory_provider_not_ready]: `Cannot resolve ViewFactory before the provider was prepared.`,\n  [ErrorNames.view_factory_invalid_name]: `Cannot resolve ViewFactory without a (valid) name.`,\n\n  [ErrorNames.rendering_mismatch_length]: `AUR0757: The compiled template is not aligned with the render instructions. There are {{0}} targets and {{1}} instructions.`,\n\n  [ErrorNames.watch_null_config]: `Invalid @watch decorator config. Expected an expression or a fn but received null/undefined.`,\n  [ErrorNames.watch_invalid_change_handler]: `Invalid @watch decorator change handler config.`\n    + `Method \"{{0}}\" not found in class {{1}}`,\n  [ErrorNames.watch_non_method_decorator_usage]: `Invalid @watch decorator usage: decorated target {{0}} is not a class method.`,\n\n  [ErrorNames.repeat_invalid_key_binding_command]: `Invalid command \"{{0}}\" usage with [repeat]`,\n  [ErrorNames.repeat_extraneous_binding]: `Invalid [repeat] usage, found extraneous target \"{{0}}\"`,\n  [ErrorNames.repeat_non_iterable]: `Unsupported: [repeat] cannot iterate over {{0:toString}}`,\n  [ErrorNames.repeat_non_countable]: `Unsupported: [repeat] cannot count {{0:toString}}`,\n  [ErrorNames.repeat_mismatch_length]: `[repeat] encountered an error: number of views != number of items {{0:join(!=)}}`,\n\n  [ErrorNames.portal_invalid_insert_position]: 'Invalid portal insertion position: {{0}}',\n\n  [ErrorNames.self_behavior_invalid_usage]: `\"& self\" binding behavior only supports listener binding via trigger/capture command.`,\n  [ErrorNames.update_trigger_behavior_no_triggers]: `\"& updateTrigger\" invalid usage. This binding behavior requires at least one event name argument: eg <input value.bind=\"firstName & updateTrigger:'blur'\">`,\n  [ErrorNames.update_trigger_invalid_usage]: `\"& updateTrigger\" invalid usage. This binding behavior can only be applied to two-way/ from-view bindings.`,\n  [ErrorNames.au_compose_invalid_scope_behavior]: `Invalid scope behavior \"{{0}}\" on <au-compose />. Only \"scoped\" or \"auto\" allowed.`,\n  // originally not supported\n  [ErrorNames.au_compose_component_name_not_found]: `<au-compose /> couldn't find a custom element with name \"{{0}}\", did you forget to register it locally or globally?`,\n  [ErrorNames.au_compose_invalid_run]: `Composition has already been activated/deactivated. Id: {{0:controller}}`,\n  [ErrorNames.au_compose_duplicate_deactivate]: `Composition has already been deactivated.`,\n  [ErrorNames.else_without_if]: `Invalid [else] usage, it should follow an [if]`,\n  [ErrorNames.portal_query_empty]: `Invalid portal strict target query, empty query.`,\n  [ErrorNames.portal_no_target]: `Invalid portal strict target resolution, target not found.`,\n  [ErrorNames.promise_invalid_usage]: `Invalid [pending]/[then]/[catch] usage. The parent [promise].resolve not found; only \"*[promise.resolve] > *[pending|then|catch]\" relation is supported.`,\n  [ErrorNames.switch_invalid_usage]: `Invalid [case/default-case] usage. The parent [switch] not found; only \"*[switch] > *[case|default-case]\" relation is supported.`,\n  [ErrorNames.switch_no_multiple_default]: `Invalid [default-case] usage. Multiple 'default-case's are not allowed.`,\n  [ErrorNames.signal_behavior_invalid_usage]: `\"& signal\" binding behavior can only be used with bindings that have a \"handleChange\" method`,\n  [ErrorNames.signal_behavior_no_signals]: `\"& signal\" invalid usage. At least one signal name must be passed to the signal behavior, e.g. \"expr & signal:'my-signal'\"`,\n\n  [ErrorNames.spreading_bindable_onto_non_component]: 'Spreading to bindables onto non custom element',\n  [ErrorNames.spreading_invalid_target]: `Invalid spread target {{0}}`,\n\n  [ErrorNames.no_spread_scope_context_found]: 'No scope context for spread binding.',\n  [ErrorNames.no_spread_template_controller]: 'Spread binding does not support spreading custom attributes/template controllers. Did you build the spread instruction manually?',\n  [ErrorNames.marker_malformed]: `Marker is malformed. This likely happens when a compiled template has been modified.`\n    + ` Did you accidentally modified some compiled template? You can modify template before compilation with compiling Template compiler hook.`,\n  [ErrorNames.binding_already_has_rate_limited]: `Invalid usage, a rate limit has already been applied. Did you have both throttle and debounce on the same binding?`,\n  [ErrorNames.binding_already_has_target_subscriber]: `The binding already has a target subscriber.`,\n  [ErrorNames.attr_behavior_invalid_binding]: `\"& attr\" can be only used on property binding. It's used on {{0:ctor}}`,\n  [ErrorNames.update_trigger_behavior_not_supported]: '\"& updateTrigger\" binding behavior only works with the default implementation of Aurelia HTML observation. Implement your own node observation + updateTrigger',\n  [ErrorNames.update_trigger_behavior_node_property_not_observable]: `\"& updateTrigger\" uses node observer to observe, but it does not know how to use events to observe property <{{0:target@property}} />`,\n\n  [ErrorNames.children_decorator_invalid_usage]: `Invalid @children usage. @children decorator can only be used on a field`,\n  [ErrorNames.slotted_decorator_invalid_usage]: `Invalid @slotted usage. @slotted decorator can only be used on a field`,\n  [ErrorNames.children_invalid_query]: `Invalid query selector. Only selectors with alpha-numeric characters, or $all are allowed. Got {{0}} instead.`\n};\n\nconst getMessageByCode = (name: ErrorNames, ...details: unknown[]) => {\n  let cooked: string = errorsMap[name];\n  for (let i = 0; i < details.length; ++i) {\n    const regex = new RegExp(`{{${i}(:.*)?}}`, 'g');\n    let matches = regex.exec(cooked);\n    while (matches != null) {\n      const method = matches[1]?.slice(1);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let value = details[i] as any;\n      if (value != null) {\n        switch (method) {\n          case 'nodeName': value = (value as Node).nodeName.toLowerCase(); break;\n          case 'name': value = (value as { name: string }).name; break;\n          case 'typeof': value = typeof value; break;\n          case 'ctor': value = (value as object).constructor.name; break;\n          case 'controller': value = value.controller.name; break;\n          case 'target@property': value = `${value.target}@${value.targetProperty}`; break;\n          case 'toString': value = Object.prototype.toString.call(value); break;\n          case 'join(!=)': value = (value as unknown[]).join('!='); break;\n          case 'bindingCommandHelp': value = getBindingCommandHelp(value); break;\n          case 'element': value = value === '*' ? 'all elements' : `<${value} />`; break;\n          default: {\n            // property access\n            if (method?.startsWith('.')) {\n              value = safeString(value[method.slice(1)]);\n            } else {\n              value = safeString(value);\n            }\n          }\n        }\n      }\n      cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);\n      matches = regex.exec(cooked);\n    }\n  }\n  return cooked;\n};\n\ntype CreateError = (code: ErrorNames, ...details: unknown[]) => Error;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction pleaseHelpCreateAnIssue(title: string, body?: string) {\n  return `\\nThis is likely an issue with Aurelia.\\n Please help create an issue by clicking the following link\\n`\n    + `https://github.com/aurelia/aurelia/issues/new?title=${encodeURIComponent(title)}`\n    + (body != null ? `&body=${encodeURIComponent(body)}` : '&template=bug_report.md');\n}\n\nfunction getBindingCommandHelp(name: string) {\n  switch (name) {\n    case 'delegate':\n      return `\\nThe \".delegate\" binding command has been removed in v2.`\n      + ` Binding command \".trigger\" should be used instead.`\n      + ` If you are migrating v1 application, install compat package`\n      + ` to add back the \".delegate\" binding command for ease of migration.`;\n    case 'call':\n      return `\\nThe \".call\" binding command has been removed in v2.`\n      + ` If you want to pass a callback that preserves the context of the function call,`\n      + ` you can use lambda instead. Refer to lambda expression doc for more details.`;\n    default:\n      return '';\n  }\n}\n", "import { kebabCase, getPrototypeChain, noop, type Class, createLookup, isString, type Constructable } from '@aurelia/kernel';\nimport { ICoercionConfiguration } from '@aurelia/runtime';\nimport { defaultMode, toView, twoWay } from './binding/interfaces-bindings';\nimport { defineMetadata, getAnnotationKeyFor, getMetadata } from './utilities-metadata';\nimport { objectFreeze, objectKeys } from './utilities';\n\nimport type { InterceptorFunc } from '@aurelia/runtime';\nimport { ErrorNames, createMappedError } from './errors';\nimport { BindingMode, IComponentBindablePropDefinition } from '@aurelia/template-compiler';\n\ntype PropertyType = typeof Number | typeof String | typeof Boolean | typeof BigInt | { coercer: InterceptorFunc } | Class<unknown>;\n\nexport type PartialBindableDefinition = Omit<IComponentBindablePropDefinition, 'name'> & {\n  // mode?: BindingMode;\n  callback?: string;\n  // attribute?: string;\n  name?: string;\n  // primary?: boolean;\n  set?: InterceptorFunc;\n  type?: PropertyType;\n\n  /**\n   * When set to `false` and automatic type-coercion is enabled, `null` and `undefined` will be coerced into target type.\n   *\n   * @default true\n   */\n  nullable?: boolean;\n};\n\n// Note: there is a invisible separator character the precedes the `@` in the jsdoc example. Otherwise the eslint rule will complain.\n// Refer:\n// - https://stackoverflow.com/a/55214510/2270340\n// - https://unicode-explorer.com/c/2063\n/**\n * Decorator: Specifies a bindable property on a class property.\n *\n * @example\n * ```ts\n * class Foo {\n *   ⁣@bindable bar: string;\n * }\n * ```\n */\nexport function bindable(_: undefined, context: ClassFieldDecoratorContext): void;\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function bindable(_: Function, context: ClassGetterDecoratorContext): void;\n/**\n * Decorator: Specifies custom behavior for a bindable property.\n * This can be either be a property decorator or a class decorator.\n *\n * @param config - The overrides\n */\nexport function bindable(config?: Omit<PartialBindableDefinition, 'name'>): (target: unknown, context: ClassDecoratorContext | ClassFieldDecoratorContext | ClassGetterDecoratorContext) => void;\n/**\n * Decorator: Specifies a bindable property on a class.\n *\n * @param prop - The property name\n */\nexport function bindable(prop: string): (target: Constructable, context: ClassDecoratorContext) => void;\nexport function bindable(\n  configOrPropOrTarget: PartialBindableDefinition | string | Constructable | undefined,\n  context?: ClassDecoratorContext | ClassFieldDecoratorContext | ClassGetterDecoratorContext\n):\n  | void\n  | ((target: Constructable, context: ClassDecoratorContext) => void)\n  | ((target: undefined, context: ClassFieldDecoratorContext) => void)\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  | ((target: Function, context: ClassGetterDecoratorContext) => void) {\n\n  let configOrProp: PartialBindableDefinition | string | undefined = void 0;\n  function decorator(_target: unknown, context: ClassDecoratorContext | ClassFieldDecoratorContext | ClassGetterDecoratorContext): void {\n    let $prop: string;\n\n    switch (context.kind) {\n      case 'getter':\n      case 'field': {\n        const prop = context.name;\n        // We are not supporting a bindable that uses a symbol for name.\n        // Maybe we can later have a binding command like foo.sym=\"bar\" that creates bindable instruction for `Symbol.for('sym')`, as target property.\n        if (typeof prop !== 'string') throw createMappedError(ErrorNames.invalid_bindable_decorator_usage_symbol);\n        $prop = prop;\n        break;\n      }\n      case 'class':\n        if (configOrProp == null) throw createMappedError(ErrorNames.invalid_bindable_decorator_usage_class_without_configuration);\n        if (typeof configOrProp == 'string') {\n          $prop = configOrProp;\n        } else {\n          const prop = configOrProp.name;\n          if (!prop) throw createMappedError(ErrorNames.invalid_bindable_decorator_usage_class_without_property_name_configuration);\n          if (typeof prop !== 'string') throw createMappedError(ErrorNames.invalid_bindable_decorator_usage_symbol);\n          $prop = prop;\n        }\n        break;\n    }\n\n    const config = configOrProp == null || typeof configOrProp === 'string'\n      ? { name: $prop }\n      : configOrProp;\n\n    const metadata = (context.metadata[baseName] ??= createLookup()) as Record<string, BindableDefinition>;\n    metadata[$prop] = BindableDefinition.create($prop, config);\n  }\n\n  if (arguments.length > 1) {\n    // Non invocation:\n    // - @bindable\n    configOrProp = {};\n    decorator(configOrPropOrTarget as Constructable | undefined, context!);\n    return;\n  } else if (isString(configOrPropOrTarget)) {\n    // ClassDecorator\n    // - @bindable('bar')\n    // Direct call:\n    // - @bindable('bar')(Foo)\n    configOrProp = configOrPropOrTarget;\n    return decorator;\n  }\n\n  // Invocation with or w/o opts:\n  // - @bindable()\n  // - @bindable({...opts})\n  configOrProp = configOrPropOrTarget === void 0 ? {} satisfies PartialBindableDefinition : configOrPropOrTarget as string | PartialBindableDefinition;\n  return decorator;\n}\n\nconst baseName = /*@__PURE__*/getAnnotationKeyFor('bindables');\n\nexport const Bindable = objectFreeze({\n  name: baseName,\n  keyFrom: (name: string): string => `${baseName}:${name}`,\n  from(...bindableLists: readonly (BindableDefinition | Record<string, Exclude<PartialBindableDefinition, 'name'> | true> | readonly (string | PartialBindableDefinition & { name: string })[] | undefined)[]): Record<string, BindableDefinition> {\n    const bindables: Record<string, BindableDefinition> = {};\n\n    const isArray = Array.isArray as <T>(arg: unknown) => arg is readonly T[];\n\n    function addName(name: string): void {\n      bindables[name] = BindableDefinition.create(name);\n    }\n\n    function addDescription(name: string, def: Exclude<PartialBindableDefinition, 'name'> | true): void {\n      bindables[name] = def instanceof BindableDefinition ? def : BindableDefinition.create(name, def === true ? { } : def);\n    }\n\n    function addList(maybeList: BindableDefinition | Record<string, Exclude<PartialBindableDefinition, 'name'> | true> | readonly (string | PartialBindableDefinition & { name: string })[] | undefined): void {\n      if (isArray(maybeList)) {\n        maybeList.forEach(nameOrDef => isString(nameOrDef) ? addName(nameOrDef) : addDescription(nameOrDef.name, nameOrDef));\n      } else if (maybeList instanceof BindableDefinition) {\n        bindables[maybeList.name] = maybeList;\n      } else if (maybeList !== void 0) {\n        objectKeys(maybeList).forEach(name => addDescription(name, maybeList[name]));\n      }\n    }\n\n    bindableLists.forEach(addList);\n\n    return bindables;\n  },\n  getAll(Type: Constructable): readonly BindableDefinition[] {\n    const defs: BindableDefinition[] = [];\n    const prototypeChain = getPrototypeChain(Type);\n\n    let iProto = prototypeChain.length;\n    let Class: Constructable;\n    while (--iProto >= 0) {\n      Class = prototypeChain[iProto];\n      const bindableMetadata = getMetadata<Record<PropertyKey, BindableDefinition>>(baseName, Class);\n      if (bindableMetadata == null) continue;\n      defs.push(...Object.values<BindableDefinition>(bindableMetadata));\n    }\n    return defs;\n  },\n  /** @internal */\n  _add(bindable: BindableDefinition, Type: Constructable) {\n    let bindables = getMetadata<Record<string, BindableDefinition>>(baseName, Type);\n    if (bindables == null) {\n      defineMetadata(bindables = createLookup(), Type, baseName);\n    }\n    bindables[bindable.name] = bindable;\n  }\n});\n\nexport class BindableDefinition {\n  private constructor(\n    public readonly attribute: string,\n    public readonly callback: string,\n    public readonly mode: BindingMode,\n    public readonly primary: boolean,\n    public readonly name: string,\n    public readonly set: InterceptorFunc,\n  ) { }\n\n  public static create(prop: string, def: PartialBindableDefinition = {}): BindableDefinition {\n    const mode = (def.mode ?? toView) as BindingMode;\n    return new BindableDefinition(\n      def.attribute ?? kebabCase(prop),\n      def.callback ?? `${prop}Changed`,\n      isString(mode) ? BindingMode[mode as keyof typeof BindingMode] ?? defaultMode : mode,\n      def.primary ?? false,\n      def.name ?? prop,\n      def.set ?? getInterceptor(def),\n    );\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars,spaced-comment */\n/**\n * This function serves two purposes:\n * - A playground for contributors to try their changes to the APIs.\n * - Cause the API surface to be properly type-checked and protected against accidental type regressions.\n *\n * It will be automatically removed by dead code elimination.\n */\nfunction apiTypeCheck() {\n\n  @bindable('prop')\n  // > expected error - class decorator only accepts a string\n  //@bindable({})\n  class Foo {\n    @bindable\n    @bindable()\n    @bindable({})\n    // > expected error - 'property' does not exist on decorator input object\n    //@bindable({ property: 'prop' })\n    @bindable({ mode: twoWay })\n    @bindable({ callback: 'propChanged' })\n    @bindable({ attribute: 'prop' })\n    @bindable({ primary: true })\n    @bindable({ set: value => String(value) })\n    @bindable({ set: value => Number(value) })\n    @bindable({\n      mode: twoWay,\n      callback: 'propChanged',\n      attribute: 'prop',\n      primary: true,\n      set: value => String(value)\n    })\n    public prop: unknown;\n  }\n}\n\ntype CoercerFunction<This extends Constructable> = (this: This, value: unknown) => InstanceType<This>;\nexport function coercer<\n  This extends Constructable,\n  TCoercer extends CoercerFunction<This>\n>(\n  target: TCoercer,\n  context: ClassMethodDecoratorContext<This, TCoercer>\n): void {\n  context.addInitializer(function (this: This) {\n    Coercer.define(this, context.name);\n  });\n}\n\nconst Coercer = {\n  key: /*@__PURE__*/getAnnotationKeyFor('coercer'),\n  define(target: Constructable<unknown>, property: string | symbol) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    defineMetadata(((target as any)[property] as InterceptorFunc).bind(target), target, Coercer.key);\n  },\n  for(target: Constructable<unknown>) {\n    return getMetadata<InterceptorFunc>(Coercer.key, target);\n  }\n};\n\nfunction getInterceptor(def: PartialBindableDefinition = {}) {\n  // TS5.x does not emit design:type metadata any longer for the new TC39 decorator proposal implementation.\n  // Hence, we needs to be solely reliant on the user-provided type in the bindable definition.\n  const type: PropertyType | null = def.type ?? null;\n  if (type == null) { return noop; }\n  let coercer: InterceptorFunc;\n  switch (type) {\n    case Number:\n    case Boolean:\n    case String:\n    case BigInt:\n      coercer = type as InterceptorFunc;\n      break;\n    default: {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n      const $coercer: InterceptorFunc = (type as any).coerce as InterceptorFunc;\n      coercer = typeof $coercer === 'function'\n        ? $coercer.bind(type)\n        : (Coercer.for(type as Constructable) ?? noop);\n      break;\n    }\n  }\n  return coercer === noop\n    ? coercer\n    : createCoercer(coercer, def.nullable);\n}\n\nfunction createCoercer<TInput, TOutput>(coercer: InterceptorFunc<TInput, TOutput>, nullable: boolean | undefined): InterceptorFunc<TInput, TOutput> {\n  return function (value: TInput, coercionConfiguration?: ICoercionConfiguration): TOutput {\n    if (!coercionConfiguration?.enableCoercion) return value as unknown as TOutput;\n    return ((nullable ?? ((coercionConfiguration?.coerceNullish ?? false) ? false : true)) && value == null)\n      ? value as unknown as TOutput\n      : coercer(value, coercionConfiguration);\n  };\n}\n", "import {\n  DI,\n  Registration,\n  type IResolver,\n  type Key,\n  type Constructable,\n  type IContainer,\n  type IDisposableResolver,\n} from '@aurelia/kernel';\nimport { defineMetadata, getAnnotationKeyFor, getMetadata } from './utilities-metadata';\nimport { IResourceKind } from './resources/resources-shared';\n\n/** @internal */\nexport const createInterface = DI.createInterface;\n\n/** @internal */\nexport const singletonRegistration = Registration.singleton;\n\n/** @internal */\nexport const aliasRegistration = Registration.aliasTo;\n\n/** @internal */\nexport const instanceRegistration = Registration.instance;\n\n/** @internal */\nexport const callbackRegistration = Registration.callback;\n\n/** @internal */\nexport const transientRegistration = Registration.transient;\n\n/** @internal */\nexport const registerResolver = <T extends IResolver | IDisposableResolver>(ctn: IContainer, key: Key, resolver: T): T =>\n  ctn.registerResolver(key, resolver);\n\nexport function alias(...aliases: readonly string[]) {\n  return function (target: Constructable, context: ClassDecoratorContext) {\n    context.addInitializer(function (this) {\n      const key = getAnnotationKeyFor('aliases');\n      const existing = getMetadata<string[] | undefined>(key, this);\n      if (existing === void 0) {\n        defineMetadata(aliases, this, key);\n      } else {\n        existing.push(...aliases);\n      }\n    });\n  };\n}\n\nexport function registerAliases(aliases: readonly string[], resource: IResourceKind, key: string, container: IContainer) {\n  for (let i = 0, ii = aliases.length; i < ii; ++i) {\n    aliasRegistration(key, resource.keyFrom(aliases[i])).register(container);\n  }\n}\n", "import { Constructable, PartialResourceDefinition, ResourceDefinition, StaticResourceType } from '@aurelia/kernel';\nimport { defineMetadata, getMetadata } from '../utilities-metadata';\n\n/** @internal */ export const dtElement = 'custom-element';\n/** @internal */ export const dtAttribute = 'custom-attribute';\n\nexport interface IResourceKind {\n  readonly name: string;\n  keyFrom(name: string): string;\n}\n\n/** @internal */ export const getDefinitionFromStaticAu = <Def extends ResourceDefinition, C extends Constructable = Constructable>(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  Type: C | Function,\n  typeName: string,\n  createDef: (au: PartialResourceDefinition<Def>, Type: C) => Def,\n  metadataKey = '__au_static_resource__'\n): Def => {\n  let def = getMetadata(metadataKey, Type) as Def;\n  if (def == null) {\n    if ((Type as StaticResourceType<Def>).$au?.type === typeName) {\n      def = createDef((Type as StaticResourceType<Def>).$au!, Type as C);\n      defineMetadata(def, Type, metadataKey);\n    }\n  }\n  return def;\n};\n", "import { firstDefined, getResourceKeyFor, mergeArrays, resource, resourceBaseName, ResourceType, isFunction, isString } from '@aurelia/kernel';\nimport { type Scope } from '@aurelia/runtime';\nimport { objectFreeze } from '../utilities';\nimport { aliasRegistration, singletonRegistration } from '../utilities-di';\nimport { defineMetadata, getAnnotationKeyFor, getMetadata, hasMetadata } from '../utilities-metadata';\n\nimport type { Constructable, IContainer, IServiceLocator, PartialResourceDefinition, ResourceDefinition, StaticResourceType } from '@aurelia/kernel';\nimport { createMappedError, ErrorNames } from '../errors';\nimport { getDefinitionFromStaticAu, type IResourceKind } from './resources-shared';\nimport { IBinding } from '../binding/interfaces-bindings';\n\nexport type PartialBindingBehaviorDefinition = PartialResourceDefinition;\nexport type BindingBehaviorStaticAuDefinition = PartialBindingBehaviorDefinition & {\n  type: 'binding-behavior';\n};\n\nexport type BindingBehaviorType<T extends Constructable = Constructable> = ResourceType<T, BindingBehaviorInstance>;\n\nexport type BindingBehaviorInstance<T extends {} = {}> = {\n  type?: 'instance' | 'factory';\n  bind?(scope: Scope, binding: IBinding, ...args: unknown[]): void;\n  unbind?(scope: Scope, binding: IBinding, ...args: unknown[]): void;\n} & T;\n\nexport type BindingBehaviorKind = IResourceKind & {\n  isType<T>(value: T): value is (T extends Constructable ? BindingBehaviorType<T> : never);\n  define<T extends Constructable>(name: string, Type: T): BindingBehaviorType<T>;\n  define<T extends Constructable>(def: PartialBindingBehaviorDefinition, Type: T): BindingBehaviorType<T>;\n  define<T extends Constructable>(nameOrDef: string | PartialBindingBehaviorDefinition, Type: T): BindingBehaviorType<T>;\n  getDefinition<T extends Constructable>(Type: T): BindingBehaviorDefinition<T>;\n  find(container: IContainer, name: string): BindingBehaviorDefinition | null;\n  get(container: IServiceLocator, name: string): BindingBehaviorInstance;\n};\n\nexport type BindingBehaviorDecorator = <T extends Constructable>(Type: T, context: ClassDecoratorContext) => BindingBehaviorType<T>;\n\nexport function bindingBehavior(definition: PartialBindingBehaviorDefinition): BindingBehaviorDecorator;\nexport function bindingBehavior(name: string): BindingBehaviorDecorator;\nexport function bindingBehavior(nameOrDef: string | PartialBindingBehaviorDefinition): BindingBehaviorDecorator;\nexport function bindingBehavior(nameOrDef: string | PartialBindingBehaviorDefinition): BindingBehaviorDecorator {\n  return function <T extends Constructable>(target: T, context: ClassDecoratorContext): BindingBehaviorType<T>  {\n    context.addInitializer(function (this) {\n      BindingBehavior.define(nameOrDef, this as Constructable);\n    });\n    return target as BindingBehaviorType<T>;\n  };\n}\n\nexport class BindingBehaviorDefinition<T extends Constructable = Constructable> implements ResourceDefinition<T, BindingBehaviorInstance> {\n  private constructor(\n    public readonly Type: BindingBehaviorType<T>,\n    public readonly name: string,\n    public readonly aliases: readonly string[],\n    public readonly key: string,\n  ) {}\n\n  public static create<T extends Constructable = Constructable>(\n    nameOrDef: string | PartialBindingBehaviorDefinition,\n    Type: BindingBehaviorType<T>,\n  ): BindingBehaviorDefinition<T> {\n\n    let name: string;\n    let def: PartialBindingBehaviorDefinition;\n    if (isString(nameOrDef)) {\n      name = nameOrDef;\n      def = { name };\n    } else {\n      name = nameOrDef.name;\n      def = nameOrDef;\n    }\n\n    return new BindingBehaviorDefinition(\n      Type,\n      firstDefined(getBehaviorAnnotation(Type, 'name'), name),\n      mergeArrays(getBehaviorAnnotation(Type, 'aliases'), def.aliases, Type.aliases),\n      BindingBehavior.keyFrom(name),\n    );\n  }\n\n  public register(container: IContainer, aliasName?: string | undefined): void {\n    const $Type = this.Type;\n    const key = typeof aliasName === 'string' ? getBindingBehaviorKeyFrom(aliasName) : this.key;\n    const aliases = this.aliases;\n\n    if (!container.has(key, false)) {\n      container.register(\n        container.has($Type, false) ? null : singletonRegistration($Type, $Type),\n        aliasRegistration($Type, key),\n        ...aliases.map(alias => aliasRegistration($Type, getBindingBehaviorKeyFrom(alias))),\n      );\n    } /* istanbul ignore next */ else if (__DEV__) {\n      // eslint-disable-next-line no-console\n      console.warn(`[DEV:aurelia] ${createMappedError(ErrorNames.binding_behavior_existed, this.name)}`);\n    }\n  }\n}\n\n/** @internal */ export const behaviorTypeName = 'binding-behavior';\nconst bbBaseName = /*@__PURE__*/getResourceKeyFor(behaviorTypeName);\nconst getBehaviorAnnotation = <K extends keyof PartialBindingBehaviorDefinition>(\n  Type: Constructable,\n  prop: K,\n): PartialBindingBehaviorDefinition[K] | undefined => getMetadata(getAnnotationKeyFor(prop), Type);\n\nconst getBindingBehaviorKeyFrom = (name: string): string => `${bbBaseName}:${name}`;\n\nexport const BindingBehavior = /*@__PURE__*/ objectFreeze<BindingBehaviorKind>({\n  name: bbBaseName,\n  keyFrom: getBindingBehaviorKeyFrom,\n  isType<T>(value: T): value is (T extends Constructable ? BindingBehaviorType<T> : never) {\n    return isFunction(value) && (hasMetadata(bbBaseName, value) || (value as StaticResourceType).$au?.type === behaviorTypeName);\n  },\n  define<T extends Constructable<BindingBehaviorInstance>>(nameOrDef: string | PartialBindingBehaviorDefinition, Type: T): BindingBehaviorType<T> {\n    const definition = BindingBehaviorDefinition.create(nameOrDef, Type as Constructable<BindingBehaviorInstance>);\n    const $Type = definition.Type as BindingBehaviorType<T>;\n\n    // registration of resource name is a requirement for the resource system in kernel (module-loader)\n    defineMetadata(definition, $Type, bbBaseName, resourceBaseName);\n\n    return $Type;\n  },\n  getDefinition<T extends Constructable>(Type: T): BindingBehaviorDefinition<T> {\n    const def: BindingBehaviorDefinition<T> = getMetadata<BindingBehaviorDefinition<T>>(bbBaseName, Type)\n      ?? getDefinitionFromStaticAu(Type as BindingBehaviorType<T>, behaviorTypeName, BindingBehaviorDefinition.create);\n    if (def === void 0) {\n      throw createMappedError(ErrorNames.binding_behavior_def_not_found, Type);\n    }\n\n    return def;\n  },\n  find(container, name) {\n    const Type = container.find<BindingBehaviorType>(behaviorTypeName, name);\n    return Type == null\n      ? null\n      : getMetadata<BindingBehaviorDefinition>(bbBaseName, Type) ?? getDefinitionFromStaticAu<BindingBehaviorDefinition>(Type, behaviorTypeName, BindingBehaviorDefinition.create) ?? null;\n  },\n  get(container, name) {\n    if (__DEV__) {\n      try {\n        return container.get<BindingBehaviorInstance>(resource(getBindingBehaviorKeyFrom(name)));\n      } catch (ex) {\n        // eslint-disable-next-line no-console\n        console.error('[DEV:aurelia] Cannot retrieve binding behavior with name', name);\n        throw ex;\n      }\n    }\n    return container.get<BindingBehaviorInstance>(resource(getBindingBehaviorKeyFrom(name)));\n  },\n});\n", "import { type Scope } from '@aurelia/runtime';\nimport { type IBinding, fromView, oneTime, toView, twoWay, type BindingMode } from '../../binding/interfaces-bindings';\nimport { BindingBehaviorInstance, behaviorTypeName, type BindingBehaviorStaticAuDefinition } from '../binding-behavior';\n\nconst originalModesMap = new Map<IBinding & { mode: BindingMode }, BindingMode>();\nconst createConfig = (name: string): BindingBehaviorStaticAuDefinition => ({ type: behaviorTypeName, name });\n\nexport abstract class BindingModeBehavior implements BindingBehaviorInstance {\n  public abstract readonly mode: BindingMode;\n\n  public bind(scope: Scope, binding: IBinding & { mode: BindingMode }): void {\n    originalModesMap.set(binding, binding.mode);\n    binding.mode = this.mode;\n  }\n\n  public unbind(scope: Scope, binding: IBinding & { mode: BindingMode }): void {\n    binding.mode = originalModesMap.get(binding)!;\n    originalModesMap.delete(binding);\n  }\n}\n\nexport class OneTimeBindingBehavior extends BindingModeBehavior {\n  public static readonly $au = /*@__PURE__*/createConfig('oneTime');\n  public get mode(): typeof BindingMode.oneTime { return oneTime; }\n}\n\nexport class ToViewBindingBehavior extends BindingModeBehavior {\n  public static readonly $au = /*@__PURE__*/createConfig('toView');\n  public get mode(): typeof BindingMode.toView { return toView; }\n}\n\nexport class FromViewBindingBehavior extends BindingModeBehavior {\n  public static readonly $au = /*@__PURE__*/createConfig('fromView');\n  public get mode(): typeof BindingMode.fromView { return fromView; }\n}\n\nexport class TwoWayBindingBehavior extends BindingModeBehavior {\n  public static readonly $au = /*@__PURE__*/createConfig('twoWay');\n  public get mode(): typeof BindingMode.twoWay { return twoWay; }\n}\n", "import { isString, type IDisposable, IPlatform, emptyArray, resolve } from '@aurelia/kernel';\nimport { type Scope } from '@aurelia/runtime';\nimport { type BindingBehaviorInstance, BindingBehaviorStaticAuDefinition, behaviorTypeName } from '../binding-behavior';\n\nimport { type IBinding, type IRateLimitOptions } from '../../binding/interfaces-bindings';\n\nconst bindingHandlerMap: WeakMap<IBinding, IDisposable> = new WeakMap();\nconst defaultDelay = 200;\n\nexport class DebounceBindingBehavior implements BindingBehaviorInstance {\n  public static readonly $au: BindingBehaviorStaticAuDefinition = {\n    type: behaviorTypeName,\n    name: 'debounce',\n  };\n  /** @internal */\n  private readonly _platform = resolve(IPlatform);\n\n  public bind(scope: Scope, binding: IBinding, delay?: number, signals?: string | string[]) {\n    const opts: IRateLimitOptions = {\n      type: 'debounce',\n      delay: delay ?? defaultDelay,\n      now: this._platform.performanceNow,\n      queue: this._platform.taskQueue,\n      signals: isString(signals) ? [signals] : (signals ?? emptyArray),\n    };\n    const handler = binding.limit?.(opts);\n    if (handler == null) {\n      /* istanbul ignore next */\n      if (__DEV__) {\n        // eslint-disable-next-line no-console\n        console.warn(`Binding ${binding.constructor.name} does not support debounce rate limiting`);\n      }\n    } else {\n      bindingHandlerMap.set(binding, handler);\n    }\n  }\n\n  public unbind(scope: Scope, binding: IBinding) {\n    bindingHandlerMap.get(binding)?.dispose();\n    bindingHandlerMap.delete(binding);\n  }\n}\n", "import { createLookup } from '@aurelia/kernel';\nimport type { ISubscriber } from '@aurelia/runtime';\nimport { createInterface } from './utilities-di';\n\nexport interface ISignaler extends Signaler {}\nexport const ISignaler = /*@__PURE__*/ createInterface<ISignaler>('ISignaler', x => x.singleton(Signaler));\n\nexport class Signaler {\n  public signals: Record<string, Set<ISubscriber> | undefined> = createLookup();\n\n  public dispatchSignal(name: string): void {\n    const listeners = this.signals[name];\n    if (listeners === undefined) {\n      return;\n    }\n    let listener: ISubscriber;\n    for (listener of listeners.keys()) {\n      listener.handleChange(undefined, undefined);\n    }\n  }\n\n  public addSignalListener(name: string, listener: ISubscriber): void {\n    (this.signals[name] ??= new Set()).add(listener);\n  }\n\n  public removeSignalListener(name: string, listener: ISubscriber): void {\n    this.signals[name]?.delete(listener);\n  }\n}\n", "import { resolve } from '@aurelia/kernel';\nimport { type Scope, type ISubscriber } from '@aurelia/runtime';\nimport { ISignaler } from '../../signaler';\nimport { type BindingBehaviorInstance, type BindingBehaviorStaticAuDefinition, behaviorTypeName } from '../binding-behavior';\nimport { addSignalListener, removeSignalListener } from '../../utilities';\nimport { ErrorNames, createMappedError } from '../../errors';\nimport { IBinding } from '../../binding/interfaces-bindings';\n\ntype ISignalableBinding = IBinding & ISubscriber;\n\nexport class SignalBindingBehavior implements BindingBehaviorInstance {\n  public static readonly $au: BindingBehaviorStaticAuDefinition = {\n    type: behaviorTypeName,\n    name: 'signal',\n  };\n  /** @internal */\n  private readonly _lookup: Map<IBinding, string[]> = new Map();\n  /** @internal */\n  private readonly _signaler = resolve(ISignaler);\n\n  public bind(scope: Scope, binding: IBinding, ...names: string[]): void {\n    if (!('handleChange' in binding)) {\n      throw createMappedError(ErrorNames.signal_behavior_invalid_usage);\n    }\n    if (names.length === 0) {\n      throw createMappedError(ErrorNames.signal_behavior_no_signals);\n    }\n\n    this._lookup.set(binding, names);\n    let name: string;\n    for (name of names) {\n      addSignalListener(this._signaler, name, binding as ISignalableBinding);\n    }\n  }\n\n  public unbind(scope: Scope, binding: IBinding): void {\n    const names = this._lookup.get(binding)!;\n    this._lookup.delete(binding);\n    let name: string;\n    for (name of names) {\n      removeSignalListener(this._signaler, name, binding as ISignalableBinding);\n    }\n  }\n}\n", "import { TaskQueue } from '@aurelia/platform';\nimport { isString, IPlatform, type IDisposable, emptyArray, resolve } from '@aurelia/kernel';\nimport { type Scope } from '@aurelia/runtime';\nimport { type BindingBehaviorInstance, BindingBehaviorStaticAuDefinition, behaviorTypeName } from '../binding-behavior';\nimport { type IBinding, type IRateLimitOptions } from '../../binding/interfaces-bindings';\n\nconst bindingHandlerMap: WeakMap<IBinding, IDisposable> = new WeakMap();\nconst defaultDelay = 200;\n\nexport class ThrottleBindingBehavior implements BindingBehaviorInstance {\n  public static readonly $au: BindingBehaviorStaticAuDefinition = {\n    type: behaviorTypeName,\n    name: 'throttle',\n  };\n  /** @internal */\n  private readonly _now: () => number;\n  /** @internal */\n  private readonly _taskQueue: TaskQueue;\n\n  public constructor() {\n    ({ performanceNow: this._now, taskQueue: this._taskQueue } = resolve(IPlatform));\n  }\n\n  public bind(scope: Scope, binding: IBinding, delay?: number, signals?: string | string[]) {\n    const opts: IRateLimitOptions = {\n      type: 'throttle',\n      delay: delay ?? defaultDelay,\n      now: this._now,\n      queue: this._taskQueue,\n      signals: isString(signals) ? [signals] : (signals ?? emptyArray),\n    };\n    const handler = binding.limit?.(opts);\n    if (handler == null) {\n      /* istanbul ignore next */\n      if (__DEV__) {\n        // eslint-disable-next-line no-console\n        console.warn(`Binding ${binding.constructor.name} does not support debounce rate limiting`);\n      }\n    } else {\n      bindingHandlerMap.set(binding, handler);\n    }\n  }\n\n  public unbind(scope: Scope, binding: IBinding) {\n    bindingHandlerMap.get(binding)?.dispose();\n    bindingHandlerMap.delete(binding);\n  }\n}\n", "import {  objectFreeze } from './utilities';\nimport { createInterface, instanceRegistration } from './utilities-di';\nimport { isFunction, type IContainer, type IRegistry, type Key, type Resolved } from '@aurelia/kernel';\n\nexport type TaskSlot =\n  | 'creating'\n  | 'hydrating'\n  | 'hydrated'\n  | 'activating'\n  | 'activated'\n  | 'deactivating'\n  | 'deactivated';\n\nexport const IAppTask = /*@__PURE__*/createInterface<IAppTask>('IAppTask');\nexport interface IAppTask {\n  readonly slot: TaskSlot;\n  register(c: IContainer): IContainer;\n  run(): void | Promise<void>;\n}\n\nclass $AppTask<K extends Key = Key> implements IAppTask {\n  public readonly slot: TaskSlot;\n  /** @internal */\n  private c: IContainer = (void 0)!;\n  /** @internal */\n  private readonly k: K | null;\n  /** @internal */\n  private readonly cb: AppTaskCallback<K> | AppTaskCallbackNoArg;\n\n  public constructor(\n    slot: TaskSlot,\n    key: K | null,\n    cb: AppTaskCallback<K> | AppTaskCallbackNoArg,\n  ) {\n    this.slot = slot;\n    this.k = key;\n    this.cb = cb;\n  }\n\n  public register(container: IContainer): IContainer {\n    return this.c = container.register(instanceRegistration(IAppTask, this));\n  }\n\n  public run(): void | Promise<void> {\n    const key = this.k;\n    const cb = this.cb;\n    return (key === null\n      ? (cb as AppTaskCallbackNoArg)()\n      : cb(this.c.get(key))) as Promise<void>;\n  }\n}\n\nexport const AppTask = objectFreeze({\n  /**\n   * Returns a task that will run just before the root component is created by DI\n   */\n  creating: createAppTaskSlotHook('creating'),\n  /**\n   * Returns a task that will run after instantiating the root controller,\n   * but before compiling its view (thus means before instantiating the child elements inside it)\n   *\n   * good chance for a router to do some initial work, or initial routing related in general\n   */\n  hydrating: createAppTaskSlotHook('hydrating'),\n  /**\n   * Return a task that will run after the hydration of the root controller,\n   * but before hydrating the child element inside\n   *\n   * good chance for a router to do some initial work, or initial routing related in general\n   */\n  hydrated: createAppTaskSlotHook('hydrated'),\n  /**\n   * Return a task that will run right before the root component is activated.\n   * In this phase, scope hierarchy is formed, and bindings are getting bound\n   */\n  activating: createAppTaskSlotHook('activating'),\n  /**\n   * Return a task that will run right after the root component is activated - the app is now running\n   */\n  activated: createAppTaskSlotHook('activated'),\n  /**\n   * Return a task that will runs right before the root component is deactivated.\n   * In this phase, scope hierarchy is unlinked, and bindings are getting unbound\n   */\n  deactivating: createAppTaskSlotHook('deactivating'),\n  /**\n   * Return a task that will run right after the root component is deactivated\n   */\n  deactivated: createAppTaskSlotHook('deactivated'),\n});\n\n// unknown as the return of an app task will be ignored\n// only cares whether it's a promise or not\n// the benefit of unknown is that application can avoid having to write () => { doThingsThatDoesNotReturnVoid() }\nexport type AppTaskCallbackNoArg = () => unknown;\nexport type AppTaskCallback<T> = (arg: Resolved<T>) => unknown;\n\nfunction createAppTaskSlotHook(slotName: TaskSlot) {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function appTaskFactory<T extends Key = Key>(callback: AppTaskCallbackNoArg): IRegistry;\n  function appTaskFactory<T extends Key = Key>(key: T, callback: AppTaskCallback<T>): IRegistry;\n  function appTaskFactory<T extends Key = Key>(keyOrCallback: T | AppTaskCallback<T> | AppTaskCallbackNoArg, callback?: AppTaskCallback<T>): IRegistry {\n    if (isFunction(callback)) {\n      return new $AppTask(slotName, keyOrCallback as T, callback);\n    }\n    return new $AppTask(slotName, null, keyOrCallback as Exclude<typeof keyOrCallback, T>);\n  }\n  return appTaskFactory;\n}\n", "import { BrowserPlatform } from '@aurelia/platform-browser';\nimport { InterfaceSymbol, IPlatform as $IPlatform } from '@aurelia/kernel';\n\nexport interface IPlatform extends BrowserPlatform {}\nexport const IPlatform = $IPlatform as InterfaceSymbol<IPlatform>;\n", "import { emptyArray, isFunction } from '@aurelia/kernel';\nimport { getAttributeDefinition, isAttributeType } from './resources/custom-attribute';\nimport { getElementDefinition, isElementType } from './resources/custom-element';\nimport { objectFreeze, safeString } from './utilities';\n\nimport type { Constructable } from '@aurelia/kernel';\nimport type { IConnectable } from '@aurelia/runtime';\nimport { ErrorNames, createMappedError } from './errors';\n\nexport type IDepCollectionFn<TType extends object, TReturn = unknown> = (vm: TType, watcher: IConnectable) => TReturn;\nexport type IWatcherCallback<TType extends object, TValue = unknown>\n  = (this: TType, newValue: TValue, oldValue: TValue, vm: TType) => unknown;\n\nexport interface IWatchDefinition<T extends object = object> {\n  expression: PropertyKey | IDepCollectionFn<T>;\n  callback: keyof T | IWatcherCallback<T>;\n}\n\ntype AnyMethod<R = unknown> = (...args: unknown[]) => R;\ntype WatchClassDecorator<T extends object> = <K extends Constructable<T>>(target: K, context: ClassDecoratorContext<K>) => void;\ntype WatchMethodDecorator<T, TV extends AnyMethod> = (target: TV, context: ClassMethodDecoratorContext<T, TV>) => void;\ntype MethodsOf<Type> = {\n  [Key in keyof Type]: Type[Key] extends AnyMethod ? Key : never\n}[keyof Type];\n\n// for\n//    @watch('some.expression', (v) => ...)\n//    @watch('some.expression', 'method')\n//    @watch(Symbol, (v) => ...)\n//    @watch(Symbol, 'method')\n//    @watch(a => ..., 'method')\n//    @watch(a => ..., v => ...)\n//    class A {\n//      method() {...}\n//    }\nexport function watch<T extends object, D = unknown>(\n  expressionOrPropertyAccessFn: PropertyKey,\n  changeHandlerOrCallback: MethodsOf<T> | IWatcherCallback<T, D>,\n): WatchClassDecorator<T>;\n\nexport function watch<T extends object, D = unknown>(\n  expressionOrPropertyAccessFn: IDepCollectionFn<T, D>,\n  changeHandlerOrCallback: MethodsOf<T> | IWatcherCallback<T, D>,\n): WatchClassDecorator<T>;\n\n// for\n// class A {\n//    @watch('some.expression')\n//    @watch(Symbol)\n//    @watch(a => ...)\n//    method() {...}\n// }\nexport function watch<T extends object = object, D = unknown, TV extends AnyMethod = AnyMethod>(\n  expressionOrPropertyAccessFn: PropertyKey | IDepCollectionFn<T, D>\n): WatchMethodDecorator<T, TV>;\n\nexport function watch<T extends object = object, TV extends AnyMethod = AnyMethod>(\n  expressionOrPropertyAccessFn: PropertyKey | IDepCollectionFn<object>,\n  changeHandlerOrCallback?: PropertyKey | IWatcherCallback<T>,\n): WatchClassDecorator<T> | WatchMethodDecorator<T, TV> {\n  if (expressionOrPropertyAccessFn == null) {\n    throw createMappedError(ErrorNames.watch_null_config);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  return function decorator(target: Function | IWatcherCallback<T>, context: ClassDecoratorContext<Constructable<T>> | ClassMethodDecoratorContext<T>): void {\n    const isClassDecorator = context.kind === 'class';\n\n    // basic validation\n    if (isClassDecorator) {\n      if (!isFunction(changeHandlerOrCallback)\n        && (changeHandlerOrCallback == null || !(changeHandlerOrCallback in target.prototype))\n      ) {\n        throw createMappedError(ErrorNames.watch_invalid_change_handler, `${safeString(changeHandlerOrCallback)}@${target.name}}`);\n      }\n    } else if (!isFunction(target) || context.static) {\n      throw createMappedError(ErrorNames.watch_non_method_decorator_usage, context.name);\n    }\n\n    const watchDef = new WatchDefinition<T>(\n      expressionOrPropertyAccessFn,\n      (isClassDecorator ? changeHandlerOrCallback : target) as IWatcherCallback<T>\n    );\n\n    if (isClassDecorator) {\n      addDefinition(target as Constructable);\n    } else {\n      // instance method decorator initializer is called for each instance\n      let added = false;\n      context.addInitializer(function (this: T) {\n        if (!added) {\n          added = true;\n          addDefinition(this.constructor as Constructable);\n        }\n      });\n    }\n\n    function addDefinition(type: Constructable) {\n      Watch.add(type, watchDef as IWatchDefinition);\n\n      // if the code looks like this:\n      // @watch(...)\n      // @customAttribute(...)\n      // class Abc {}\n      //\n      // then @watch is called after @customAttribute\n      // which means the attribute definition won't have the watch definition\n      //\n      // temporarily works around this order sensitivity by manually add the watch def\n      // manual\n      if (isAttributeType(type)) {\n        getAttributeDefinition(type).watches.push(watchDef as IWatchDefinition);\n      }\n      if (isElementType(type)) {\n        getElementDefinition(type).watches.push(watchDef as IWatchDefinition);\n      }\n    }\n  };\n}\n\nclass WatchDefinition<T extends object> implements IWatchDefinition<T> {\n  public constructor(\n    public expression: PropertyKey | IDepCollectionFn<T>,\n    public callback: IWatcherCallback<T>,\n  ) {}\n}\n\nexport const Watch = /*@__PURE__*/(() => {\n  const watches = new WeakMap<Constructable, IWatchDefinition[]>();\n  return objectFreeze({\n    add(Type: Constructable, definition: IWatchDefinition): void {\n      let defs = watches.get(Type);\n      if (defs == null) {\n        watches.set(Type, defs = []);\n      }\n      defs.push(definition);\n    },\n    getDefinitions(Type: Constructable): IWatchDefinition[] {\n      return watches.get(Type) ?? emptyArray;\n    }\n  });\n})();\n", "import { mergeArrays, firstDefined, Key, resourceBaseName, getResourceKeyFor, isFunction, isString, ILogger } from '@aurelia/kernel';\nimport { Bindable } from '../bindable';\nimport { Watch } from '../watch';\nimport { INode, getEffectiveParentNode, getRef } from '../dom';\nimport { defineMetadata, getAnnotationKeyFor, getMetadata, hasMetadata } from '../utilities-metadata';\nimport { objectFreeze } from '../utilities';\nimport { aliasRegistration, singletonRegistration } from '../utilities-di';\nimport { defaultMode, toView, BindingMode } from '../binding/interfaces-bindings';\n\nimport type {\n  Constructable,\n  IContainer,\n  ResourceDefinition,\n  PartialResourceDefinition,\n  ResourceType,\n  StaticResourceType,\n} from '@aurelia/kernel';\nimport type { BindableDefinition, PartialBindableDefinition } from '../bindable';\nimport type { ICustomAttributeViewModel, ICustomAttributeController, Controller } from '../templating/controller';\nimport type { IWatchDefinition } from '../watch';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { dtAttribute, getDefinitionFromStaticAu, type IResourceKind } from './resources-shared';\nimport { IAttributeComponentDefinition } from '@aurelia/template-compiler';\n\nexport type PartialCustomAttributeDefinition<TBindables extends string = string> = PartialResourceDefinition<Omit<IAttributeComponentDefinition, 'type'> & {\n  readonly defaultBindingMode?: string | number;\n  readonly isTemplateController?: boolean;\n  readonly bindables?: (Record<TBindables, true | Omit<PartialBindableDefinition, 'name'>>) | (TBindables | PartialBindableDefinition & { name: TBindables })[];\n  /**\n   * A config that can be used by template compliler to change attr value parsing mode\n   * `true` to always parse as a single value, mostly will be string in URL scenario\n   * Example:\n   * ```html\n   * <div goto=\"http://bla.bla.com\">\n   * ```\n   * With `noMultiBinding: true`, user does not need to escape the `:` with `\\`\n   * or use binding command to escape it.\n   *\n   * With `noMultiBinding: false (default)`, the above will be parsed as it's binding\n   * to a property name `http`, with value equal to literal string `//bla.bla.com`\n   */\n  readonly noMultiBindings?: boolean;\n  readonly watches?: IWatchDefinition[];\n  readonly dependencies?: readonly Key[];\n  /**\n   * **Only used by template controller custom attributes.**\n   *\n   * Container strategy for the view factory of this template controller.\n   *\n   * By default, the view factory will be reusing the container of the parent view (controller),\n   * as this container has information about the resources registered.\n   *\n   * Specify `'new'` to create a new container for the view factory.\n   */\n  readonly containerStrategy?: 'reuse' | 'new';\n}>;\n\nexport type CustomAttributeStaticAuDefinition<TBindables extends string = string> = PartialCustomAttributeDefinition<TBindables> & {\n  type: 'custom-attribute';\n};\n\nexport type CustomAttributeType<T extends Constructable = Constructable> = ResourceType<T, ICustomAttributeViewModel, PartialCustomAttributeDefinition>;\nexport type CustomAttributeKind = IResourceKind & {\n  for<C extends ICustomAttributeViewModel = ICustomAttributeViewModel>(node: Node, name: string): ICustomAttributeController<C> | undefined;\n  closest<A extends object | Constructable, TType extends A extends Constructable<infer T extends object> ? Constructable<T> : Constructable<A> = A extends Constructable<infer T extends object> ? Constructable<T> : Constructable<A>>(node: Node, Type: CustomAttributeType<TType>): ICustomAttributeController<InstanceType<TType>> | null;\n  closest<A extends object | Constructable, TType extends A extends Constructable<infer T extends object> ? Constructable<T> : Constructable<A> = A extends Constructable<infer T extends object> ? Constructable<T> : Constructable<A>>(node: Node, name: string): ICustomAttributeController<InstanceType<TType>> | null;\n  isType<T>(value: T): value is (T extends Constructable ? CustomAttributeType<T> : never);\n  define<T extends Constructable>(name: string, Type: T): CustomAttributeType<T>;\n  define<T extends Constructable>(def: PartialCustomAttributeDefinition, Type: T): CustomAttributeType<T>;\n  define<T extends Constructable>(nameOrDef: string | PartialCustomAttributeDefinition, Type: T): CustomAttributeType<T>;\n  getDefinition<T extends Constructable>(Type: T, context?: DecoratorContext | null): CustomAttributeDefinition<T>;\n  // eslint-disable-next-line\n  getDefinition<T extends Constructable>(Type: Function, context?: DecoratorContext | null): CustomAttributeDefinition<T>;\n  annotate<K extends keyof PartialCustomAttributeDefinition>(Type: Constructable, prop: K, value: PartialCustomAttributeDefinition[K]): void;\n  getAnnotation<K extends keyof PartialCustomAttributeDefinition>(Type: Constructable, prop: K, context: DecoratorContext | undefined | null): PartialCustomAttributeDefinition[K] | undefined;\n  find(c: IContainer, name: string): CustomAttributeDefinition | null;\n};\n\nexport type CustomAttributeDecorator = <T extends Constructable>(Type: T, context: ClassDecoratorContext) => CustomAttributeType<T>;\n\n/**\n * Decorator: Indicates that the decorated class is a custom attribute.\n */\nexport function customAttribute(definition: PartialCustomAttributeDefinition): CustomAttributeDecorator;\nexport function customAttribute(name: string): CustomAttributeDecorator;\nexport function customAttribute(nameOrDef: string | PartialCustomAttributeDefinition): CustomAttributeDecorator;\nexport function customAttribute(nameOrDef: string | PartialCustomAttributeDefinition): CustomAttributeDecorator {\n  return function <T extends Constructable>(target: T, context: ClassDecoratorContext): CustomAttributeType<T> {\n    context.addInitializer(function (this) {\n      defineAttribute(nameOrDef, this as Constructable);\n    });\n    return target as CustomAttributeType<T>;\n  };\n}\n\n/**\n * Decorator: Applied to custom attributes. Indicates that whatever element the\n * attribute is placed on should be converted into a template and that this\n * attribute controls the instantiation of the template.\n */\nexport function templateController(definition: Omit<PartialCustomAttributeDefinition, 'isTemplateController' | 'type'>): CustomAttributeDecorator;\nexport function templateController(name: string): CustomAttributeDecorator;\nexport function templateController(nameOrDef: string | Omit<PartialCustomAttributeDefinition, 'isTemplateController' | 'type'>): CustomAttributeDecorator;\nexport function templateController(nameOrDef: string | Omit<PartialCustomAttributeDefinition, 'isTemplateController' | 'type'>): CustomAttributeDecorator {\n  return function (target, context) {\n    context.addInitializer(function (this) {\n      defineAttribute(\n        isString(nameOrDef)\n          ? { isTemplateController: true, name: nameOrDef }\n          : { isTemplateController: true, ...nameOrDef },\n        this as Constructable,\n      );\n    });\n    return target;\n  } as CustomAttributeDecorator;\n}\n\nexport class CustomAttributeDefinition<T extends Constructable = Constructable> implements ResourceDefinition<T, ICustomAttributeViewModel, PartialCustomAttributeDefinition> {\n  public static warnDuplicate = true;\n  // a simple marker to distinguish between Custom Element definition & Custom attribute definition\n  public get type(): 'custom-attribute' { return dtAttribute; }\n\n  private constructor(\n    public readonly Type: CustomAttributeType<T>,\n    public readonly name: string,\n    public readonly aliases: readonly string[],\n    public readonly key: string,\n    public readonly defaultBindingMode: BindingMode,\n    public readonly isTemplateController: boolean,\n    public readonly bindables: Record<string, BindableDefinition>,\n    public readonly noMultiBindings: boolean,\n    public readonly watches: IWatchDefinition[],\n    public readonly dependencies: Key[],\n    public readonly containerStrategy: 'reuse' | 'new',\n  ) {}\n\n  public static create<T extends Constructable = Constructable>(\n    nameOrDef: string | PartialCustomAttributeDefinition,\n    Type: CustomAttributeType<T>,\n  ): CustomAttributeDefinition<T> {\n    let name: string;\n    let def: PartialCustomAttributeDefinition;\n    if (isString(nameOrDef)) {\n      name = nameOrDef;\n      def = { name };\n    } else {\n      name = nameOrDef.name;\n      def = nameOrDef;\n    }\n\n    const mode = firstDefined(getAttributeAnnotation(Type, 'defaultBindingMode'), def.defaultBindingMode, Type.defaultBindingMode, toView) as string | BindingMode;\n\n    for(const bindable of Object.values(Bindable.from(def.bindables))) {\n      Bindable._add(bindable, Type);\n    }\n    return new CustomAttributeDefinition(\n      Type,\n      firstDefined(getAttributeAnnotation(Type, 'name'), name),\n      mergeArrays(getAttributeAnnotation(Type, 'aliases'), def.aliases, Type.aliases),\n      getAttributeKeyFrom(name),\n      isString(mode) ? BindingMode[mode as keyof typeof BindingMode] ?? defaultMode : mode,\n      firstDefined(getAttributeAnnotation(Type, 'isTemplateController'), def.isTemplateController, Type.isTemplateController, false),\n      Bindable.from(...Bindable.getAll(Type), getAttributeAnnotation(Type, 'bindables'), Type.bindables, def.bindables),\n      firstDefined(getAttributeAnnotation(Type, 'noMultiBindings'), def.noMultiBindings, Type.noMultiBindings, false),\n      mergeArrays(Watch.getDefinitions(Type), Type.watches),\n      mergeArrays(getAttributeAnnotation(Type, 'dependencies'), def.dependencies, Type.dependencies),\n      firstDefined(getAttributeAnnotation(Type, 'containerStrategy'), def.containerStrategy, Type.containerStrategy, 'reuse'),\n    );\n  }\n\n  public register(container: IContainer, aliasName?: string | undefined): void {\n    const $Type = this.Type;\n    const key = typeof aliasName === 'string' ? getAttributeKeyFrom(aliasName) : this.key;\n    const aliases = this.aliases;\n\n    if (!container.has(key, false)) {\n      container.register(\n        container.has($Type, false) ? null : singletonRegistration($Type, $Type),\n        aliasRegistration($Type, key),\n        ...aliases.map(alias => aliasRegistration($Type, getAttributeKeyFrom(alias)))\n      );\n    } /* istanbul ignore next */ else {\n      if (CustomAttributeDefinition.warnDuplicate) {\n        container.get(ILogger).warn(createMappedError(ErrorNames.attribute_existed, this.name));\n      }\n      /* istanbul ignore if */\n      if (__DEV__) {\n        // eslint-disable-next-line no-console\n        console.warn(`[DEV:aurelia] ${createMappedError(ErrorNames.attribute_existed, this.name)}`);\n      }\n    }\n  }\n\n  public toString() {\n    return `au:ca:${this.name}`;\n  }\n}\n\n/** @internal */ export const attrTypeName = 'custom-attribute';\nconst attributeBaseName = /*@__PURE__*/getResourceKeyFor(attrTypeName);\nconst getAttributeKeyFrom = (name: string): string => `${attributeBaseName}:${name}`;\n\nconst getAttributeAnnotation = <K extends keyof PartialCustomAttributeDefinition>(\n  Type: Constructable,\n  prop: K,\n): PartialCustomAttributeDefinition[K] | undefined => getMetadata(getAnnotationKeyFor(prop), Type);\n\n/** @internal */\nexport const isAttributeType = <T>(value: T): value is (T extends Constructable ? CustomAttributeType<T> : never) => {\n  return isFunction(value) && (\n    hasMetadata(attributeBaseName, value)\n    || (value as StaticResourceType).$au?.type === attrTypeName\n  );\n};\n\n/** @internal */\nexport const findAttributeControllerFor = <C extends ICustomAttributeViewModel = ICustomAttributeViewModel>(node: Node, name: string): ICustomAttributeController<C> | undefined => {\n  return (getRef(node, getAttributeKeyFrom(name)) ?? void 0) as ICustomAttributeController<C> | undefined;\n};\n\n/** @internal */\nexport const defineAttribute = <T extends Constructable>(nameOrDef: string | PartialCustomAttributeDefinition, Type: T): CustomAttributeType<T> => {\n  const definition = CustomAttributeDefinition.create(nameOrDef, Type as Constructable);\n  const $Type = definition.Type as CustomAttributeType<T>;\n\n  defineMetadata(definition, $Type, attributeBaseName, resourceBaseName);\n\n  return $Type;\n};\n\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const getAttributeDefinition = <T extends Constructable>(Type: T | Function): CustomAttributeDefinition<T> => {\n  const def: CustomAttributeDefinition<T> = getMetadata<CustomAttributeDefinition<T>>(attributeBaseName, Type)\n    ?? getDefinitionFromStaticAu(Type as CustomAttributeType<T>, attrTypeName, CustomAttributeDefinition.create);\n  if (def === void 0) {\n    throw createMappedError(ErrorNames.attribute_def_not_found, Type);\n  }\n\n  return def;\n};\n\nconst findClosestControllerByName = (node: Node, attrNameOrType: string | CustomAttributeType): ICustomAttributeController | null => {\n  let key = '';\n  let attrName = '';\n  if (isString(attrNameOrType)) {\n    key = getAttributeKeyFrom(attrNameOrType);\n    attrName = attrNameOrType;\n  } else {\n    const definition = getAttributeDefinition(attrNameOrType);\n    key = definition.key;\n    attrName = definition.name;\n  }\n  let cur = node as INode | null;\n  while (cur !== null) {\n    const controller = getRef(cur, key) as Controller | null;\n    if (controller?.is(attrName)) {\n      return controller as ICustomAttributeController;\n    }\n\n    cur = getEffectiveParentNode(cur);\n  }\n\n  return null;\n};\n\nexport const CustomAttribute = /*@__PURE__*/ objectFreeze<CustomAttributeKind>({\n  name: attributeBaseName,\n  keyFrom: getAttributeKeyFrom,\n  isType: isAttributeType,\n  for: findAttributeControllerFor,\n  closest: findClosestControllerByName,\n  define: defineAttribute,\n  getDefinition: getAttributeDefinition,\n  annotate<K extends keyof PartialCustomAttributeDefinition>(Type: Constructable, prop: K, value: PartialCustomAttributeDefinition[K]): void {\n    defineMetadata(value, Type, getAnnotationKeyFor(prop));\n  },\n  getAnnotation: getAttributeAnnotation,\n  find(c, name) {\n    const Type = c.find<CustomAttributeType>(attrTypeName, name);\n    return Type === null\n      ? null\n      : getMetadata<CustomAttributeDefinition>(attributeBaseName, Type)\n      ?? getDefinitionFromStaticAu<CustomAttributeDefinition>(Type, attrTypeName, CustomAttributeDefinition.create)\n      ?? null;\n  },\n});\n", "import { createInterface, singletonRegistration } from '../utilities-di';\nimport { getOwnPropertyNames, objectFreeze, baseObjectPrototype } from '../utilities';\n\nimport { type Constructable, type IContainer, type AnyFunction, type FunctionPropNames, IRegistry, registrableMetadataKey } from '@aurelia/kernel';\n\nexport type LifecycleHook<TViewModel, TKey extends keyof TViewModel> =\n  TViewModel[TKey] extends (AnyFunction | undefined)\n    ? (vm: TViewModel, ...args: Parameters<NonNullable<TViewModel[TKey]>>) => ReturnType<NonNullable<TViewModel[TKey]>>\n    : never;\n\nexport type ILifecycleHooks<TViewModel = {}, TKey extends keyof TViewModel = keyof TViewModel> = { [K in TKey]-?: LifecycleHook<TViewModel, K>; };\nexport const ILifecycleHooks = /*@__PURE__*/createInterface<ILifecycleHooks<object>>('ILifecycleHooks');\n\nexport type LifecycleHooksLookup<TViewModel = {}> = {\n  [K in FunctionPropNames<TViewModel>]?: readonly LifecycleHooksEntry<TViewModel, K>[];\n};\nexport class LifecycleHooksEntry<TViewModel = {}, TKey extends keyof TViewModel = keyof TViewModel, THooks extends Constructable = Constructable> {\n  public constructor(\n    public readonly definition: LifecycleHooksDefinition<THooks>,\n    public readonly instance: ILifecycleHooks<TViewModel, TKey>,\n  ) {}\n}\n\n/**\n * This definition has no specific properties yet other than the type, but is in place for future extensions.\n *\n * See: https://github.com/aurelia/aurelia/issues/1044\n */\nexport class LifecycleHooksDefinition<T extends Constructable = Constructable> {\n  private constructor(\n    public readonly Type: T,\n    public readonly propertyNames: ReadonlySet<string>,\n  ) {}\n\n  /**\n   * @param def - Placeholder for future extensions. Currently always an empty object.\n   */\n  public static create<T extends Constructable>(def: {}, Type: T): LifecycleHooksDefinition<T> {\n    const propertyNames = new Set<string>();\n    let proto = Type.prototype;\n    while (proto !== baseObjectPrototype) {\n      for (const name of getOwnPropertyNames(proto)) {\n        // This is the only check we will do for now. Filtering on e.g. function types might not always work properly when decorators come into play. This would need more testing first.\n        if (name !== 'constructor' && !name.startsWith('_')) {\n          propertyNames.add(name);\n        }\n      }\n      proto = Object.getPrototypeOf(proto);\n    }\n\n    return new LifecycleHooksDefinition(Type, propertyNames);\n  }\n}\n\nexport const LifecycleHooks = /*@__PURE__*/(() => {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const containerLookup = new WeakMap<IContainer, LifecycleHooksLookup<any>>();\n  // const lhBaseName = getAnnotationKeyFor('lifecycle-hooks');\n  const definitionMap = new WeakMap<Constructable, LifecycleHooksDefinition>();\n\n  return objectFreeze({\n    // name: lhBaseName,\n    /**\n     * @param def - Placeholder for future extensions. Currently always an empty object.\n     */\n    define<T extends Constructable>(def: {}, Type: T): IRegistry {\n      const definition = LifecycleHooksDefinition.create(def, Type);\n      const $Type = definition.Type;\n\n      definitionMap.set($Type, definition);\n\n      return {\n        register(container: IContainer): void {\n          singletonRegistration(ILifecycleHooks, $Type).register(container);\n        }\n      };\n    },\n    /**\n     * @param ctx - The container where the resolution starts\n     * @param Type - The constructor of the Custom element/ Custom attribute with lifecycle metadata\n     */\n    resolve(ctx: IContainer): LifecycleHooksLookup {\n      let lookup = containerLookup.get(ctx);\n      if (lookup === void 0) {\n        containerLookup.set(ctx, lookup = new LifecycleHooksLookupImpl());\n        const root = ctx.root;\n        const instances = root === ctx\n          ? ctx.getAll(ILifecycleHooks)\n          // if it's not root, only resolve it from the current context when it has the resolver\n          // to maintain resources semantic: current -> root\n          : ctx.has(ILifecycleHooks, false)\n            ? root.getAll(ILifecycleHooks).concat(ctx.getAll(ILifecycleHooks))\n            : root.getAll(ILifecycleHooks);\n\n        let instance: ILifecycleHooks;\n        let definition: LifecycleHooksDefinition;\n        let entry: LifecycleHooksEntry;\n        let name: string;\n        let entries: LifecycleHooksEntry[];\n\n        for (instance of instances) {\n          definition = definitionMap.get(instance.constructor as Constructable)!;\n          entry = new LifecycleHooksEntry(definition, instance);\n          for (name of definition.propertyNames) {\n            entries = lookup[name] as LifecycleHooksEntry[];\n            if (entries === void 0) {\n              lookup[name] = [entry];\n            } else {\n              entries.push(entry);\n            }\n          }\n        }\n      }\n      return lookup;\n    },\n  });\n})();\n\nclass LifecycleHooksLookupImpl implements LifecycleHooksLookup {}\n\n/**\n * Decorator: Indicates that the decorated class is a custom element.\n */\nexport function lifecycleHooks(): <T extends Constructable>(target: T, context: ClassDecoratorContext) => T;\nexport function lifecycleHooks<T extends Constructable>(target: T, context: ClassDecoratorContext): T;\nexport function lifecycleHooks<T extends Constructable>(target?: T, context?: ClassDecoratorContext<T>): T | (<T extends Constructable>(target: T, context: ClassDecoratorContext) => T) {\n  function decorator<T extends Constructable>(target: T, context: ClassDecoratorContext): T {\n    const metadata = context?.metadata ?? (target[Symbol.metadata] ??= Object.create(null));\n    metadata[registrableMetadataKey] = LifecycleHooks.define({}, target);\n    return target;\n  }\n  return target == null ? decorator : decorator(target, context!);\n}\n", "import {\n  mergeArrays,\n  firstDefined,\n  resourceBaseName,\n  getResourceKeyFor,\n  resource,\n  isFunction,\n  isString,\n} from '@aurelia/kernel';\nimport { aliasRegistration, singletonRegistration } from '../utilities-di';\nimport { objectFreeze } from '../utilities';\nimport { defineMetadata, getAnnotationKeyFor, getMetadata, hasMetadata } from '../utilities-metadata';\n\nimport type {\n  Constructable,\n  IContainer,\n  ResourceDefinition,\n  ResourceType,\n  PartialResourceDefinition,\n  IServiceLocator,\n  StaticResourceType,\n} from '@aurelia/kernel';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { getDefinitionFromStaticAu, type IResourceKind } from './resources-shared';\n\nexport type PartialValueConverterDefinition = PartialResourceDefinition;\nexport type ValueConverterStaticAuDefinition = PartialValueConverterDefinition & {\n  type: 'value-converter';\n};\n\nexport type ValueConverterType<T extends Constructable = Constructable> = ResourceType<T, ValueConverterInstance>;\nexport type ValueConverterInstance<T extends {} = {}> = {\n  signals?: string[];\n  toView(input: unknown, ...args: unknown[]): unknown;\n  fromView?(input: unknown, ...args: unknown[]): unknown;\n} & T;\n\nexport type ValueConverterKind = IResourceKind & {\n  isType<T>(value: T): value is (T extends Constructable ? ValueConverterType<T> : never);\n  define<T extends Constructable>(name: string, Type: T, decoratorContext?: DecoratorContext): ValueConverterType<T>;\n  define<T extends Constructable>(def: PartialValueConverterDefinition, Type: T, decoratorContext?: DecoratorContext): ValueConverterType<T>;\n  define<T extends Constructable>(nameOrDef: string | PartialValueConverterDefinition, Type: T, decoratorContext?: DecoratorContext): ValueConverterType<T>;\n  getDefinition<T extends Constructable>(Type: T): ValueConverterDefinition<T>;\n  annotate<K extends keyof PartialValueConverterDefinition>(Type: Constructable, prop: K, value: PartialValueConverterDefinition[K]): void;\n  getAnnotation<K extends keyof PartialValueConverterDefinition>(Type: Constructable, prop: K, context: DecoratorContext | null): PartialValueConverterDefinition[K] | undefined;\n  find(container: IContainer, name: string): ValueConverterDefinition | null;\n  get(container: IServiceLocator, name: string): ValueConverterInstance;\n};\n\nexport type ValueConverterDecorator = <T extends Constructable>(Type: T, context: ClassDecoratorContext) => ValueConverterType<T>;\n\nexport function valueConverter(definition: PartialValueConverterDefinition): ValueConverterDecorator;\nexport function valueConverter(name: string): ValueConverterDecorator;\nexport function valueConverter(nameOrDef: string | PartialValueConverterDefinition): ValueConverterDecorator;\nexport function valueConverter(nameOrDef: string | PartialValueConverterDefinition): ValueConverterDecorator {\n  return function <T extends Constructable>(target: T, context: ClassDecoratorContext): ValueConverterType<T> {\n    context.addInitializer(function (this) {\n      ValueConverter.define(nameOrDef, this as Constructable);\n    });\n    return target as ValueConverterType<T>;\n  };\n}\n\nexport class ValueConverterDefinition<T extends Constructable = Constructable> implements ResourceDefinition<T, ValueConverterInstance> {\n  private constructor(\n    public readonly Type: ValueConverterType<T>,\n    public readonly name: string,\n    public readonly aliases: readonly string[],\n    public readonly key: string,\n  ) {}\n\n  public static create<T extends Constructable = Constructable>(\n    nameOrDef: string | PartialValueConverterDefinition,\n    Type: ValueConverterType<T>,\n  ): ValueConverterDefinition<T> {\n\n    let name: string;\n    let def: PartialValueConverterDefinition;\n    if (isString(nameOrDef)) {\n      name = nameOrDef;\n      def = { name };\n    } else {\n      name = nameOrDef.name;\n      def = nameOrDef;\n    }\n\n    return new ValueConverterDefinition(\n      Type,\n      firstDefined(getConverterAnnotation(Type, 'name'), name),\n      mergeArrays(getConverterAnnotation(Type, 'aliases'), def.aliases, Type.aliases),\n      ValueConverter.keyFrom(name),\n    );\n  }\n\n  public register(container: IContainer, aliasName?: string): void {\n    const $Type = this.Type;\n    const key = typeof aliasName === 'string' ? getValueConverterKeyFrom(aliasName) : this.key;\n    const aliases = this.aliases;\n\n    if (!container.has(key, false)) {\n      container.register(\n        container.has($Type, false) ? null : singletonRegistration($Type, $Type),\n        aliasRegistration($Type, key),\n        ...aliases.map(alias => aliasRegistration($Type, getValueConverterKeyFrom(alias)))\n      );\n    } /* istanbul ignore next */ else if(__DEV__) {\n      // eslint-disable-next-line no-console\n      console.warn(`[DEV:aurelia] ${createMappedError(ErrorNames.value_converter_existed, this.name)}`);\n    }\n  }\n}\n\n/** @internal */ export const converterTypeName = 'value-converter';\nconst vcBaseName = /*@__PURE__*/getResourceKeyFor(converterTypeName);\nconst getConverterAnnotation = <K extends keyof PartialValueConverterDefinition>(\n  Type: Constructable,\n  prop: K,\n): PartialValueConverterDefinition[K] | undefined => getMetadata(getAnnotationKeyFor(prop), Type);\n\nconst getValueConverterKeyFrom = (name: string): string => `${vcBaseName}:${name}`;\n\nexport const ValueConverter = objectFreeze<ValueConverterKind>({\n  name: vcBaseName,\n  keyFrom: getValueConverterKeyFrom,\n  isType<T>(value: T): value is (T extends Constructable ? ValueConverterType<T> : never) {\n    return isFunction(value)\n      && (hasMetadata(vcBaseName, value) || (value as StaticResourceType).$au?.type === converterTypeName);\n  },\n  define<T extends Constructable<ValueConverterInstance>>(nameOrDef: string | PartialValueConverterDefinition, Type: T): ValueConverterType<T> {\n    const definition = ValueConverterDefinition.create(nameOrDef, Type as Constructable<ValueConverterInstance>);\n    const $Type = definition.Type as ValueConverterType<T>;\n\n    // registration of resource name is a requirement for the resource system in kernel (module-loader)\n    defineMetadata(definition, $Type, vcBaseName, resourceBaseName);\n\n    return $Type;\n  },\n  getDefinition<T extends Constructable>(Type: T): ValueConverterDefinition<T> {\n    const def = getMetadata<ValueConverterDefinition<T>>(vcBaseName, Type) ?? getDefinitionFromStaticAu<ValueConverterDefinition<T>, ValueConverterType<T>>(Type as ValueConverterType, converterTypeName, ValueConverterDefinition.create);\n    if (def === void 0) {\n      throw createMappedError(ErrorNames.value_converter_def_not_found, Type);\n    }\n\n    return def;\n  },\n  annotate<K extends keyof PartialValueConverterDefinition>(Type: Constructable, prop: K, value: PartialValueConverterDefinition[K]): void {\n    defineMetadata(value, Type, getAnnotationKeyFor(prop));\n  },\n  getAnnotation: getConverterAnnotation,\n  find(container, name) {\n    const Type = container.find<ValueConverterType>(converterTypeName, name);\n    return Type == null\n      ? null\n      : getMetadata<ValueConverterDefinition>(vcBaseName, Type) ?? getDefinitionFromStaticAu<ValueConverterDefinition, ValueConverterType>(Type, converterTypeName, ValueConverterDefinition.create) ?? null;\n  },\n  get(container, name) {\n    if (__DEV__) {\n      try {\n        return container.get<ValueConverterInstance>(resource(getValueConverterKeyFrom(name)));\n      } catch (ex) {\n        // eslint-disable-next-line no-console\n        console.error('[DEV:aurelia] Cannot retrieve value converter with name', name);\n        throw ex;\n      }\n    }\n    return container.get<ValueConverterInstance>(resource(getValueConverterKeyFrom(name)));\n  },\n});\n", "import { type IServiceLocator, Key, type Constructable, IDisposable, IContainer } from '@aurelia/kernel';\nimport { ITask } from '@aurelia/platform';\nimport { type ISubscriber, astEvaluate, type Scope } from '@aurelia/runtime';\nimport { type IBinding, type IRateLimitOptions } from './interfaces-bindings';\nimport { BindingBehavior, BindingBehaviorInstance } from '../resources/binding-behavior';\nimport { ValueConverter, ValueConverterInstance } from '../resources/value-converter';\nimport { addSignalListener, defineHiddenProp, removeSignalListener, tsPending } from '../utilities';\nimport { createInterface } from '../utilities-di';\nimport { PropertyBinding } from './property-binding';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { ISignaler } from '../signaler';\n\n/**\n * A subscriber that is used for subcribing to target observer & invoking `updateSource` on a binding\n */\nexport class BindingTargetSubscriber implements ISubscriber {\n  /** @internal */\n  private readonly b: PropertyBinding;\n  // flush queue is a way to handle the notification order in a synchronous change notification system\n  // without a flush queue, changes are notified depth first\n  // with    a flush queue, changes are notified breadth first\n  //\n  // though we are only queueing target->source direction and that's already enough to prevent such issues\n  /** @internal */\n  private readonly _flushQueue: IFlushQueue;\n  /** @internal */\n  private _value: unknown = void 0;\n\n  public constructor(\n    b: PropertyBinding,\n    // flush queue is a way to handle the notification order in a synchronous change notification system\n    // without a flush queue, changes are notified depth first\n    // with    a flush queue, changes are notified breadth first\n    flushQueue: IFlushQueue,\n  ) {\n    this.b = b;\n    this._flushQueue = flushQueue;\n  }\n\n  public flush() {\n    this.b.updateSource(this._value);\n  }\n\n  // deepscan-disable-next-line\n  public handleChange(value: unknown, _: unknown): void {\n    const b = this.b;\n    if (value !== astEvaluate(b.ast, b._scope!, b, null)) {\n      this._value = value;\n      this._flushQueue.add(this);\n    }\n  }\n}\n\n/**\n * Implement method `useScope` in a common way for a binding. For internal use only for size saving.\n */\nexport const mixinUseScope = /*@__PURE__*/(() => {\n  function useScope<T extends { _scope?: Scope }>(this: T, scope: Scope) {\n    this._scope = scope;\n  }\n  return <T extends { _scope?: Scope }>(target: Constructable<T>) => {\n    defineHiddenProp(target.prototype, 'useScope', useScope);\n  };\n})();\n\n/**\n * Turns a class into AST evaluator with support for value converter & binding behavior. For internal use only\n */\nexport const mixinAstEvaluator = /*@__PURE__*/(() => {\n  type IHasServiceLocator = { l: IServiceLocator };\n\n  class ResourceLookup {\n    [key: string]: ValueConverterInstance | BindingBehaviorInstance;\n  }\n\n  const converterResourceLookupCache = new WeakMap<{ l: IServiceLocator }, Record<string, ValueConverterInstance>>();\n  const behaviorResourceLookupCache = new WeakMap<{ l: IServiceLocator }, Record<string, BindingBehaviorInstance>>();\n  const appliedBehaviors = new WeakMap<{ l: IServiceLocator }, Record<string, boolean>>();\n\n  function evaluatorGet<T extends IHasServiceLocator>(this: T, key: Key) {\n    return this.l.get(key);\n  }\n  function evaluatorGetBehavior<T extends IHasServiceLocator>(b: T, name: string) {\n    let resourceLookup = behaviorResourceLookupCache.get(b);\n    if (resourceLookup == null) {\n      behaviorResourceLookupCache.set(b, resourceLookup = new ResourceLookup() as Record<string, BindingBehaviorInstance>);\n    }\n    return resourceLookup[name] ??= BindingBehavior.get(b.l, name);\n  }\n  function evaluatorBindBehavior<T extends IHasServiceLocator>(this: T, name: string, scope: Scope, args: unknown[]) {\n    const behavior = evaluatorGetBehavior(this, name);\n    if (behavior == null) {\n      throw createMappedError(ErrorNames.ast_behavior_not_found, name);\n    }\n\n    let applied = appliedBehaviors.get(this);\n    if (applied == null) {\n      appliedBehaviors.set(this, applied = {});\n    }\n    if (applied[name]) {\n      throw createMappedError(ErrorNames.ast_behavior_duplicated, name);\n    }\n    // todo: remove casting\n    // there should be a base \"mixinAstEvaluator\" factory that takes parameters to handle behaviors/converters\n    // so observation infra can be free of template oriented features: behaviors/converters\n    // or anything that is not supposed to be supporting binding behavior shouldn't be using this mixin\n    behavior.bind?.(scope, this as unknown as IBinding, ...args);\n  }\n\n  function evaluatorUnbindBehavior<T extends IHasServiceLocator>(this: T, name: string, scope: Scope) {\n    const behavior = evaluatorGetBehavior(this, name);\n    const applied = appliedBehaviors.get(this);\n\n    // todo: remove casting\n    // there should be a base \"mixinAstEvaluator\" factory that takes parameters to handle behaviors/converters\n    // so observation infra can be free of template oriented features: behaviors/converters\n    // or anything that is not supposed to be supporting binding behavior shouldn't be using this mixin\n    behavior?.unbind?.(scope, this as unknown as IBinding);\n    if (applied != null) {\n      applied[name] = false;\n    }\n  }\n\n  function evaluatorGetConverter<T extends IHasServiceLocator>(b: T, name: string) {\n    let resourceLookup = converterResourceLookupCache.get(b);\n    if (resourceLookup == null) {\n      converterResourceLookupCache.set(b, resourceLookup = new ResourceLookup() as Record<string, ValueConverterInstance>);\n    }\n    return resourceLookup[name] ??= ValueConverter.get(b.l as IContainer, name);\n  }\n  function evaluatorBindConverter<T extends IHasServiceLocator>(this: T, name: string) {\n    const vc = evaluatorGetConverter(this, name);\n    if (vc == null) {\n      throw createMappedError(ErrorNames.ast_converter_not_found, name);\n    }\n    const signals = vc.signals;\n    if (signals != null) {\n      const signaler = this.l.get(ISignaler);\n      const ii = signals.length;\n      let i = 0;\n      for (; i < ii; ++i) {\n        // note: the cast is expected. To connect, it just needs to be a IConnectable\n        // though to work with signal, it needs to have `handleChange`\n        // so having `handleChange` as a guard in the connectable as a safe measure is needed\n        // to make sure signaler works\n        signaler.addSignalListener(signals[i], this as unknown as ISubscriber);\n      }\n    }\n  }\n\n  function evaluatorUnbindConverter<T extends IHasServiceLocator>(this: T, name: string) {\n    const vc = evaluatorGetConverter(this, name);\n    if (vc?.signals === void 0) {\n      return;\n    }\n    const signaler = this.l.get(ISignaler);\n    let i = 0;\n    for (; i < vc.signals.length; ++i) {\n      signaler.removeSignalListener(vc.signals[i], this as unknown as ISubscriber);\n    }\n  }\n\n  function evaluatorUseConverter<T extends IHasServiceLocator>(this: T, name: string, mode: 'toView' | 'fromView', value: unknown, args: unknown[]) {\n    const vc = evaluatorGetConverter(this, name);\n    if (vc == null) {\n      throw createMappedError(ErrorNames.ast_converter_not_found, name);\n    }\n    switch (mode) {\n      case 'toView':\n        return 'toView' in vc ? vc.toView(value, ...args) : value;\n      case 'fromView':\n        return 'fromView' in vc ? vc.fromView?.(value, ...args) : value;\n    }\n  }\n\n  return <T extends IHasServiceLocator>(target: Constructable<T>) => {\n    const proto = target.prototype;\n    defineHiddenProp(proto, 'get', evaluatorGet<T>);\n    defineHiddenProp(proto, 'bindBehavior', evaluatorBindBehavior<T>);\n    defineHiddenProp(proto, 'unbindBehavior', evaluatorUnbindBehavior<T>);\n    defineHiddenProp(proto, 'bindConverter', evaluatorBindConverter<T>);\n    defineHiddenProp(proto, 'unbindConverter', evaluatorUnbindConverter<T>);\n    defineHiddenProp(proto, 'useConverter', evaluatorUseConverter<T>);\n  };\n})();\n\nexport interface IFlushable {\n  flush(): void;\n}\n\nexport const IFlushQueue = /*@__PURE__*/createInterface<IFlushQueue>('IFlushQueue', x => x.singleton(FlushQueue));\nexport interface IFlushQueue {\n  get count(): number;\n  add(flushable: IFlushable): void;\n}\n\nexport class FlushQueue implements IFlushQueue {\n  /** @internal */\n  private _flushing: boolean = false;\n  /** @internal */\n  private readonly _items: Set<IFlushable> = new Set();\n\n  public get count(): number {\n    return this._items.size;\n  }\n\n  public add(flushable: IFlushable): void {\n    this._items.add(flushable);\n    if (this._flushing) {\n      return;\n    }\n    this._flushing = true;\n    try {\n      this._items.forEach(flushItem);\n    } finally {\n      this._flushing = false;\n    }\n  }\n\n  public clear(): void {\n    this._items.clear();\n    this._flushing = false;\n  }\n}\n\nconst flushItem = function (item: IFlushable, _: IFlushable, items: Set<IFlushable>) {\n  items.delete(item);\n  item.flush();\n};\n\n/**\n * A mixing for bindings to implement a set of default behvaviors for rate limiting their calls.\n *\n * For internal use only\n */\nexport const mixingBindingLimited = /*@__PURE__*/ (() => {\n  const withLimitationBindings = new WeakSet<IBinding>();\n  /**\n   * A helper for creating rated limited functions for binding. For internal use only\n   */\n  const debounced = <T extends (v?: unknown) => unknown>(opts: IRateLimitOptions, callOriginal: T, binding: IBinding): LimiterHandle => {\n    let limiterTask: ITask | undefined;\n    let task: ITask | undefined;\n    let latestValue: unknown;\n    let isPending = false;\n    const taskQueue = opts.queue;\n    const callOriginalCallback = () => callOriginal(latestValue);\n    const fn = (v: unknown) => {\n      latestValue = v;\n      if (binding.isBound) {\n        task = limiterTask;\n        limiterTask = taskQueue.queueTask(callOriginalCallback, { delay: opts.delay });\n        task?.cancel();\n      } else {\n        callOriginalCallback();\n      }\n    };\n    const dispose = fn.dispose = () => {\n      task?.cancel();\n      limiterTask?.cancel();\n      task = limiterTask = void 0;\n    };\n    fn.flush = () => {\n      // only call callback when there's actually task being queued\n      isPending = limiterTask?.status === tsPending;\n      dispose();\n      if (isPending) {\n        callOriginalCallback();\n      }\n    };\n\n    return fn;\n  };\n\n  /**\n   * A helper for creating rated limited functions for binding. For internal use only\n   */\n  const throttled = <T extends (v?: unknown) => unknown>(opts: IRateLimitOptions, callOriginal: T, binding: IBinding): LimiterHandle => {\n    let limiterTask: ITask | undefined;\n    let task: ITask | undefined;\n    let last: number = 0;\n    let elapsed = 0;\n    let latestValue: unknown;\n    let isPending = false;\n    const taskQueue = opts.queue;\n    const now = () => opts.now();\n    const callOriginalCallback = () => callOriginal(latestValue);\n    const fn = (v: unknown) => {\n      latestValue = v;\n      if (binding.isBound) {\n        elapsed = now() - last;\n        task = limiterTask;\n        if (elapsed > opts.delay) {\n          last = now();\n          callOriginalCallback();\n        } else {\n          // Queue the new one before canceling the old one, to prevent early yield\n          limiterTask = taskQueue.queueTask(() => {\n            last = now();\n            callOriginalCallback();\n          }, { delay: opts.delay - elapsed });\n        }\n        task?.cancel();\n      } else {\n        callOriginalCallback();\n      }\n    };\n    const dispose = fn.dispose = () => {\n      task?.cancel();\n      limiterTask?.cancel();\n      task = limiterTask = void 0;\n    };\n    fn.flush = () => {\n      // only call callback when there's actually task being queued\n      isPending = limiterTask?.status === tsPending;\n      dispose();\n      if (isPending) {\n        callOriginalCallback();\n      }\n    };\n    return fn;\n  };\n\n  type LimiterHandle = IDisposable & {\n    (v: unknown, oV?: unknown): void;\n    flush(): void;\n  };\n\n  return <T extends IBinding>(target: Constructable<T>, getMethodName: (binding: T, opts: IRateLimitOptions) => keyof T) => {\n    defineHiddenProp(target.prototype, 'limit', function (this: T, opts: IRateLimitOptions) {\n      if (withLimitationBindings.has(this)) {\n        throw createMappedError(ErrorNames.binding_already_has_rate_limited);\n      }\n      withLimitationBindings.add(this);\n      const prop = getMethodName(this, opts);\n      const signals = opts.signals;\n      const signaler = signals.length > 0 ? this.get(ISignaler) : null;\n      const originalFn = this[prop] as unknown as (...args: unknown[]) => unknown;\n      const callOriginal = (...args: unknown[]) => originalFn.call(this, ...args);\n      const limitedFn = opts.type === 'debounce'\n        ? debounced(opts, callOriginal, this)\n        : throttled(opts, callOriginal, this);\n      const signalListener = signaler ? { handleChange: limitedFn.flush } : null;\n      this[prop] = limitedFn as unknown as typeof this[typeof prop];\n      if (signaler) {\n        signals.forEach(s => addSignalListener(signaler, s, signalListener!));\n      }\n\n      return {\n        dispose: () => {\n          if (signaler) {\n            signals.forEach(s => removeSignalListener(signaler, s, signalListener!));\n          }\n          withLimitationBindings.delete(this);\n          limitedFn.dispose();\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete this[prop];\n        }\n      };\n    });\n  };\n})();\n\nexport const createPrototypeMixer = ((mixed = new WeakSet<Constructable<IBinding>>()) => {\n  return (mixer: () => void) => {\n    return function<T extends Constructable<IBinding>>(this: T) {\n      if (!mixed.has(this)) {\n        mixed.add(this);\n        mixer.call(this);\n      }\n    };\n  };\n})();\n", "import { type IServiceLocator, isString } from '@aurelia/kernel';\nimport {\n  connectable,\n  type IObserverLocator,\n  IObserverLocatorBasedConnectable,\n  ISubscriber,\n  ICollectionSubscriber,\n  astBind,\n  astEvaluate,\n  astUnbind,\n  type IAstEvaluator,\n  type Scope,\n} from '@aurelia/runtime';\nimport { activating } from '../templating/controller';\nimport { createPrototypeMixer, mixinAstEvaluator, mixinUseScope, mixingBindingLimited } from './binding-utils';\nimport { oneTime, toView } from './interfaces-bindings';\n\nimport type {\n  ITask,\n  QueueTaskOptions,\n  TaskQueue\n} from '@aurelia/platform';\nimport type { INode } from '../dom';\nimport type { IBinding, BindingMode, IBindingController } from './interfaces-bindings';\nimport { safeString } from '../utilities';\nimport { ForOfStatement, IsBindingBehavior } from '@aurelia/expression-parser';\n\nconst taskOptions: QueueTaskOptions = {\n  preempt: true,\n};\n\n// the 2 interfaces implemented come from mixin\nexport interface AttributeBinding extends IAstEvaluator, IServiceLocator, IObserverLocatorBasedConnectable {}\n\n/**\n * Attribute binding. Handle attribute binding betwen view/view model. Understand Html special attributes\n */\nexport class AttributeBinding implements IBinding, ISubscriber, ICollectionSubscriber {\n  /** @internal */\n  public static mix = /*@__PURE__*/ createPrototypeMixer(() => {\n      mixinUseScope(AttributeBinding);\n      mixingBindingLimited(AttributeBinding, () => 'updateTarget');\n      connectable(AttributeBinding, null!);\n      mixinAstEvaluator(AttributeBinding);\n  });\n\n  public isBound: boolean = false;\n  /** @internal */\n  public _scope?: Scope = void 0;\n\n  /** @internal */\n  private _task: ITask | null = null;\n\n  public target: HTMLElement;\n\n  /** @internal */\n  private _value: unknown = void 0;\n\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  private readonly _controller: IBindingController;\n\n  /** @internal */\n  private readonly _taskQueue: TaskQueue;\n\n  /** @internal */\n  public readonly l: IServiceLocator;\n\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  public ast: IsBindingBehavior | ForOfStatement;\n\n  public constructor(\n    controller: IBindingController,\n    locator: IServiceLocator,\n    observerLocator: IObserverLocator,\n    taskQueue: TaskQueue,\n    ast: IsBindingBehavior | ForOfStatement,\n    target: INode,\n    // some attributes may have inner structure\n    // such as class -> collection of class names\n    // such as style -> collection of style rules\n    //\n    // for normal attributes, targetAttribute and targetProperty are the same and can be ignore\n    public targetAttribute: string,\n    public targetProperty: string,\n    public mode: BindingMode,\n    public strict: boolean,\n  ) {\n    this.l = locator;\n    this.ast = ast;\n    this._controller = controller;\n    this.target = target as HTMLElement;\n    this.oL = observerLocator;\n    this._taskQueue = taskQueue;\n  }\n\n  public updateTarget(value: unknown): void {\n    const target = this.target;\n    const targetAttribute = this.targetAttribute;\n    const targetProperty = this.targetProperty;\n\n    switch (targetAttribute) {\n      case 'class':\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        target.classList.toggle(targetProperty, !!value);\n        break;\n      case 'style': {\n        let priority = '';\n        let newValue = safeString(value);\n        if (isString(newValue) && newValue.includes('!important')) {\n          priority = 'important';\n          newValue = newValue.replace('!important', '');\n        }\n        target.style.setProperty(targetProperty, newValue, priority);\n        break;\n      }\n      default: {\n        if (value == null) {\n          target.removeAttribute(targetAttribute);\n        } else {\n          target.setAttribute(targetAttribute, safeString(value));\n        }\n      }\n    }\n  }\n\n  public handleChange(): void {\n    if (!this.isBound) {\n      /* istanbul-ignore-next */\n      return;\n    }\n\n    let task: ITask | null;\n    this.obs.version++;\n    const newValue = astEvaluate(\n      this.ast,\n      this._scope!,\n      this,\n      // should observe?\n      (this.mode & toView) > 0 ? this : null\n    );\n    this.obs.clear();\n\n    if (newValue !== this._value) {\n      this._value = newValue;\n      const shouldQueueFlush = this._controller.state !== activating;\n      if (shouldQueueFlush) {\n        // Queue the new one before canceling the old one, to prevent early yield\n        task = this._task;\n        this._task = this._taskQueue.queueTask(() => {\n          this._task = null;\n          this.updateTarget(newValue);\n        }, taskOptions);\n        task?.cancel();\n      } else {\n        this.updateTarget(newValue);\n      }\n    }\n  }\n\n  // todo: based off collection and handle update accordingly instead off always start\n  public handleCollectionChange(): void {\n    this.handleChange();\n  }\n\n  public bind(_scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === _scope) {\n      /* istanbul-ignore-next */\n        return;\n      }\n      this.unbind();\n    }\n    this._scope = _scope;\n\n    astBind(this.ast, _scope, this);\n\n    if (this.mode & (toView | oneTime)) {\n      this.updateTarget(\n        this._value = astEvaluate(this.ast, _scope, this, /* should connect? */(this.mode & toView) > 0 ? this : null)\n      );\n    }\n\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) {\n      /* istanbul-ignore-next */\n      return;\n    }\n    this.isBound = false;\n\n    astUnbind(this.ast, this._scope!, this);\n\n    this._scope = void 0;\n    this._value = void 0;\n\n    this._task?.cancel();\n    this._task = null;\n    this.obs.clearAll();\n  }\n}\n", "import { type IServiceLocator, isArray } from '@aurelia/kernel';\nimport {\n  connectable,\n  astBind,\n  astEvaluate,\n  astUnbind,\n  IAstEvaluator,\n} from '@aurelia/runtime';\nimport { activating } from '../templating/controller';\nimport { createPrototypeMixer, mixinAstEvaluator, mixinUseScope, mixingBindingLimited } from './binding-utils';\nimport { toView } from './interfaces-bindings';\n\nimport type { ITask, QueueTaskOptions, TaskQueue } from '@aurelia/platform';\nimport type {\n  AccessorOrObserver,\n  IAccessor,\n  ICollectionSubscriber,\n  IObserverLocator,\n  IObserverLocatorBasedConnectable,\n  ISubscriber,\n  Scope,\n} from '@aurelia/runtime';\nimport { atLayout } from '../utilities';\nimport type { IBinding, BindingMode, IBindingController } from './interfaces-bindings';\nimport { type Interpolation, IsExpression } from '@aurelia/expression-parser';\n\nconst queueTaskOptions: QueueTaskOptions = {\n  preempt: true,\n};\n\n// a pseudo binding to manage multiple InterpolationBinding s\n// ========\n// Note: the child expressions of an Interpolation expression are full Aurelia expressions, meaning they may include\n// value converters and binding behaviors.\n// Each expression represents one ${interpolation}, and for each we create a child InterpolationPartBinding\n\nexport interface InterpolationBinding extends IObserverLocatorBasedConnectable, IAstEvaluator, IServiceLocator {}\nexport class InterpolationBinding implements IBinding, ISubscriber, ICollectionSubscriber {\n  public isBound: boolean = false;\n\n  /** @internal */\n  public _scope?: Scope = void 0;\n\n  public partBindings: InterpolationPartBinding[];\n\n  /** @internal */\n  private _targetObserver: AccessorOrObserver;\n\n  /** @internal */\n  private _task: ITask | null = null;\n\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  private readonly _taskQueue: TaskQueue;\n\n  /** @internal */\n  private readonly _controller: IBindingController;\n\n  public constructor(\n    controller: IBindingController,\n    locator: IServiceLocator,\n    observerLocator: IObserverLocator,\n    taskQueue: TaskQueue,\n    public ast: Interpolation,\n    public target: object,\n    public targetProperty: string,\n    public mode: BindingMode,\n    public strict: boolean,\n  ) {\n    this._controller = controller;\n    this.oL = observerLocator;\n    this._taskQueue = taskQueue;\n    this._targetObserver = observerLocator.getAccessor(target, targetProperty);\n    const expressions = ast.expressions;\n    const partBindings = this.partBindings = Array(expressions.length);\n    const ii = expressions.length;\n    let i = 0;\n    for (; ii > i; ++i) {\n      partBindings[i] = new InterpolationPartBinding(expressions[i], target, targetProperty, locator, observerLocator, strict, this);\n    }\n  }\n\n  /** @internal */\n  public _handlePartChange() {\n    this.updateTarget();\n  }\n\n  public updateTarget(): void {\n    const partBindings = this.partBindings;\n    const staticParts = this.ast.parts;\n    const ii = partBindings.length;\n    let result = '';\n    let i = 0;\n    if (ii === 1) {\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      result = staticParts[0] + partBindings[0]._value + staticParts[1];\n    } else {\n      result = staticParts[0];\n      for (; ii > i; ++i) {\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        result += partBindings[i]._value + staticParts[i + 1];\n      }\n    }\n\n    const targetObserver = this._targetObserver;\n    // Alpha: during bind a simple strategy for bind is always flush immediately\n    // todo:\n    //  (1). determine whether this should be the behavior\n    //  (2). if not, then fix tests to reflect the changes/platform to properly yield all with aurelia.start()\n    const shouldQueueFlush = this._controller.state !== activating && (targetObserver.type & atLayout) > 0;\n    let task: ITask | null;\n    if (shouldQueueFlush) {\n      // Queue the new one before canceling the old one, to prevent early yield\n      task = this._task;\n      this._task = this._taskQueue.queueTask(() => {\n        this._task = null;\n        targetObserver.setValue(result, this.target, this.targetProperty);\n      }, queueTaskOptions);\n      task?.cancel();\n      task = null;\n    } else {\n      targetObserver.setValue(result, this.target, this.targetProperty);\n    }\n  }\n\n  public bind(_scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === _scope) {\n        /* istanbul-ignore-next */\n        return;\n      }\n      this.unbind();\n    }\n    this._scope = _scope;\n\n    const partBindings = this.partBindings;\n    const ii = partBindings.length;\n    let i = 0;\n    for (; ii > i; ++i) {\n      partBindings[i].bind(_scope);\n    }\n    this.updateTarget();\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) {\n        /* istanbul-ignore-next */\n      return;\n    }\n    this.isBound = false;\n    this._scope = void 0;\n    const partBindings = this.partBindings;\n    const ii = partBindings.length;\n    let i = 0;\n    for (; ii > i; ++i) {\n      partBindings[i].unbind();\n    }\n    this._task?.cancel();\n    this._task = null;\n  }\n\n  /**\n   * Start using a given observer to update the target\n   */\n  public useAccessor(accessor: IAccessor): void {\n    this._targetObserver = accessor;\n  }\n}\n\n// a pseudo binding, part of a larger interpolation binding\n// employed to support full expression per expression part of an interpolation\nexport interface InterpolationPartBinding extends IAstEvaluator, IObserverLocatorBasedConnectable, IServiceLocator {}\n\nexport class InterpolationPartBinding implements IBinding, ICollectionSubscriber {\n  /** @internal */\n  public static mix = /*@__PURE__*/ createPrototypeMixer(() => {\n    mixinUseScope(InterpolationPartBinding);\n    mixingBindingLimited(InterpolationPartBinding, () => 'updateTarget');\n    connectable(InterpolationPartBinding, null!);\n    mixinAstEvaluator(InterpolationPartBinding);\n  });\n\n  // at runtime, mode may be overriden by binding behavior\n  // but it wouldn't matter here, just start with something for later check\n  public readonly mode: BindingMode = toView;\n  public _scope?: Scope;\n  public task: ITask | null = null;\n  public isBound: boolean = false;\n\n  /** @internal */\n  public _value: unknown = '';\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  public readonly l: IServiceLocator;\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  public constructor(\n    public readonly ast: IsExpression,\n    public readonly target: object,\n    public readonly targetProperty: string,\n    locator: IServiceLocator,\n    observerLocator: IObserverLocator,\n    public strict: boolean,\n    public readonly owner: InterpolationBinding,\n  ) {\n    this.l = locator;\n    this.oL = observerLocator;\n  }\n\n  public updateTarget() {\n    this.owner._handlePartChange();\n  }\n\n  public handleChange(): void {\n    if (!this.isBound) {\n        /* istanbul-ignore-next */\n      return;\n    }\n    this.obs.version++;\n    const newValue = astEvaluate(\n      this.ast,\n      this._scope!,\n      this,\n      // should observe?\n      (this.mode & toView) > 0 ? this : null\n    );\n    this.obs.clear();\n    // todo(!=): maybe should do strict comparison?\n    // eslint-disable-next-line eqeqeq\n    if (newValue != this._value) {\n      this._value = newValue;\n      if (isArray(newValue)) {\n        this.observeCollection(newValue);\n      }\n      this.updateTarget();\n    }\n  }\n\n  public handleCollectionChange(): void {\n    this.updateTarget();\n  }\n\n  public bind(_scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === _scope) {\n        /* istanbul-ignore-next */\n        return;\n      }\n      this.unbind();\n    }\n    this._scope = _scope;\n\n    astBind(this.ast, _scope, this);\n\n    this._value = astEvaluate(\n      this.ast,\n      this._scope,\n      this,\n      (this.mode & toView) > 0 ?  this : null,\n    );\n    if (isArray(this._value)) {\n      this.observeCollection(this._value);\n    }\n\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) {\n        /* istanbul-ignore-next */\n      return;\n    }\n    this.isBound = false;\n\n    astUnbind(this.ast, this._scope!, this);\n\n    this._scope = void 0;\n    this.obs.clearAll();\n  }\n}\n", "import {\n  connectable,\n  IAstEvaluator,\n  astBind,\n  astEvaluate,\n  astUnbind,\n} from '@aurelia/runtime';\nimport { activating } from '../templating/controller';\nimport { toView } from './interfaces-bindings';\nimport { type IServiceLocator, isArray } from '@aurelia/kernel';\nimport type { ITask, QueueTaskOptions, TaskQueue } from '@aurelia/platform';\nimport type {\n  ICollectionSubscriber,\n  IObserverLocator,\n  IObserverLocatorBasedConnectable,\n  ISubscriber,\n  Scope,\n} from '@aurelia/runtime';\nimport type { IPlatform } from '../platform';\nimport { safeString } from '../utilities';\nimport type { BindingMode, IBinding, IBindingController } from './interfaces-bindings';\nimport { mixinUseScope, mixingBindingLimited, mixinAstEvaluator, createPrototypeMixer } from './binding-utils';\nimport { IsExpression } from '@aurelia/expression-parser';\n\nconst queueTaskOptions: QueueTaskOptions = {\n  preempt: true,\n};\n\nexport interface ContentBinding extends IAstEvaluator, IServiceLocator, IObserverLocatorBasedConnectable {}\n\n/**\n * A binding for handling the element content interpolation\n */\n\nexport class ContentBinding implements IBinding, ISubscriber, ICollectionSubscriber {\n  /** @internal */\n  public static mix = /*@__PURE__*/ createPrototypeMixer(() => {\n    mixinUseScope(ContentBinding);\n    mixingBindingLimited(ContentBinding, () => 'updateTarget');\n    connectable(ContentBinding, null!);\n    mixinAstEvaluator(ContentBinding);\n  });\n\n  public isBound: boolean = false;\n\n  // at runtime, mode may be overriden by binding behavior\n  // but it wouldn't matter here, just start with something for later check\n  public readonly mode: BindingMode = toView;\n\n  /** @internal */\n  public _scope?: Scope;\n\n  /** @internal */\n  public _task: ITask | null = null;\n\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n  /** @internal */\n  private readonly _taskQueue: TaskQueue;\n\n  /** @internal */\n  public readonly l: IServiceLocator;\n\n  /** @internal */\n  private _value: unknown = '';\n  /** @internal */\n  private readonly _controller: IBindingController;\n  /** @internal */\n  private _needsRemoveNode: boolean = false;\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  public constructor(\n    controller: IBindingController,\n    locator: IServiceLocator,\n    observerLocator: IObserverLocator,\n    taskQueue: TaskQueue,\n    private readonly p: IPlatform,\n    public readonly ast: IsExpression,\n    public readonly target: Text,\n    public strict: boolean,\n  ) {\n    this.l = locator;\n    this._controller = controller;\n    this.oL = observerLocator;\n    this._taskQueue = taskQueue;\n  }\n\n  public updateTarget(value: unknown): void {\n    const target = this.target;\n    const oldValue = this._value;\n    this._value = value;\n    if (this._needsRemoveNode) {\n      (oldValue as Node).parentNode?.removeChild(oldValue as Node);\n      this._needsRemoveNode = false;\n    }\n    if (value instanceof this.p.Node) {\n      target.parentNode?.insertBefore(value, target);\n      value = '';\n      this._needsRemoveNode = true;\n    }\n    // console.log({ value, type: typeof value });\n    target.textContent = safeString(value ?? '');\n  }\n\n  public handleChange(): void {\n    if (!this.isBound) {\n      /* istanbul ignore next */\n      return;\n    }\n    this.obs.version++;\n    const newValue = astEvaluate(\n      this.ast,\n      this._scope!,\n      this,\n      // should observe?\n      (this.mode & toView) > 0 ? this : null\n    );\n    this.obs.clear();\n    if (newValue === this._value) {\n      // in a frequent update, e.g collection mutation in a loop\n      // value could be changing frequently and previous update task may be stale at this point\n      // cancel if any task going on because the latest value is already the same\n      this._task?.cancel();\n      this._task = null;\n      return;\n    }\n    const shouldQueueFlush = this._controller.state !== activating;\n    if (shouldQueueFlush) {\n      this._queueUpdate(newValue);\n    } else {\n      this.updateTarget(newValue);\n    }\n  }\n\n  public handleCollectionChange(): void {\n    if (!this.isBound) {\n      /* istanbul-ignore-next */\n      return;\n    }\n    this.obs.version++;\n    const v = this._value = astEvaluate(\n      this.ast,\n      this._scope!,\n      this,\n      (this.mode & toView) > 0 ? this : null\n    );\n    this.obs.clear();\n    if (isArray(v)) {\n      this.observeCollection(v);\n    }\n    const shouldQueueFlush = this._controller.state !== activating;\n    if (shouldQueueFlush) {\n      this._queueUpdate(v);\n    } else {\n      this.updateTarget(v);\n    }\n  }\n\n  public bind(_scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === _scope) {\n      /* istanbul-ignore-next */\n        return;\n      }\n      this.unbind();\n    }\n    this._scope = _scope;\n\n    astBind(this.ast, _scope, this);\n\n    const v = this._value = astEvaluate(\n      this.ast,\n      this._scope,\n      this,\n      (this.mode & toView) > 0 ? this : null\n    );\n    if (isArray(v)) {\n      this.observeCollection(v);\n    }\n    this.updateTarget(v);\n\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) {\n      /* istanbul-ignore-next */\n      return;\n    }\n    this.isBound = false;\n\n    astUnbind(this.ast, this._scope!, this);\n    if (this._needsRemoveNode) {\n      (this._value as Node).parentNode?.removeChild(this._value as Node);\n    }\n\n    // TODO: should existing value (either connected node, or a string)\n    // be removed when this binding is unbound?\n    // this.updateTarget('');\n    this._scope = void 0;\n    this.obs.clearAll();\n    this._task?.cancel();\n    this._task = null;\n  }\n\n  // queue a force update\n  /** @internal */\n  private _queueUpdate(newValue: unknown): void {\n    const task = this._task;\n    this._task = this._taskQueue.queueTask(() => {\n      this._task = null;\n      this.updateTarget(newValue);\n    }, queueTaskOptions);\n    task?.cancel();\n  }\n}\n", "import {\n  ICollectionSubscriber,\n  IObserverLocatorBasedConnectable,\n  ISubscriber,\n  connectable,\n  type IObservable,\n  type IObserverLocator,\n  type Scope,\n  astBind,\n  astEvaluate,\n  astUnbind,\n  type IAstEvaluator,\n} from '@aurelia/runtime';\nimport { createPrototypeMixer, mixinAstEvaluator, mixinUseScope, mixingBindingLimited } from './binding-utils';\n\nimport type { IIndexable, IServiceLocator } from '@aurelia/kernel';\nimport { IsExpression } from '@aurelia/expression-parser';\nimport { IBinding } from './interfaces-bindings';\nexport interface LetBinding extends IAstEvaluator, IObserverLocatorBasedConnectable, IServiceLocator {}\n\nexport class LetBinding implements IBinding, ISubscriber, ICollectionSubscriber {\n  /**\n   * The renderer can call this method to prepare the prototype,\n   * so that it can be effectively tree shaken before decorator can be officially applied with tree shaking.\n   * @internal\n   */\n  public static mix = /*@__PURE__*/ createPrototypeMixer(() => {\n    mixinUseScope(LetBinding);\n    mixingBindingLimited(LetBinding, () => 'updateTarget');\n    connectable(LetBinding, null!);\n    mixinAstEvaluator(LetBinding);\n  });\n\n  public isBound: boolean = false;\n\n  /** @internal */\n  public _scope?: Scope = void 0;\n\n  public target: (IObservable & IIndexable) | null = null;\n  /** @internal */\n  private readonly _toBindingContext: boolean;\n\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  public l: IServiceLocator;\n\n  /** @internal */\n  private _value: unknown;\n\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  public strict: boolean;\n\n  public constructor(\n    locator: IServiceLocator,\n    observerLocator: IObserverLocator,\n    public ast: IsExpression,\n    public targetProperty: string,\n    toBindingContext: boolean,\n    strict: boolean,\n  ) {\n    this.l = locator;\n    this.oL = observerLocator;\n    this.strict = strict;\n    this._toBindingContext = toBindingContext;\n  }\n\n  public updateTarget() {\n    this.target![this.targetProperty] = this._value;\n  }\n\n  public handleChange(): void {\n    if (!this.isBound) {\n      /* istanbul-ignore-next */\n      return;\n    }\n    this.obs.version++;\n    this._value = astEvaluate(this.ast, this._scope!, this, this);\n    this.obs.clear();\n    this.updateTarget();\n  }\n\n  public handleCollectionChange(): void {\n    this.handleChange();\n  }\n\n  public bind(_scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === _scope) {\n      /* istanbul-ignore-next */\n        return;\n      }\n      this.unbind();\n    }\n    this._scope = _scope;\n    this.target = (this._toBindingContext ? _scope.bindingContext : _scope.overrideContext) as IIndexable;\n\n    astBind(this.ast, _scope, this);\n\n    this._value = astEvaluate(this.ast, this._scope, this, this);\n    this.updateTarget();\n\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) {\n      /* istanbul-ignore-next */\n      return;\n    }\n    this.isBound = false;\n\n    astUnbind(this.ast, this._scope!, this);\n\n    this._scope = void 0;\n    this.obs.clearAll();\n  }\n}\n", "import {\n  connectable,\n  ISubscriber,\n  astAssign,\n  astBind,\n  astEvaluate,\n  astUnbind,\n  IAstEvaluator,\n  type Scope,\n  type AccessorOrObserver,\n  type ICollectionSubscriber,\n  type IObserver,\n  type IObserverLocator,\n  type IObserverLocatorBasedConnectable,\n} from '@aurelia/runtime';\nimport { activating } from '../templating/controller';\nimport { BindingTargetSubscriber, IFlushQueue, createPrototypeMixer, mixinAstEvaluator, mixinUseScope, mixingBindingLimited } from './binding-utils';\nimport { IBinding, fromView, oneTime, toView } from './interfaces-bindings';\n\nimport type { IServiceLocator } from '@aurelia/kernel';\nimport type { ITask, QueueTaskOptions, TaskQueue } from '@aurelia/platform';\nimport type { BindingMode, IBindingController } from './interfaces-bindings';\nimport { createMappedError, ErrorNames } from '../errors';\nimport { atLayout } from '../utilities';\nimport { type IsBindingBehavior, ForOfStatement } from '@aurelia/expression-parser';\n\nexport interface PropertyBinding extends IAstEvaluator, IServiceLocator, IObserverLocatorBasedConnectable {}\n\nexport class PropertyBinding implements IBinding, ISubscriber, ICollectionSubscriber {\n  /** @internal */\n  public static mix = /*@__PURE__*/ createPrototypeMixer(() => {\n    mixinUseScope(PropertyBinding);\n    mixingBindingLimited(PropertyBinding, (propBinding: PropertyBinding) => (propBinding.mode & fromView) ? 'updateSource' : 'updateTarget');\n    connectable(PropertyBinding, null!);\n    mixinAstEvaluator(PropertyBinding);\n  });\n\n  public isBound: boolean = false;\n\n  /** @internal */\n  public _scope?: Scope = void 0;\n\n  /** @internal */\n  private _targetObserver?: AccessorOrObserver = void 0;\n\n  /** @internal */\n  private _task: ITask | null = null;\n\n  /** @internal */\n  private _targetSubscriber: ISubscriber | null = null;\n\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  public l: IServiceLocator;\n\n  /** @internal */\n  private readonly _controller: IBindingController;\n\n  /** @internal */\n  private readonly _taskQueue: TaskQueue;\n\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  public constructor(\n    controller: IBindingController,\n    locator: IServiceLocator,\n    observerLocator: IObserverLocator,\n    taskQueue: TaskQueue,\n    public ast: IsBindingBehavior | ForOfStatement,\n    public target: object,\n    public targetProperty: string,\n    public mode: BindingMode,\n    public strict: boolean,\n  ) {\n    this.l = locator;\n    this._controller = controller;\n    this._taskQueue = taskQueue;\n    this.oL = observerLocator;\n  }\n\n  public updateTarget(value: unknown): void {\n    this._targetObserver!.setValue(value, this.target, this.targetProperty);\n  }\n\n  public updateSource(value: unknown): void {\n    astAssign(this.ast, this._scope!, this, value);\n  }\n\n  public handleChange(): void {\n    if (!this.isBound) {\n      /* istanbul-ignore-next */\n      return;\n    }\n\n    this.obs.version++;\n    const newValue = astEvaluate(\n      this.ast,\n      this._scope!,\n      this,\n      // should observe?\n      (this.mode & toView) > 0 ? this : null\n    );\n    this.obs.clear();\n\n    const shouldQueueFlush = this._controller.state !== activating && (this._targetObserver!.type & atLayout) > 0;\n    if (shouldQueueFlush) {\n      // Queue the new one before canceling the old one, to prevent early yield\n      task = this._task;\n      this._task = this._taskQueue.queueTask(() => {\n        this.updateTarget(newValue);\n        this._task = null;\n      }, updateTaskOpts);\n      task?.cancel();\n      task = null;\n    } else {\n      this.updateTarget(newValue);\n    }\n  }\n\n  // todo: based off collection and handle update accordingly instead off always start\n  public handleCollectionChange(): void {\n    this.handleChange();\n  }\n\n  public bind(scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === scope) {\n      /* istanbul-ignore-next */\n        return;\n      }\n      this.unbind();\n    }\n    this._scope = scope;\n\n    astBind(this.ast, scope, this);\n\n    const observerLocator = this.oL;\n    const $mode = this.mode;\n    let targetObserver = this._targetObserver;\n    if (!targetObserver) {\n      if ($mode & fromView) {\n        targetObserver = observerLocator.getObserver(this.target, this.targetProperty);\n      } else {\n        targetObserver = observerLocator.getAccessor(this.target, this.targetProperty);\n      }\n      this._targetObserver = targetObserver;\n    }\n\n    const shouldConnect = ($mode & toView) > 0;\n\n    if ($mode & (toView | oneTime)) {\n      this.updateTarget(\n        astEvaluate(this.ast, this._scope, this, shouldConnect ? this : null),\n      );\n    }\n\n    if ($mode & fromView) {\n      (targetObserver as IObserver).subscribe(this._targetSubscriber ??= new BindingTargetSubscriber(this, this.l.get(IFlushQueue)));\n      if (!shouldConnect) {\n        this.updateSource(targetObserver.getValue(this.target, this.targetProperty));\n      }\n    }\n\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) {\n      /* istanbul-ignore-next */\n      return;\n    }\n    this.isBound = false;\n\n    astUnbind(this.ast, this._scope!, this);\n\n    this._scope = void 0;\n\n    if (this._targetSubscriber) {\n      (this._targetObserver as IObserver).unsubscribe(this._targetSubscriber);\n      this._targetSubscriber = null;\n    }\n    this._task?.cancel();\n    this._task = null;\n    this.obs.clearAll();\n  }\n\n  /**\n   * Start using a given observer to listen to changes on the target of this binding\n   */\n  public useTargetObserver(observer: IObserver): void {\n    (this._targetObserver as IObserver)?.unsubscribe(this);\n    (this._targetObserver = observer).subscribe(this);\n  }\n\n  /**\n   * Provide a subscriber for target change observation.\n   *\n   * Binding behaviors can use this to setup custom observation handling during bind lifecycle\n   * to alter the update source behavior during bind phase of this binding.\n   */\n  public useTargetSubscriber(subscriber: ISubscriber): void {\n    if (this._targetSubscriber != null) {\n      throw createMappedError(ErrorNames.binding_already_has_target_subscriber);\n    }\n    this._targetSubscriber = subscriber;\n  }\n}\n\nlet task: ITask | null = null;\n\nconst updateTaskOpts: QueueTaskOptions = {\n  preempt: true,\n};\n", "import type { IServiceLocator } from '@aurelia/kernel';\nimport {\n  type ICollectionSubscriber,\n  type IObserverLocatorBasedConnectable,\n  type ISubscriber,\n  type Scope,\n  astAssign,\n  astBind,\n  astEvaluate,\n  astUnbind,\n  type IAstEvaluator,\n} from '@aurelia/runtime';\nimport { createPrototypeMixer, mixinAstEvaluator } from './binding-utils';\nimport { type IsBindingBehavior } from '@aurelia/expression-parser';\nimport { IBinding } from './interfaces-bindings';\n\nexport interface RefBinding extends IAstEvaluator, IObserverLocatorBasedConnectable, IServiceLocator { }\nexport class RefBinding implements IBinding, ISubscriber, ICollectionSubscriber {\n  public static mix = /*@__PURE__*/ createPrototypeMixer(() => {\n    mixinAstEvaluator(RefBinding);\n  });\n\n  public isBound: boolean = false;\n\n  /** @internal */\n  public _scope?: Scope = void 0;\n\n  /** @internal */\n  public l: IServiceLocator;\n\n  public constructor(\n    locator: IServiceLocator,\n    public ast: IsBindingBehavior,\n    public target: object,\n    public strict: boolean,\n  ) {\n    this.l = locator;\n  }\n\n  public bind(_scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === _scope) {\n      /* istanbul-ignore-next */\n        return;\n      }\n\n      this.unbind();\n    }\n    this._scope = _scope;\n\n    astBind(this.ast, _scope, this);\n\n    astAssign(this.ast, this._scope, this, this.target);\n\n    // add isBound flag and remove isBinding flag\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) {\n      /* istanbul-ignore-next */\n      return;\n    }\n    this.isBound = false;\n\n    if (astEvaluate(this.ast, this._scope!, this, null) === this.target) {\n      astAssign(this.ast, this._scope!, this, null);\n    }\n\n    astUnbind(this.ast, this._scope!, this);\n\n    this._scope = void 0;\n  }\n}\n", "import { type IsBindingBehavior } from '@aurelia/expression-parser';\nimport { isArray, isFunction, isString, resolve, type IServiceLocator, all, IContainer } from '@aurelia/kernel';\nimport { objectFreeze } from '../utilities';\nimport { createInterface, singletonRegistration } from '../utilities-di';\nimport { createPrototypeMixer, mixinAstEvaluator, mixinUseScope, mixingBindingLimited } from './binding-utils';\n\nimport {\n  ICollectionSubscriber,\n  IObserverLocatorBasedConnectable,\n  ISubscriber,\n  type Scope,\n  astBind,\n  astEvaluate,\n  astUnbind,\n  IAstEvaluator,\n} from '@aurelia/runtime';\nimport { IBinding } from './interfaces-bindings';\n\nexport class ListenerBindingOptions {\n  public constructor(\n    public readonly prevent: boolean,\n    public readonly capture: boolean = false,\n    public readonly onError: (event: Event, error: unknown) => void,\n  ) {}\n}\n\nexport interface ListenerBinding extends IAstEvaluator, IObserverLocatorBasedConnectable, IServiceLocator {}\n/**\n * Listener binding. Handle event binding between view and view model\n */\nexport class ListenerBinding implements IBinding, ISubscriber, ICollectionSubscriber {\n  /** @internal */\n  public static mix = createPrototypeMixer(function () {\n    mixinUseScope(ListenerBinding);\n    mixingBindingLimited(ListenerBinding, () => 'callSource');\n    mixinAstEvaluator(ListenerBinding);\n  });\n\n  public isBound: boolean = false;\n\n  /** @internal */\n  public _scope?: Scope;\n\n  /** @internal */\n  private readonly _options: ListenerBindingOptions;\n\n  /** @internal */\n  public l: IServiceLocator;\n\n  /**\n   * Whether this binding only handles events originate from the target this binding is bound to\n   */\n  public self: boolean = false;\n\n  /**\n   * Indicates if this binding evaluates an ast and get a function, that function should be bound\n   * to the instance it is on\n   *\n   * @internal\n   */\n  public readonly boundFn = true;\n\n  /** @internal */\n  private readonly _modifiedEventHandler: IModifiedEventHandler | null = null;\n\n  public constructor(\n    locator: IServiceLocator,\n    public ast: IsBindingBehavior,\n    public target: Node,\n    public targetEvent: string,\n    options: ListenerBindingOptions,\n    modifiedEventHandler: IModifiedEventHandler | null,\n    public strict: boolean,\n  ) {\n    this.l = locator;\n    this._options = options;\n    this._modifiedEventHandler = modifiedEventHandler;\n  }\n\n  public callSource(event: Event): void {\n    const overrideContext = this._scope!.overrideContext;\n    overrideContext.$event = event;\n\n    // let result\n    let result = astEvaluate(this.ast, this._scope!, this, null);\n    // try {\n    // } catch (ex) {\n    //   console.log(ex);\n    // }\n\n    delete overrideContext.$event;\n\n    if (isFunction(result)) {\n      result = result(event);\n    }\n\n    if (result !== true && this._options.prevent) {\n      event.preventDefault();\n    }\n  }\n\n  public handleEvent(event: Event): void {\n    if (this.self) {\n      if (this.target !== event.composedPath()[0]) {\n      /* istanbul ignore next */\n        return;\n      }\n    }\n    if (this._modifiedEventHandler?.(event) !== false) {\n      try {\n        this.callSource(event);\n      } catch (ex) {\n        this._options.onError(event, ex);\n      }\n    }\n  }\n\n  public bind(scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === scope) {\n      /* istanbul ignore next */\n        return;\n      }\n      this.unbind();\n    }\n    this._scope = scope;\n\n    astBind(this.ast, scope, this);\n\n    this.target.addEventListener(this.targetEvent, this, this._options);\n\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) {\n      /* istanbul ignore next */\n      return;\n    }\n    this.isBound = false;\n\n    astUnbind(this.ast, this._scope!, this);\n\n    this._scope = void 0;\n    this.target.removeEventListener(this.targetEvent, this, this._options);\n  }\n}\n\nexport type IModifiedEventHandler = (event: Event) => boolean;\n\nexport interface IModifiedEventHandlerCreator {\n  readonly type: string | string[];\n  getHandler(modifier: string): IModifiedEventHandler;\n}\nexport const IModifiedEventHandlerCreator = /*@__PURE__*/createInterface<IModifiedEventHandlerCreator>('IEventModifier');\n\nexport interface IKeyMapping {\n  readonly meta: string[];\n  readonly keys: Record</* modifier */string, /* key */ string>;\n}\nexport const IKeyMapping = /*@__PURE__*/createInterface<IKeyMapping>('IKeyMapping', x => x.instance({\n  meta: objectFreeze(['ctrl', 'alt', 'shift', 'meta']) as string[],\n  keys: {\n    escape: 'Escape',\n    enter: 'Enter',\n    space: 'Space',\n    tab: 'tab',\n    // by default, maps the key a-z and A-Z to their respective keycodes\n    ...Array.from({ length: 25 }).reduce((acc: Record<string, string>, _, idx) => {\n      // map keycode of upper case character from A-Z\n      let char = String.fromCharCode(idx + 65);\n      acc[idx + 65] = char;\n\n      // map keycode and character code of lower case character from a-z\n      char = String.fromCharCode(idx + 97);\n      acc[idx + 97] = acc[char] = char;\n      return acc;\n    }, {})\n  },\n}));\n\nclass ModifiedMouseEventHandler implements IModifiedEventHandlerCreator {\n  public static register(c: IContainer) {\n    c.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedMouseEventHandler));\n  }\n\n  public readonly type = ['click', 'mousedown', 'mousemove', 'mouseup', 'dblclick', 'contextmenu'];\n  /** @internal */\n  private readonly _mapping = resolve(IKeyMapping);\n  /** @internal */\n  private readonly _mouseButtons = ['left', 'middle', 'right'];\n\n  public getHandler(modifier: string): IModifiedEventHandler {\n    const modifiers = modifier.split(/[:+.]/);\n    if (__DEV__) {\n      // verify modifiers and add warnings if necessary\n    }\n    return ((event: MouseEvent) => {\n      let prevent = false;\n      let stop = false;\n      let m: string;\n\n      for (m of modifiers) {\n        switch (m) {\n          case 'prevent': prevent = true; continue;\n          case 'stop': stop = true; continue;\n          case 'left':\n          case 'middle':\n          case 'right':\n            if (event.button !== this._mouseButtons.indexOf(m)) return false;\n            continue;\n        }\n        if (this._mapping.meta.includes(m) && event[`${m}Key` as keyof MouseEvent] !== true) {\n          return false;\n        }\n\n        if (__DEV__) {\n          // eslint-disable-next-line no-console\n          console.warn(`Modifier '${m}' is not supported for mouse events.`);\n        }\n      }\n\n      if (prevent) event.preventDefault();\n      if (stop) event.stopPropagation();\n\n      return true;\n    }) as IModifiedEventHandler;\n  }\n}\n\nclass ModifiedKeyboardEventHandler implements IModifiedEventHandlerCreator {\n  public static register(c: IContainer) {\n    c.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedKeyboardEventHandler));\n  }\n\n  /** @internal */\n  private readonly _mapping = resolve(IKeyMapping);\n  public readonly type = ['keydown', 'keyup'];\n  public getHandler(modifier: string): IModifiedEventHandler {\n    const modifiers = modifier.split(/[:+.]/);\n    return ((event: KeyboardEvent) => {\n      let prevent = false;\n      let stop = false;\n      let mod: string;\n\n      for (mod of modifiers) {\n        switch (mod) {\n          case 'prevent': prevent = true; continue;\n          case 'stop': stop = true; continue;\n        }\n        if (this._mapping.meta.includes(mod)) {\n          if (event[`${mod}Key` as keyof KeyboardEvent] !== true) {\n            return false;\n          }\n          continue;\n        }\n\n        const mappedKey = this._mapping.keys[mod];\n        if (mappedKey !== event.key) {\n          return false;\n        }\n\n        if (__DEV__) {\n          // eslint-disable-next-line no-console\n          console.warn(`Modifier '${mod}' is not supported for keyboard event with key \"${event.key}\".`);\n        }\n      }\n\n      if (prevent) event.preventDefault();\n      if (stop) event.stopPropagation();\n\n      return true;\n    }) as IModifiedEventHandler;\n  }\n}\n\n/**\n * A generic event handler that can be used for any event type\n */\nclass ModifiedEventHandler implements IModifiedEventHandlerCreator {\n  public static register(c: IContainer) {\n    c.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedEventHandler));\n  }\n\n  public readonly type = ['$ALL'];\n  public getHandler(modifier: string): IModifiedEventHandler {\n    const modifiers = modifier.split(/[:+.]/);\n    return ((event: Event) => {\n      let prevent = false;\n      let stop = false;\n      let mod: string;\n\n      for (mod of modifiers) {\n        switch (mod) {\n          case 'prevent': prevent = true; continue;\n          case 'stop': stop = true; continue;\n        }\n\n        if (__DEV__) {\n          // eslint-disable-next-line no-console\n          console.warn(`Modifier '${mod}' is not supported for event \"${event.type}\".`);\n        }\n      }\n\n      if (prevent) event.preventDefault();\n      if (stop) event.stopPropagation();\n\n      return true;\n    }) as IModifiedEventHandler;\n  }\n}\n\nexport interface IEventModifier {\n  getHandler(type: string, modifier: string | null): IModifiedEventHandler | null;\n}\nexport const IEventModifier = /*@__PURE__*/createInterface<IEventModifier>('IEventModifierHandler', x => x.instance({\n  getHandler: () => {\n    if (__DEV__) {\n      // eslint-disable-next-line no-console\n      console.warn('No event modifier handler registered');\n    }\n    /* istanbul ignore next */\n    return null;\n  }\n}));\n\nexport class EventModifier implements IEventModifier {\n  public static register(c: IContainer) {\n    c.register(singletonRegistration(IEventModifier, EventModifier));\n  }\n  /** @internal */\n  private readonly _reg = resolve(all(IModifiedEventHandlerCreator))\n    .reduce((acc: Record<string, IModifiedEventHandlerCreator>, cur) => {\n      const types = isArray(cur.type) ? cur.type : [cur.type];\n      types.forEach(t => acc[t] = cur);\n      return acc;\n    }, {});\n\n  public getHandler(type: string, modifier: string | null): IModifiedEventHandler | null {\n    return isString(modifier) ? (this._reg[type] ?? this._reg.$ALL)?.getHandler(modifier) ?? null : null;\n  }\n}\n\nexport const EventModifierRegistration = {\n  register(c: IContainer) {\n    c.register(\n      EventModifier,\n      ModifiedMouseEventHandler,\n      ModifiedKeyboardEventHandler,\n      ModifiedEventHandler,\n    );\n  }\n};\n", "import { isString, type IContainer } from '@aurelia/kernel';\nimport { CustomElementDefinition } from '../resources/custom-element';\nimport { createInterface } from '../utilities-di';\nimport { Controller } from './controller';\n\nimport type { ICustomAttributeController, ICustomElementController, ISyntheticView } from './controller';\n\nexport interface IViewFactory {\n  name: string;\n  readonly container: IContainer;\n  def: CustomElementDefinition;\n  isCaching: boolean;\n\n  setCacheSize(size: number | '*', doNotOverrideIfAlreadySet: boolean): void;\n\n  canReturnToCache(_controller: ISyntheticView): boolean;\n\n  tryReturnToCache(controller: ISyntheticView): boolean;\n\n  create(parentController?: ISyntheticView | ICustomElementController | ICustomAttributeController | undefined): ISyntheticView;\n}\nexport const IViewFactory = /*@__PURE__*/createInterface<IViewFactory>('IViewFactory');\n\nexport class ViewFactory implements IViewFactory {\n  public static maxCacheSize: number = 0xFFFF;\n\n  public name: string;\n  public readonly container: IContainer;\n  public def: CustomElementDefinition;\n  public isCaching: boolean = false;\n\n  /** @internal */\n  private _cache: ISyntheticView[] = null!;\n  /** @internal */\n  private _cacheSize: number = -1;\n\n  public constructor(\n    container: IContainer,\n    def: CustomElementDefinition,\n  ) {\n    this.name = def.name;\n    this.container = container;\n    this.def = def;\n  }\n\n  public setCacheSize(size: number | '*', doNotOverrideIfAlreadySet: boolean): void {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (size) {\n      if (size === '*') {\n        size = ViewFactory.maxCacheSize;\n      } else if (isString(size)) {\n        size = parseInt(size, 10);\n      }\n\n      if (this._cacheSize === -1 || !doNotOverrideIfAlreadySet) {\n        this._cacheSize = size;\n      }\n    }\n\n    if (this._cacheSize > 0) {\n      this._cache = [];\n    } else {\n      this._cache = null!;\n    }\n\n    this.isCaching = this._cacheSize > 0;\n  }\n\n  public canReturnToCache(_controller: ISyntheticView): boolean {\n    return this._cache != null && this._cache.length < this._cacheSize;\n  }\n\n  public tryReturnToCache(controller: ISyntheticView): boolean {\n    if (this.canReturnToCache(controller)) {\n      this._cache.push(controller);\n      return true;\n    }\n\n    return false;\n  }\n\n  public create(\n    parentController?: ISyntheticView | ICustomElementController | ICustomAttributeController | undefined,\n  ): ISyntheticView {\n    const cache = this._cache;\n    let controller: ISyntheticView;\n\n    if (cache != null && cache.length > 0) {\n      controller = cache.pop()!;\n      return controller;\n    }\n\n    controller = Controller.$view(this, parentController);\n    return controller;\n  }\n}\n", "import { type IRenderLocation } from './dom';\nimport { type IPlatform } from './platform';\n\n/** @internal */\nexport const createLocation = /*@__PURE__*/ (() => {\n  const createComment = (p: IPlatform, text: string) => p.document.createComment(text);\n  return (p: IPlatform) => {\n    const locationEnd = createComment(p, 'au-end') as IRenderLocation;\n    locationEnd.$start = createComment(p, 'au-start') as IRenderLocation;\n\n    return locationEnd;\n  };\n})();\n\n/** @internal */\nexport const insertManyBefore = (parent: Node | null, target: Node | null, newChildNodes: ArrayLike<Node>) => {\n  if (parent === null) {\n    return;\n  }\n  const ii = newChildNodes.length;\n  let i = 0;\n  while (ii > i) {\n    parent.insertBefore(newChildNodes[i], target);\n    ++i;\n  }\n};\n\n/** @internal */\nexport const createMutationObserver = (node: Node, callback: MutationCallback) => new node.ownerDocument!.defaultView!.MutationObserver(callback);\n\n/** @internal */\nexport const isElement = (node: Node): node is Element => node.nodeType === 1;\n", "import { emptyArray, type IContainer, type IIndexable, type IServiceLocator, type Key } from '@aurelia/kernel';\nimport { subscriberCollection, type ISubscribable, type ISubscriberCollection } from '@aurelia/runtime';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { PartialCustomElementDefinition } from '../resources/custom-element';\nimport { def, objectAssign, safeString } from '../utilities';\nimport { createInterface, instanceRegistration } from '../utilities-di';\nimport { isElement } from '../utilities-dom';\nimport { type ICustomElementController, type ICustomElementViewModel } from './controller';\nimport { ILifecycleHooks, lifecycleHooks } from './lifecycle-hooks';\n\nimport { getAnnotationKeyFor } from '../utilities-metadata';\n\n/** @internal */\nexport const defaultSlotName = 'default';\n/** @internal */\nexport const auslotAttr = 'au-slot';\n\nexport type PartialSlottedDefinition = {\n  callback?: PropertyKey;\n  slotName?: string;\n  query?: string;\n  // options?: MutationObserverInit;\n  // query?: (controller: ICustomElementController) => ArrayLike<Node>;\n  // filter?: (node: Node, controller?: ICustomElementController | null, viewModel?: ICustomElementViewModel) => boolean;\n  // map?: (node: Node, controller?: ICustomElementController | null, viewModel?: ICustomElementViewModel) => unknown;\n};\n\nexport type IAuSlotProjections = Record<string, PartialCustomElementDefinition>;\n\nexport interface IAuSlotsInfo {\n  /**\n   * Name of the slots to which content are projected.\n   */\n  readonly projectedSlots: readonly string[];\n}\n/**\n * Describing the projection information statically available for a custom element\n */\nexport const IAuSlotsInfo = /*@__PURE__*/createInterface<IAuSlotsInfo>('IAuSlotsInfo');\nexport class AuSlotsInfo implements IAuSlotsInfo {\n  public constructor(\n    public readonly projectedSlots: string[],\n  ) { }\n}\n\n/**\n * Describe the interface of a slot\n */\nexport interface IAuSlot {\n  readonly name: string;\n  readonly nodes: readonly Node[];\n  /** Add subscriber to the change listener list of this slot */\n  subscribe(subscriber: IAuSlotSubscriber): void;\n  /** Remove subscriber from the change listener list of this slot */\n  unsubscribe(subscriber: IAuSlotSubscriber): void;\n}\n\nexport interface IAuSlotSubscriber {\n  handleSlotChange(slot: IAuSlot, nodes: Node[]): void;\n}\n\n/**\n * Describes the interface of a <au-slot> watcher\n */\nexport interface IAuSlotWatcher extends ISubscribable {\n  // this may be an issue in the future where there's a desire\n  // for a watcher to selectively watch multiple slot at once\n  // at the moment, it's all (*) or one (name)\n  readonly slotName: string;\n  watch(slot: IAuSlot): void;\n  unwatch(slot: IAuSlot): void;\n}\nexport const IAuSlotWatcher = /*@__PURE__*/createInterface<IAuSlotWatcher>('IAuSlotWatcher');\n\n// 1. on hydrating, create a slot watcher (binding) & register with hydration context\n// 2. on slot with projection created, optionally retrieve the slot watcher\n//  2.a if there's NOT a watcher, do nothing\n//  2.b else register the slot\n\n// 1. au-slot should start listening to mutation when attaching\n// 2. au-slot should stop listening to mutation when detaching\n// 3. au-slot should notify slot watcher on mutation\n\ninterface AuSlotWatcherBinding extends ISubscriberCollection {}\nclass AuSlotWatcherBinding implements IAuSlotWatcher, IAuSlotSubscriber, ISubscriberCollection {\n  /** @internal */\n  private readonly _obj: ICustomElementViewModel;\n  /** @internal */\n  private readonly _callback: (nodes: readonly Node[]) => void;\n\n  public readonly slotName: string;\n  /** @internal */\n  private readonly _query: string;\n  /** @internal */\n  private readonly _slots = new Set<IAuSlot>();\n\n  /** @internal */\n  private _nodes: Node[] = emptyArray;\n\n  public isBound: boolean = false;\n\n  public constructor(\n    obj: ICustomElementViewModel,\n    callback: PropertyKey,\n    slotName: string,\n    query: string,\n  ) {\n    this._callback = (this._obj = obj as IIndexable)[callback] as typeof AuSlotWatcherBinding.prototype._callback;\n    this.slotName = slotName;\n    this._query = query;\n  }\n\n  public bind() {\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    this.isBound = false;\n  }\n\n  public getValue() {\n    return this._nodes;\n  }\n\n  public watch(slot: IAuSlot): void {\n    if (!this._slots.has(slot)) {\n      this._slots.add(slot);\n      slot.subscribe(this);\n    }\n  }\n\n  public unwatch(slot: IAuSlot): void {\n    if (this._slots.delete(slot)) {\n      slot.unsubscribe(this);\n    }\n  }\n\n  public handleSlotChange(slot: IAuSlot, nodes: Node[]): void {\n    if (!this.isBound) {\n      return;\n    }\n    const oldNodes = this._nodes;\n    const $nodes: Node[] = [];\n    const query = this._query;\n    let $slot: IAuSlot;\n    let node: Node;\n    for ($slot of this._slots) {\n      for (node of $slot === slot ? nodes : $slot.nodes) {\n        if (query === '$all' || (isElement(node) && (query === '*' || node.matches(query)))) {\n          $nodes[$nodes.length] = node;\n        }\n      }\n    }\n    if ($nodes.length !== oldNodes.length || $nodes.some((n, i) => n !== oldNodes[i])) {\n      this._nodes = $nodes;\n      this._callback?.call(this._obj, $nodes);\n      this.subs.notify($nodes, oldNodes);\n    }\n  }\n\n  /* istanbul ignore next */\n  public get(): ReturnType<IServiceLocator['get']> {\n    throw createMappedError(ErrorNames.method_not_implemented, 'get');\n  }\n}\n\ntype SlottedPropDefinition = PartialSlottedDefinition & { name: PropertyKey };\nclass SlottedLifecycleHooks {\n  public constructor(\n    private readonly _def: SlottedPropDefinition,\n  ) {}\n\n  public register(c: IContainer) {\n    instanceRegistration(ILifecycleHooks, this).register(c);\n  }\n\n  public hydrating(vm: object, controller: ICustomElementController) {\n    const $def = this._def;\n    const watcher = new AuSlotWatcherBinding(\n      vm,\n      $def.callback ?? `${safeString($def.name)}Changed`,\n      $def.slotName ?? 'default',\n      $def.query ?? '*'\n    );\n    def(vm, $def.name, {\n      enumerable: true,\n      configurable: true,\n      get: objectAssign((/* SlotWatcherBinding */) => watcher.getValue(), { getObserver: () => watcher }),\n      set: (/* SlotWatcherBinding */) => {/* nothing */}\n    });\n\n    instanceRegistration(IAuSlotWatcher, watcher).register(controller.container);\n    controller.addBinding(watcher);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Tc39PropertyDecorator = (target: undefined, context: ClassFieldDecoratorContext) => (initialValue: any) => any;\n/**\n * Decorate a property of a class to get updates from the projection of the decorated custom element\n */\nexport function slotted(): Tc39PropertyDecorator;\n/**\n * Decorate a property of a class to get updates from the projection of the decorated custom element\n *\n * @param query - the query select used to match each slotted node of the corresponding <au-slot>\n * If * is provided, then it'll get all nodes (including text nodes)\n */\nexport function slotted(query: string): Tc39PropertyDecorator;\n/**\n * Decorate a property of a class to get updates from the projection of the decorated custom element\n *\n * @param query - the query select used to match each slotted node of the corresponding <au-slot>\n * If * is provided, then it'll get all nodes (including text nodes)\n * @param slotName - the name of the <au-slot> this slotted decorator is targeting.\n * If * is provided, then it'll get all nodes from all <au-slot>\n */\nexport function slotted(query: string, slotName: string): Tc39PropertyDecorator;\n\n/**\n * Decorate a property of a class to get updates from the projection of the decorated custom element\n *\n * @param def - The configuration of the slotted decorator.\n */\nexport function slotted(def: PartialSlottedDefinition): Tc39PropertyDecorator;\nexport function slotted(queryOrDef?: string | PartialSlottedDefinition, slotName?: string): Tc39PropertyDecorator;\nexport function slotted(queryOrDef?: string | PartialSlottedDefinition, slotName?: string) {\n  if (!mixed) {\n    mixed = true;\n    subscriberCollection(AuSlotWatcherBinding, null!);\n    lifecycleHooks()(SlottedLifecycleHooks, null!);\n  }\n  const dependenciesKey = getAnnotationKeyFor('dependencies');\n\n  // function decorator($target: {}, $prop: symbol | string, desc?: PropertyDecorator): void {\n  function decorator(_: undefined, context: ClassFieldDecoratorContext): void {\n    if (context.kind !== 'field') throw createMappedError(ErrorNames.slotted_decorator_invalid_usage);\n\n    const config = (typeof queryOrDef === 'object'\n      ? queryOrDef\n      : {\n        query: queryOrDef,\n        slotName,\n        name: ''\n      }) as SlottedPropDefinition;\n    config.name = context.name;\n\n    const dependencies = (context.metadata[dependenciesKey] ??= []) as Key[];\n    dependencies.push(new SlottedLifecycleHooks(config));\n  }\n\n  return decorator;\n}\n\n/* eslint-disable */\nfunction testDecorator() {\n  class Abc {\n    @slotted() abc: any;\n    @slotted('div') a2: any;\n    @slotted('div', 'slot1') a3: any;\n    @slotted({\n      slotName: 'slot1'\n    })\n    a4: any;\n  }\n}\n\nlet mixed = false;\n", "import { AccessScopeExpression, IExpressionParser, type IsBindingBehavior } from '@aurelia/expression-parser';\nimport { isObject, type IServiceLocator, type Key, emptyArray } from '@aurelia/kernel';\nimport { TaskQueue } from '@aurelia/platform';\nimport {\n  type IObserverLocator,\n  type IObserverLocatorBasedConnectable,\n  connectable,\n  Scope,\n  type IAstEvaluator,\n  astBind,\n  astEvaluate,\n  astUnbind,\n} from '@aurelia/runtime';\nimport { BindingMode, IInstruction, ITemplateCompiler, InstructionType, SpreadElementPropBindingInstruction } from '@aurelia/template-compiler';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { IPlatform } from '../platform';\nimport { IHasController, } from '../renderer';\nimport { CustomElementDefinition, findElementControllerFor } from '../resources/custom-element';\nimport { IController, ICustomElementController, IHydratableController, IHydrationContext, vmkCa } from '../templating/controller';\nimport { IRendering } from '../templating/rendering';\nimport { createPrototypeMixer, mixinAstEvaluator, mixinUseScope, mixingBindingLimited } from './binding-utils';\nimport { IBinding, IBindingController } from './interfaces-bindings';\nimport { PropertyBinding } from './property-binding';\n\n/**\n * The public methods of this binding emulates the necessary of an IHydratableController,\n * which mainly is the addBinding method since a spread binding\n * is a surrogate of other bindings created from the captured attrs\n */\nexport class SpreadBinding implements IBinding, IHasController {\n\n  /**\n   * Create a list of SpreadBinding by searching for captured attributes in HydrationContexts\n   * from a container\n   */\n  public static create(\n    hydrationContext: IHydrationContext,\n    target: HTMLElement,\n    /**\n     * To be supplied to the compilation of spread' attrs\n     * Sometimes in dynamic compilation scenario, this could be used to influence\n     * what attributes can be compiled into (i.e bindable vs normal)\n     */\n    targetDef: CustomElementDefinition | undefined,\n    rendering: IRendering,\n    compiler: ITemplateCompiler,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): SpreadBinding[] {\n    const bindings: SpreadBinding[] = [];\n    const renderers = rendering.renderers;\n    const getHydrationContext = (ancestor: number) => {\n      let currentLevel = ancestor;\n      let currentContext: IHydrationContext | undefined = hydrationContext;\n      while (currentContext != null && currentLevel > 0) {\n        currentContext = currentContext.parent;\n        --currentLevel;\n      }\n      if (currentContext == null) {\n        throw createMappedError(ErrorNames.no_spread_scope_context_found);\n      }\n      return currentContext as IHydrationContext<object>;\n    };\n    const renderSpreadInstruction = (ancestor: number) => {\n      const context = getHydrationContext(ancestor);\n      const spreadBinding = new SpreadBinding(context) as SpreadBinding & IHydratableController;\n      const instructions = compiler.compileSpread(\n        context.controller.definition,\n        context.instruction?.captures ?? emptyArray,\n        context.controller.container,\n        target,\n        targetDef\n      );\n      let inst: IInstruction;\n      for (inst of instructions) {\n        switch (inst.type) {\n          case InstructionType.spreadTransferedBinding:\n            renderSpreadInstruction(ancestor + 1);\n            break;\n          case InstructionType.spreadElementProp:\n            renderers[(inst as SpreadElementPropBindingInstruction).instruction.type].render(\n              spreadBinding,\n              findElementControllerFor(target),\n              (inst as SpreadElementPropBindingInstruction).instruction,\n              platform,\n              exprParser,\n              observerLocator,\n            );\n            break;\n          default:\n            renderers[inst.type].render(spreadBinding, target, inst, platform, exprParser, observerLocator);\n        }\n      }\n      bindings.push(spreadBinding);\n    };\n    renderSpreadInstruction(0);\n    return bindings;\n  }\n\n  public scope?: Scope | undefined;\n  public isBound: boolean = false;\n  public readonly locator: IServiceLocator;\n\n  public readonly $controller: ICustomElementController;\n\n  public get container() {\n    return this.locator;\n  }\n\n  public get definition(): CustomElementDefinition {\n    return this.$controller.definition;\n  }\n\n  public get state() {\n    return this.$controller.state;\n  }\n\n  /** @internal */ private readonly _innerBindings: IBinding[] = [];\n  /** @internal */ private readonly _hydrationContext: IHydrationContext<object>;\n\n  public constructor(\n    hydrationContext: IHydrationContext<object>,\n  ) {\n    this.locator = (this.$controller = (this._hydrationContext = hydrationContext).controller).container;\n  }\n\n  public get(key: Key) {\n    return this.locator.get(key);\n  }\n\n  public bind(_scope: Scope): void {\n    /* istanbul ignore if */\n    if (this.isBound) {\n      /* istanbul ignore next */\n      return;\n    }\n    this.isBound = true;\n    const innerScope = this.scope = this._hydrationContext.controller.scope.parent ?? void 0;\n    if (innerScope == null) {\n      throw createMappedError(ErrorNames.no_spread_scope_context_found);\n    }\n\n    this._innerBindings.forEach(b => b.bind(innerScope));\n  }\n\n  public unbind(): void {\n    this._innerBindings.forEach(b => b.unbind());\n    this.isBound = false;\n  }\n\n  public addBinding(binding: IBinding) {\n    this._innerBindings.push(binding);\n  }\n\n  public addChild(controller: IController) {\n    if (controller.vmKind !== vmkCa) {\n      throw createMappedError(ErrorNames.no_spread_template_controller);\n    }\n    this.$controller.addChild(controller);\n  }\n}\n\nexport interface SpreadValueBinding extends IAstEvaluator, IServiceLocator, IObserverLocatorBasedConnectable {}\nexport class SpreadValueBinding implements IBinding {\n  /** @internal */\n  public static mix = /*@__PURE__*/ createPrototypeMixer(() => {\n    mixinUseScope(SpreadValueBinding);\n    mixingBindingLimited(SpreadValueBinding, () => 'updateTarget');\n    connectable(SpreadValueBinding, null!);\n    mixinAstEvaluator(SpreadValueBinding);\n  });\n\n  /** @internal */\n  private static readonly _astCache: Record<string, AccessScopeExpression> = {};\n\n  public isBound = false;\n\n  /** @internal */\n  public _scope?: Scope = void 0;\n\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  public l: IServiceLocator;\n\n  /** @internal */\n  private readonly _taskQueue: TaskQueue;\n\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  /** @internal */\n  private readonly _controller: IBindingController;\n\n  /** @internal */\n  private readonly _bindingCache: Record<PropertyKey, PropertyBinding> = {};\n  // not a static weakmap because we want to clear the cache when the binding is disposed\n  // also different binding at different logic with the same object shouldn't be sharing the same override context\n  /** @internal */\n  private readonly _scopeCache = new WeakMap<object, Scope>();\n\n  public constructor(\n    controller: IBindingController,\n    public target: object,\n    public targetKeys: string[],\n    public ast: IsBindingBehavior,\n    ol: IObserverLocator,\n    l: IServiceLocator,\n    taskQueue: TaskQueue,\n    public strict: boolean,\n  ) {\n    this._controller = controller;\n    this.oL = ol;\n    this.l = l;\n    this._taskQueue = taskQueue;\n  }\n\n  public updateTarget(): void {\n    this.obs.version++;\n    const newValue = astEvaluate(\n      this.ast,\n      this._scope!,\n      this,\n      this\n    );\n    this.obs.clear();\n\n    this._createBindings(newValue as Record<PropertyKey, unknown> | null, true);\n  }\n\n  public handleChange(): void {\n      /* istanbul ignore if */\n    if (!this.isBound) {\n      /* istanbul ignore next */\n      return;\n    }\n    this.updateTarget();\n  }\n\n  public handleCollectionChange(): void {\n      /* istanbul ignore if */\n    if (!this.isBound) {\n      /* istanbul ignore next */\n      return;\n    }\n    this.updateTarget();\n  }\n\n  public bind(scope: Scope) {\n      /* istanbul ignore if */\n    if (this.isBound) {\n      /* istanbul ignore if */\n      if (scope === this._scope) {\n      /* istanbul ignore next */\n        return;\n      }\n      /* istanbul ignore next */\n      this.unbind();\n    }\n    this.isBound = true;\n    this._scope = scope;\n\n    astBind(this.ast, scope, this);\n\n    const value = astEvaluate(this.ast, scope, this, this);\n\n    this._createBindings(value as Record<string, unknown> | null, false);\n  }\n\n  public unbind(): void {\n      /* istanbul ignore if */\n    if (!this.isBound) {\n      /* istanbul ignore next */\n      return;\n    }\n    this.isBound = false;\n    astUnbind(this.ast, this._scope!, this);\n    this._scope = void 0;\n    let key: string;\n    // can also try to keep track of what the active bindings are\n    // but we know in our impl, all unbind are idempotent\n    // so just be simple and unbind all\n    for (key in this._bindingCache) {\n      this._bindingCache[key].unbind();\n    }\n  }\n\n  /**\n   * @internal\n   */\n  private _createBindings(value: Record<string, unknown> | null, unbind: boolean) {\n    let key: string;\n    if (!isObject(value)) {\n      /* istanbul ignore if */\n      if (__DEV__) {\n        // eslint-disable-next-line no-console\n        console.warn(`[DEV:aurelia] $bindable spread is given a non object for properties: \"${this.targetKeys.join(', ')}\" of ${this.target.constructor.name}`);\n      }\n      for (key in this._bindingCache) {\n        this._bindingCache[key]?.unbind();\n      }\n      return;\n    }\n\n    let binding: PropertyBinding;\n    // use a cache as we don't wanna cause bindings to \"move\" (bind/unbind)\n    // whenever there's a new evaluation\n    let scope = this._scopeCache.get(value);\n    if (scope == null) {\n      this._scopeCache.set(value, scope = Scope.fromParent(this._scope!, value));\n    }\n    for (key of this.targetKeys) {\n      binding = this._bindingCache[key];\n      if (key in value) {\n        if (binding == null) {\n          binding = this._bindingCache[key] = new PropertyBinding(\n            this._controller,\n            this.l,\n            this.oL,\n            this._taskQueue,\n            SpreadValueBinding._astCache[key] ??= new AccessScopeExpression(key, 0),\n            this.target,\n            key,\n            BindingMode.toView,\n            this.strict,\n          );\n        }\n        binding.bind(scope);\n      } else if (unbind) {\n        binding?.unbind();\n      }\n    }\n  }\n}\n", "import { Constructable, noop } from '@aurelia/kernel';\nimport type { ISubscriber, ISubscriberCollection } from '@aurelia/runtime';\nimport type { INode } from '../dom';\nimport { defineHiddenProp } from '../utilities';\nimport type { INodeObserver, INodeObserverConfigBase } from './observer-locator';\n\nconst addListener = (target: EventTarget, name: string, handler: EventListenerOrEventListenerObject, options?: AddEventListenerOptions) => {\n  target.addEventListener(name, handler, options);\n};\n\nconst removeListener = (target: EventTarget, name: string, handler: EventListenerOrEventListenerObject, options?: AddEventListenerOptions) => {\n  target.removeEventListener(name, handler, options);\n};\n\n/** @internal */\nexport const mixinNodeObserverUseConfig =\n  <T extends INodeObserver & EventListenerObject & ISubscriberCollection & { _el: INode; _config: INodeObserverConfigBase; _listened: boolean; _start(): void; _stop?(): void }>(target: Constructable<T>) => {\n    let event: string;\n    const prototype = target.prototype;\n    defineHiddenProp(prototype, 'subscribe', function (this: T, subscriber: ISubscriber) {\n      if (this.subs.add(subscriber) && this.subs.count === 1) {\n        for (event of this._config.events) {\n          addListener(this._el, event, this);\n        }\n        this._listened = true;\n        this._start?.();\n      }\n    });\n    defineHiddenProp(prototype, 'unsubscribe', function (this: T, subscriber: ISubscriber) {\n        if (this.subs.remove(subscriber) && this.subs.count === 0) {\n          for (event of this._config.events) {\n            removeListener(this._el, event, this);\n          }\n          this._listened = false;\n          this._stop?.();\n        }\n    });\n    defineHiddenProp(prototype, 'useConfig', function (this: T, config: INodeObserverConfigBase): void {\n      this._config = config;\n      if (this._listened) {\n        for (event of this._config.events) {\n          removeListener(this._el, event, this);\n        }\n        for (event of this._config.events) {\n          addListener(this._el, event, this);\n        }\n      }\n    });\n};\n\n/** @internal */\nexport const mixinNoopSubscribable = (target: Constructable) => {\n  defineHiddenProp(target.prototype, 'subscribe', noop);\n  defineHiddenProp(target.prototype, 'unsubscribe', noop);\n};\n", "import { emptyArray, isArray, isString } from '@aurelia/kernel';\nimport { atLayout, atNode } from '../utilities';\n\nimport type { AccessorType, IAccessor, IObserver } from '@aurelia/runtime';\nimport { mixinNoopSubscribable } from './observation-utils';\n\nexport interface ClassAttributeAccessor extends IObserver {}\nexport class ClassAttributeAccessor implements IAccessor {\n  static {\n    mixinNoopSubscribable(ClassAttributeAccessor);\n  }\n\n  public get doNotCache(): true { return true; }\n  public type: AccessorType = (atNode | atLayout) as AccessorType;\n\n  /** @internal */\n  private _value: unknown = '';\n\n  /** @internal */\n  private readonly _nameIndex: Record<string, number> = {};\n  /** @internal */\n  private _version: number = 0;\n\n  public constructor(\n    public readonly obj: HTMLElement,\n    public readonly mapping: Record<string, string> = {}\n  ) {\n  }\n\n  public getValue(): unknown {\n    return this._value;\n  }\n\n  public setValue(newValue: unknown): void {\n    if (newValue !== this._value) {\n      this._value = newValue;\n      this._flushChanges();\n    }\n  }\n\n  /** @internal */\n  private _flushChanges(): void {\n    const nameIndex = this._nameIndex;\n    const version = ++this._version;\n    const classList = this.obj.classList;\n    const classesToAdd = getClassesToAdd(this._value as string | Record<string, unknown> | []);\n    const ii = classesToAdd.length;\n    let i = 0;\n    let name: string;\n\n    // Get strings split on a space not including empties\n    if (ii > 0) {\n      for (; i < ii; i++) {\n        name = classesToAdd[i];\n        name = this.mapping[name] || name;\n\n        if (name.length === 0) {\n          continue;\n        }\n        nameIndex[name] = this._version;\n        classList.add(name);\n      }\n    }\n\n    // First call to setValue?  We're done.\n    if (version === 1) {\n      return;\n    }\n\n    for (name in nameIndex) {\n      name = this.mapping[name] || name;\n      if (nameIndex[name] === version) {\n        continue;\n      }\n      // TODO: this has the side-effect that classes already present which are added again,\n      // will be removed if they're not present in the next update.\n      // Better would be do have some configurability for this behavior, allowing the user to\n      // decide whether initial classes always need to be kept, always removed, or something in between\n      classList.remove(name);\n    }\n  }\n}\n\nfunction getClassesToAdd(object: Record<string, unknown> | [] | string): string[] {\n  if (isString(object)) {\n    return splitClassString(object);\n  }\n  if (typeof object !== 'object') {\n    return emptyArray;\n  }\n\n  if (isArray(object)) {\n    const len = object.length;\n    if (len > 0) {\n      const classes: string[] = [];\n      let i = 0;\n      for (; len > i; ++i) {\n        classes.push(...getClassesToAdd(object[i]));\n      }\n      return classes;\n    } else {\n      return emptyArray;\n    }\n  }\n\n  const classes: string[] = [];\n  let property: string;\n  for (property in object) {\n    // Let non typical values also evaluate true so disable bool check\n    // eslint-disable-next-line no-extra-boolean-cast\n    if (Boolean(object[property])) {\n      // We must do this in case object property has a space in the name which results in two classes\n      if (property.includes(' ')) {\n        classes.push(...splitClassString(property));\n      } else {\n        classes.push(property);\n      }\n    }\n  }\n  return classes;\n}\n\nfunction splitClassString(classString: string): string[] {\n  const matches = classString.match(/\\S+/g);\n  if (matches === null) {\n    return emptyArray;\n  }\n  return matches;\n}\n", "import { Key, IResolver, own } from '@aurelia/kernel';\nimport { IHydrationContext } from '../templating/controller';\n\n/**\n * Create a resolver for a given key that will only resolve from the nearest hydration context.\n *\n * @internal\n */\nexport const fromHydrationContext = <T extends Key>(key: T): IResolver<T | undefined> => ({\n  $isResolver: true,\n  resolve(_, requestor) {\n    return requestor.get(IHydrationContext).controller.container.get(own(key));\n  }\n});\n", "import {\n  emptyArray,\n  InstanceProvider,\n  type IContainer,\n  type Constructable,\n  type IResolver,\n  resolve,\n  isString,\n  registrableMetadataKey,\n} from '@aurelia/kernel';\nimport {\n  IExpressionParser,\n  type ExpressionType,\n  type AnyBindingExpression,\n} from '@aurelia/expression-parser';\nimport {\n  IObserverLocator,\n  type IObservable,\n} from '@aurelia/runtime';\nimport { toView } from './binding/interfaces-bindings';\nimport { AttributeBinding } from './binding/attribute-binding';\nimport { InterpolationBinding, InterpolationPartBinding } from './binding/interpolation-binding';\nimport { ContentBinding } from \"./binding/content-binding\";\nimport { LetBinding } from './binding/let-binding';\nimport { PropertyBinding } from './binding/property-binding';\nimport { RefBinding } from './binding/ref-binding';\nimport { IEventModifier, ListenerBinding, ListenerBindingOptions } from './binding/listener-binding';\nimport { CustomElement, CustomElementDefinition, findElementControllerFor } from './resources/custom-element';\nimport { CustomAttribute, CustomAttributeDefinition, findAttributeControllerFor } from './resources/custom-attribute';\nimport { convertToRenderLocation, IRenderLocation, INode, setRef, ICssClassMapping, registerHostNode } from './dom';\nimport { Controller, ICustomElementController, ICustomElementViewModel, IController, ICustomAttributeViewModel, IHydrationContext } from './templating/controller';\nimport { IPlatform } from './platform';\nimport { IViewFactory } from './templating/view';\nimport { IRendering } from './templating/rendering';\nimport { objectKeys, etIsProperty, etInterpolation, etIsIterator, etIsFunction } from './utilities';\nimport { createInterface, registerResolver, singletonRegistration } from './utilities-di';\nimport { IAuSlotsInfo, AuSlotsInfo } from './templating/controller.projection';\n\nimport type { IHydratableController } from './templating/controller';\nimport { ErrorNames, createMappedError } from './errors';\nimport { SpreadBinding, SpreadValueBinding } from './binding/spread-binding';\nimport {\n  AttributeBindingInstruction,\n  HydrateAttributeInstruction,\n  HydrateElementInstruction,\n  HydrateLetElementInstruction,\n  HydrateTemplateController,\n  IInstruction,\n  ITemplateCompiler,\n  InstructionType,\n  InterpolationInstruction,\n  IteratorBindingInstruction,\n  LetBindingInstruction,\n  ListenerBindingInstruction,\n  PropertyBindingInstruction,\n  RefBindingInstruction,\n  SetAttributeInstruction,\n  SetClassAttributeInstruction,\n  SetPropertyInstruction,\n  SetStyleAttributeInstruction,\n  SpreadTransferedBindingInstruction,\n  SpreadValueBindingInstruction,\n  StylePropertyBindingInstruction,\n  TextBindingInstruction\n} from '@aurelia/template-compiler';\nimport { ClassAttributeAccessor } from './observation/class-attribute-accessor';\nimport { fromHydrationContext } from './resources/resolvers';\n\n/**\n * An interface describing an instruction renderer\n * its target property will be used to match instruction types dynamically at render time\n */\nexport interface IRenderer {\n  target: string;\n  render(\n    /**\n     * The controller that is current invoking this renderer\n     */\n    renderingCtrl: IHydratableController,\n    target: unknown,\n    instruction: IInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void;\n}\n\nexport const IRenderer = /*@__PURE__*/createInterface<IRenderer>('IRenderer');\n\nexport function renderer<T extends IRenderer, C extends Constructable<T>>(target: C, context: ClassDecoratorContext): C {\n  const metadata = context?.metadata ?? (target[Symbol.metadata] ??= Object.create(null));\n  metadata[registrableMetadataKey] = {\n    register(container: IContainer): void {\n      singletonRegistration(IRenderer, target).register(container);\n    }\n  };\n  return target;\n}\n\nfunction ensureExpression<TFrom>(parser: IExpressionParser, srcOrExpr: TFrom | string, expressionType: ExpressionType): TFrom {\n  if (isString(srcOrExpr)) {\n    return parser.parse(srcOrExpr, expressionType) as TFrom;\n  }\n  return srcOrExpr;\n}\n\nfunction getTarget(potentialTarget: object): object {\n  if ((potentialTarget as { viewModel?: object }).viewModel != null) {\n    return (potentialTarget as { viewModel: object }).viewModel;\n  }\n  return potentialTarget;\n}\n\nfunction getRefTarget(refHost: INode, refTargetName: string): object {\n  if (refTargetName === 'element') {\n    return refHost;\n  }\n  switch (refTargetName) {\n    case 'controller':\n      // this means it supports returning undefined\n      return findElementControllerFor(refHost)!;\n    case 'view':\n      throw createMappedError(ErrorNames.not_supported_view_ref_api);\n    case 'component':\n      // this means it supports returning undefined\n      return findElementControllerFor(refHost)!.viewModel;\n    default: {\n      const caController = findAttributeControllerFor(refHost, refTargetName);\n      if (caController !== void 0) {\n        return caController.viewModel;\n      }\n      const ceController = findElementControllerFor(refHost, { name: refTargetName });\n      if (ceController === void 0) {\n        throw createMappedError(ErrorNames.ref_not_found, refTargetName);\n      }\n      return ceController.viewModel;\n    }\n  }\n}\n\nexport const SetPropertyRenderer = /*@__PURE__*/ renderer(class SetPropertyRenderer implements IRenderer {\n  public readonly target = InstructionType.setProperty;\n\n  public render(\n    renderingCtrl: IHydratableController,\n    target: IController,\n    instruction: SetPropertyInstruction,\n  ): void {\n    const obj = getTarget(target) as IObservable;\n    if (obj.$observers?.[instruction.to] !== void 0) {\n      obj.$observers[instruction.to].setValue(instruction.value);\n    } else {\n      obj[instruction.to] = instruction.value;\n    }\n  }\n}, null!);\n\nexport const CustomElementRenderer = /*@__PURE__*/ renderer(class CustomElementRenderer implements IRenderer {\n  /** @internal */ public readonly _rendering = resolve(IRendering);\n\n  public readonly target = InstructionType.hydrateElement;\n\n  public render(\n    renderingCtrl: IHydratableController,\n    target: HTMLElement,\n    instruction: HydrateElementInstruction<Record<PropertyKey, unknown>, CustomElementDefinition>,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    /* eslint-disable prefer-const */\n    let def: CustomElementDefinition | null;\n    let component: ICustomElementViewModel;\n    let childCtrl: ICustomElementController;\n    const res = instruction.res;\n    const projections = instruction.projections;\n    const ctxContainer = renderingCtrl.container;\n    switch (typeof res) {\n      case 'string':\n        def = CustomElement.find(ctxContainer, res);\n        if (def == null) {\n          throw createMappedError(ErrorNames.element_res_not_found, instruction, renderingCtrl);\n        }\n        break;\n      // constructor based instruction\n      // will be enabled later if needed.\n      // As both AOT + runtime based can use definition for perf\n      // -----------------\n      // case 'function':\n      //   def = CustomElement.getDefinition(res);\n      //   break;\n      default:\n        def = res;\n    }\n    const containerless = instruction.containerless || def.containerless;\n    const location = containerless ? convertToRenderLocation(target) : null;\n    const container = createElementContainer(\n      /* platform         */platform,\n      /* parentController */renderingCtrl,\n      /* host             */target,\n      /* instruction      */instruction,\n      /* location         */location,\n      /* SlotsInfo      */projections == null ? void 0 : new AuSlotsInfo(objectKeys(projections)),\n    );\n    component = container.invoke(def.Type);\n    childCtrl = Controller.$el(\n      /* own container       */container,\n      /* viewModel           */component,\n      /* host                */target,\n      /* instruction         */instruction,\n      /* definition          */def,\n      /* location            */location\n    );\n\n    setRef(target, def.key, childCtrl);\n\n    const renderers = this._rendering.renderers;\n    const props = instruction.props;\n    const ii = props.length;\n    let i = 0;\n    let propInst: IInstruction;\n    while (ii > i) {\n      propInst = props[i];\n      renderers[propInst.type].render(renderingCtrl, childCtrl, propInst, platform, exprParser, observerLocator);\n      ++i;\n    }\n\n    renderingCtrl.addChild(childCtrl);\n    /* eslint-enable prefer-const */\n  }\n}, null!);\n\nexport const CustomAttributeRenderer = /*@__PURE__*/ renderer(class CustomAttributeRenderer implements IRenderer {\n  /** @internal */ public readonly _rendering = resolve(IRendering);\n\n  public readonly target = InstructionType.hydrateAttribute;\n\n  public render(\n    /**\n     * The cotroller that is currently invoking this renderer\n     */\n    renderingCtrl: IHydratableController,\n    target: HTMLElement,\n    // <CustomAttributeDefinition> as we assume it's always used with the default resources resolver\n    instruction: HydrateAttributeInstruction<CustomAttributeDefinition>,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    /* eslint-disable prefer-const */\n    let ctxContainer = renderingCtrl.container;\n    let def: CustomAttributeDefinition | null;\n    switch (typeof instruction.res) {\n      case 'string':\n        def = CustomAttribute.find(ctxContainer, instruction.res);\n        if (def == null) {\n          throw createMappedError(ErrorNames.attribute_res_not_found, instruction, renderingCtrl);\n        }\n        break;\n      // constructor based instruction\n      // will be enabled later if needed.\n      // As both AOT + runtime based can use definition for perf\n      // -----------------\n      // case 'function':\n      //   def = CustomAttribute.getDefinition(instruction.res);\n      //   break;\n      default:\n        def = instruction.res;\n    }\n    const results = invokeAttribute(\n      /* platform         */platform,\n      /* attr definition  */def,\n      /* parentController */renderingCtrl,\n      /* host             */target,\n      /* instruction      */instruction,\n      /* viewFactory      */void 0,\n      /* location         */void 0,\n    );\n    const childController = Controller.$attr(\n      /* context ct */results.ctn,\n      /* viewModel  */results.vm,\n      /* host       */target,\n      /* definition */def,\n    );\n\n    setRef(target, def.key, childController);\n\n    const renderers = this._rendering.renderers;\n    const props = instruction.props;\n    const ii = props.length;\n    let i = 0;\n    let propInst: IInstruction;\n    while (ii > i) {\n      propInst = props[i];\n      renderers[propInst.type].render(renderingCtrl, childController, propInst, platform, exprParser, observerLocator);\n      ++i;\n    }\n\n    renderingCtrl.addChild(childController);\n    /* eslint-enable prefer-const */\n  }\n}, null!);\n\nexport const TemplateControllerRenderer = /*@__PURE__*/ renderer(class TemplateControllerRenderer implements IRenderer {\n  /** @internal */ public readonly _rendering = resolve(IRendering);\n\n  public readonly target = InstructionType.hydrateTemplateController;\n\n  public render(\n    renderingCtrl: IHydratableController,\n    target: HTMLElement,\n    // <CustomAttributeDefinition> as we assume it's always used with the default resources resolver\n    instruction: HydrateTemplateController<CustomAttributeDefinition>,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    /* eslint-disable prefer-const */\n    let ctxContainer = renderingCtrl.container;\n    let def: CustomAttributeDefinition | null;\n    switch (typeof instruction.res) {\n      case 'string':\n        def = CustomAttribute.find(ctxContainer, instruction.res);\n        if (def == null) {\n          throw createMappedError(ErrorNames.attribute_tc_res_not_found, instruction, renderingCtrl);\n        }\n        break;\n      // constructor based instruction\n      // will be enabled later if needed.\n      // As both AOT + runtime based can use definition for perf\n      // -----------------\n      // case 'function':\n      //   def = CustomAttribute.getDefinition(instruction.res);\n      //   break;\n      default:\n        def = instruction.res;\n    }\n    // const viewFactory = this._rendering.getViewFactory(\n    //   instruction.def,\n    //   ctxContainer\n    // );\n    const viewFactory = this._rendering.getViewFactory(\n      instruction.def,\n      def.containerStrategy === 'new'\n        ? ctxContainer.createChild({ inheritParentResources: true })\n        : ctxContainer\n    );\n    const renderLocation = convertToRenderLocation(target);\n    const results = invokeAttribute(\n      /* platform         */platform,\n      /* attr definition  */def,\n      /* parentController */renderingCtrl,\n      /* host             */target,\n      /* instruction      */instruction,\n      /* viewFactory      */viewFactory,\n      /* location         */renderLocation,\n    );\n    const childController = Controller.$attr(\n      /* container ct */results.ctn,\n      /* viewModel    */results.vm,\n      /* host         */target,\n      /* definition   */def,\n    );\n\n    setRef(renderLocation, def.key, childController);\n\n    results.vm.link?.(renderingCtrl, childController, target, instruction);\n\n    const renderers = this._rendering.renderers;\n    const props = instruction.props;\n    const ii = props.length;\n    let i = 0;\n    let propInst: IInstruction;\n    while (ii > i) {\n      propInst = props[i];\n      renderers[propInst.type].render(renderingCtrl, childController, propInst, platform, exprParser, observerLocator);\n      ++i;\n    }\n\n    renderingCtrl.addChild(childController);\n    /* eslint-enable prefer-const */\n  }\n}, null!);\n\nexport const LetElementRenderer = /*@__PURE__*/ renderer(class LetElementRenderer implements IRenderer {\n  public readonly target = InstructionType.hydrateLetElement;\n  public constructor() {\n    LetBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: Node & ChildNode,\n    instruction: HydrateLetElementInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    target.remove();\n    const childInstructions = instruction.instructions;\n    const toBindingContext = instruction.toBindingContext;\n    const container = renderingCtrl.container;\n    const ii = childInstructions.length;\n\n    let childInstruction: LetBindingInstruction;\n    let expr: AnyBindingExpression;\n    let i = 0;\n    while (ii > i) {\n      childInstruction = childInstructions[i];\n      expr = ensureExpression(exprParser, childInstruction.from, etIsProperty);\n      renderingCtrl.addBinding(new LetBinding(\n        container,\n        observerLocator,\n        expr,\n        childInstruction.to,\n        toBindingContext,\n        renderingCtrl.strict ?? false,\n      ));\n      ++i;\n    }\n  }\n}, null!);\n\nexport const RefBindingRenderer = /*@__PURE__*/ renderer(class RefBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.refBinding;\n  public render(\n    renderingCtrl: IHydratableController,\n    target: INode,\n    instruction: RefBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n  ): void {\n    renderingCtrl.addBinding(new RefBinding(\n      renderingCtrl.container,\n      ensureExpression(exprParser, instruction.from, etIsProperty),\n      getRefTarget(target, instruction.to),\n      renderingCtrl.strict ?? false,\n    ));\n  }\n}, null!);\n\nexport const InterpolationBindingRenderer = /*@__PURE__*/ renderer(class InterpolationBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.interpolation;\n  public constructor() {\n    InterpolationPartBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: IController | HTMLElement,\n    instruction: InterpolationInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    const container = renderingCtrl.container;\n    const binding = new InterpolationBinding(\n      renderingCtrl,\n      container,\n      observerLocator,\n      platform.domQueue,\n      ensureExpression(exprParser, instruction.from, etInterpolation),\n      getTarget(target),\n      instruction.to,\n      toView,\n      renderingCtrl.strict ?? false,\n    );\n    if (instruction.to === 'class' && (binding.target as Node).nodeType > 0) {\n      const cssMapping = container.get(fromHydrationContext(ICssClassMapping));\n      binding.useAccessor(new ClassAttributeAccessor(binding.target as HTMLElement, cssMapping));\n    }\n    renderingCtrl.addBinding(binding);\n  }\n}, null!);\n\nexport const PropertyBindingRenderer = /*@__PURE__*/ renderer(class PropertyBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.propertyBinding;\n  public constructor() {\n    PropertyBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: IController,\n    instruction: PropertyBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    const container = renderingCtrl.container;\n    const binding = new PropertyBinding(\n      renderingCtrl,\n      container,\n      observerLocator,\n      platform.domQueue,\n      ensureExpression(exprParser, instruction.from, etIsProperty),\n      getTarget(target),\n      instruction.to,\n      instruction.mode,\n      renderingCtrl.strict ?? false,\n    );\n    if (instruction.to === 'class' && (binding.target as Node).nodeType > 0) {\n      const cssMapping = container.get(fromHydrationContext(ICssClassMapping));\n      binding.useTargetObserver(new ClassAttributeAccessor(binding.target as HTMLElement, cssMapping));\n    }\n    renderingCtrl.addBinding(binding);\n  }\n}, null!);\n\nexport const IteratorBindingRenderer = /*@__PURE__*/ renderer(class IteratorBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.iteratorBinding;\n  public constructor() {\n    PropertyBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: IController,\n    instruction: IteratorBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    renderingCtrl.addBinding(new PropertyBinding(\n      renderingCtrl,\n      renderingCtrl.container,\n      observerLocator,\n      platform.domQueue,\n      ensureExpression(exprParser, instruction.forOf, etIsIterator),\n      getTarget(target),\n      instruction.to,\n      toView,\n      renderingCtrl.strict ?? false,\n    ));\n  }\n}, null!);\n\nexport const TextBindingRenderer = /*@__PURE__*/ renderer(class TextBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.textBinding;\n  public constructor() {\n    ContentBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: ChildNode,\n    instruction: TextBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    renderingCtrl.addBinding(new ContentBinding(\n      renderingCtrl,\n      renderingCtrl.container,\n      observerLocator,\n      platform.domQueue,\n      platform,\n      ensureExpression(exprParser, instruction.from, etIsProperty),\n      target as Text,\n      renderingCtrl.strict ?? false,\n    ));\n  }\n}, null!);\n\n/**\n * An interface describing configuration for listener bindings\n */\nexport interface IListenerBindingOptions {\n  /**\n   * Indicate whether listener should by default call preventDefault on all the events\n   */\n  prevent: boolean;\n\n  /**\n   * The error handler for listener bindings, by default, it will dispatch an event `au-event-error` on the window object\n   * and if the event is not prevented, it will throw the errors caught by the listener bindings\n   */\n  onError: (event: Event, error: unknown) => void;\n\n}\nexport const IListenerBindingOptions = createInterface<IListenerBindingOptions>('IListenerBindingOptions', x => x.singleton(class {\n  /** @internal */\n  private readonly p = resolve(IPlatform);\n  public prevent = false;\n\n  public onError = (event: Event, error: unknown) => {\n    const errorEvent = new this.p.CustomEvent('au-event-error', { cancelable: true, detail: { event, error } });\n    this.p.window.dispatchEvent(errorEvent);\n    if (errorEvent.defaultPrevented) {\n      return;\n    }\n    throw error;\n  };\n}));\n\nexport const ListenerBindingRenderer = /*@__PURE__*/ renderer(class ListenerBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.listenerBinding;\n\n  /** @internal */\n  public readonly _modifierHandler = resolve(IEventModifier);\n  /** @internal */\n  public readonly _defaultOptions = resolve(IListenerBindingOptions);\n\n  public constructor() {\n    ListenerBinding.mix();\n  }\n\n  public render(\n    renderingCtrl: IHydratableController,\n    target: HTMLElement,\n    instruction: ListenerBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n  ): void {\n    renderingCtrl.addBinding(new ListenerBinding(\n      renderingCtrl.container,\n      ensureExpression(exprParser, instruction.from, etIsFunction),\n      target,\n      instruction.to,\n      new ListenerBindingOptions(this._defaultOptions.prevent, instruction.capture, this._defaultOptions.onError),\n      this._modifierHandler.getHandler(instruction.to, instruction.modifier),\n      renderingCtrl.strict ?? false,\n    ));\n  }\n}, null!);\n\nexport const SetAttributeRenderer = /*@__PURE__*/ renderer(class SetAttributeRenderer implements IRenderer {\n  public readonly target = InstructionType.setAttribute;\n  public render(\n    _: IHydratableController,\n    target: HTMLElement,\n    instruction: SetAttributeInstruction,\n  ): void {\n    target.setAttribute(instruction.to, instruction.value);\n  }\n}, null!);\n\nexport const SetClassAttributeRenderer = /*@__PURE__*/ renderer(class SetClassAttributeRenderer implements IRenderer {\n  public readonly target = InstructionType.setClassAttribute;\n  public render(\n    _: IHydratableController,\n    target: HTMLElement,\n    instruction: SetClassAttributeInstruction,\n  ): void {\n    addClasses(target.classList, instruction.value);\n  }\n}, null!);\n\nexport const SetStyleAttributeRenderer = /*@__PURE__*/ renderer(class SetStyleAttributeRenderer implements IRenderer {\n  public readonly target = InstructionType.setStyleAttribute;\n  public render(\n    _: IHydratableController,\n    target: HTMLElement,\n    instruction: SetStyleAttributeInstruction,\n  ): void {\n    target.style.cssText += instruction.value;\n  }\n}, null!);\n\n/* istanbul ignore next */\nconst ambiguousStyles = [\n  'height',\n  'width',\n  'border-width',\n  'padding',\n  'padding-left',\n  'padding-right',\n  'padding-top',\n  'padding-right',\n  'padding-inline',\n  'padding-block',\n  'margin',\n  'margin-left',\n  'margin-right',\n  'margin-top',\n  'margin-bottom',\n  'margin-inline',\n  'margin-block',\n  'top',\n  'right',\n  'bottom',\n  'left',\n];\n\nexport const StylePropertyBindingRenderer = /*@__PURE__*/ renderer(class StylePropertyBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.stylePropertyBinding;\n  public constructor() {\n    PropertyBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: HTMLElement,\n    instruction: StylePropertyBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    if (__DEV__) {\n      /* istanbul ignore next */\n      if (ambiguousStyles.includes(instruction.to)) {\n        renderingCtrl.addBinding(new DevStylePropertyBinding(\n          renderingCtrl,\n          renderingCtrl.container,\n          observerLocator,\n          platform.domQueue,\n          ensureExpression(exprParser, instruction.from, etIsProperty),\n          target.style,\n          instruction.to,\n          toView,\n          renderingCtrl.strict ?? false,\n        ));\n        return;\n      }\n    }\n    renderingCtrl.addBinding(new PropertyBinding(\n      renderingCtrl,\n      renderingCtrl.container,\n      observerLocator,\n      platform.domQueue,\n      ensureExpression(exprParser, instruction.from, etIsProperty),\n      target.style,\n      instruction.to,\n      toView,\n      renderingCtrl.strict ?? false,\n    ));\n  }\n}, null!);\n\n/* istanbul ignore next */\nclass DevStylePropertyBinding extends PropertyBinding {\n  public updateTarget(value: unknown): void {\n    if (typeof value === 'number' && value > 0) {\n      // eslint-disable-next-line no-console\n      console.warn(`[DEV]: Setting number ${value} as value for style.${this.targetProperty}. Did you meant \"${value}px\"?`);\n    }\n    return super.updateTarget(value);\n  }\n}\n\nexport const AttributeBindingRenderer = /*@__PURE__*/ renderer(class AttributeBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.attributeBinding;\n  public constructor() {\n    AttributeBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: HTMLElement,\n    instruction: AttributeBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    const container = renderingCtrl.container;\n    const classMapping =\n      container.has(ICssClassMapping, false)\n        ? container.get(ICssClassMapping)\n        : null;\n    renderingCtrl.addBinding(new AttributeBinding(\n      renderingCtrl,\n      container,\n      observerLocator,\n      platform.domQueue,\n      ensureExpression(exprParser, instruction.from, etIsProperty),\n      target,\n      instruction.attr/* targetAttribute */,\n      classMapping == null\n        ? instruction.to/* targetKey */\n        : instruction.to.split(/\\s/g).map(c => classMapping[c] ?? c).join(' '),\n      toView,\n      renderingCtrl.strict ?? false,\n    ));\n  }\n}, null!);\n\nexport const SpreadRenderer = /*@__PURE__*/ renderer(class SpreadRenderer implements IRenderer {\n  /** @internal */ public readonly _compiler = resolve(ITemplateCompiler);\n  /** @internal */ public readonly _rendering = resolve(IRendering);\n\n  public readonly target = InstructionType.spreadTransferedBinding;\n\n  public render(\n    renderingCtrl: IHydratableController,\n    target: HTMLElement,\n    instruction: SpreadTransferedBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    SpreadBinding.create(\n      renderingCtrl.container.get(IHydrationContext),\n      target,\n      void 0,\n      this._rendering,\n      this._compiler,\n      platform,\n      exprParser,\n      observerLocator\n    )\n    .forEach(b => renderingCtrl.addBinding(b));\n  }\n}, null!);\n\nexport const SpreadValueRenderer = /*@__PURE__*/ renderer(class SpreadValueRenderer implements IRenderer {\n  public readonly target = InstructionType.spreadValueBinding;\n  public constructor() {\n    SpreadValueBinding.mix();\n  }\n\n  public render(\n    renderingCtrl: IHydratableController,\n    target: ICustomElementController,\n    instruction: SpreadValueBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    const instructionTarget = instruction.target;\n    if (instructionTarget === '$bindables') {\n      renderingCtrl.addBinding(new SpreadValueBinding(\n        renderingCtrl,\n        target.viewModel,\n        objectKeys(target.definition.bindables),\n        exprParser.parse(instruction.from, etIsProperty),\n        observerLocator,\n        renderingCtrl.container,\n        platform.domQueue,\n        renderingCtrl.strict ?? false,\n      ));\n    } else {\n      throw createMappedError(ErrorNames.spreading_invalid_target, instructionTarget);\n    }\n  }\n}, null!);\n\n// http://jsben.ch/7n5Kt\nfunction addClasses(classList: DOMTokenList, className: string): void {\n  const len = className.length;\n  let start = 0;\n  for (let i = 0; i < len; ++i) {\n    if (className.charCodeAt(i) === 0x20) {\n      if (i !== start) {\n        classList.add(className.slice(start, i));\n      }\n      start = i + 1;\n    } else if (i + 1 === len) {\n      classList.add(className.slice(start));\n    }\n  }\n}\n\n// const createSurrogateBinding = (context: IHydrationContext<object>) =>\n//   new SpreadBinding([], context) as SpreadBinding & IHydratableController;\nconst controllerProviderName = 'IController';\nconst instructionProviderName = 'IInstruction';\nconst locationProviderName = 'IRenderLocation';\nconst slotInfoProviderName = 'ISlotsInfo';\n\nfunction createElementContainer(\n  p: IPlatform,\n  renderingCtrl: IController,\n  host: HTMLElement,\n  instruction: HydrateElementInstruction,\n  location: IRenderLocation | null,\n  auSlotsInfo?: IAuSlotsInfo,\n): IContainer {\n  const ctn = renderingCtrl.container.createChild();\n\n  registerHostNode(ctn, host, p);\n  registerResolver(ctn, IController, new InstanceProvider(controllerProviderName, renderingCtrl));\n  registerResolver(ctn, IInstruction, new InstanceProvider(instructionProviderName, instruction));\n  registerResolver(ctn, IRenderLocation, location == null\n    ? noLocationProvider\n    : new RenderLocationProvider(location));\n  registerResolver(ctn, IViewFactory, noViewFactoryProvider);\n  registerResolver(ctn, IAuSlotsInfo, auSlotsInfo == null\n    ? noAuSlotProvider\n    : new InstanceProvider(slotInfoProviderName, auSlotsInfo)\n  );\n\n  return ctn;\n}\n\nclass ViewFactoryProvider implements IResolver {\n  private readonly f: IViewFactory | null;\n  public get $isResolver(): true { return true; }\n\n  public constructor(\n    /**\n     * The factory instance that this provider will resolves to,\n     * until explicitly overridden by prepare call\n     */\n    factory: IViewFactory | null\n  ) {\n    this.f = factory;\n  }\n\n  public resolve(): IViewFactory {\n    const f = this.f;\n    if (f === null) {\n      throw createMappedError(ErrorNames.view_factory_provider_not_ready);\n    }\n    if (!isString(f.name) || f.name.length === 0) {\n      throw createMappedError(ErrorNames.view_factory_invalid_name);\n    }\n    return f;\n  }\n}\n\n/** @internal */\nexport interface IHasController {\n  $controller: IController;\n}\n\nfunction invokeAttribute(\n  p: IPlatform,\n  definition: CustomAttributeDefinition,\n  $renderingCtrl: IController | IHasController,\n  host: HTMLElement,\n  instruction: HydrateAttributeInstruction | HydrateTemplateController,\n  viewFactory?: IViewFactory,\n  location?: IRenderLocation,\n  auSlotsInfo?: IAuSlotsInfo,\n): { vm: ICustomAttributeViewModel; ctn: IContainer } {\n  const renderingCtrl = $renderingCtrl instanceof Controller\n    ? $renderingCtrl\n    : ($renderingCtrl as IHasController).$controller;\n  const ctn = renderingCtrl.container.createChild();\n  registerHostNode(ctn, host, p);\n  registerResolver(ctn, IController, new InstanceProvider(controllerProviderName, renderingCtrl));\n  registerResolver(ctn, IInstruction, new InstanceProvider<IInstruction>(instructionProviderName, instruction));\n  registerResolver(ctn, IRenderLocation, location == null\n    ? noLocationProvider\n    : new InstanceProvider(locationProviderName, location));\n  registerResolver(ctn, IViewFactory, viewFactory == null\n    ? noViewFactoryProvider\n    : new ViewFactoryProvider(viewFactory));\n  registerResolver(ctn, IAuSlotsInfo, auSlotsInfo == null\n    ? noAuSlotProvider\n    : new InstanceProvider(slotInfoProviderName, auSlotsInfo));\n\n  return { vm: ctn.invoke(definition.Type), ctn };\n}\n\nclass RenderLocationProvider implements IResolver {\n  public get name() { return 'IRenderLocation'; }\n  public get $isResolver(): true { return true; }\n\n  public constructor(\n    private readonly _location: IRenderLocation | null\n  ) {}\n\n  public resolve(): IRenderLocation | null {\n    return this._location;\n  }\n}\n\nconst noLocationProvider = new RenderLocationProvider(null);\nconst noViewFactoryProvider = new ViewFactoryProvider(null);\nconst noAuSlotProvider = new InstanceProvider<IAuSlotsInfo>(slotInfoProviderName, new AuSlotsInfo(emptyArray));\n", "import { createLookup, isString, IContainer, resolve } from '@aurelia/kernel';\nimport { IExpressionParser } from '@aurelia/expression-parser';\nimport { IObserverLocator } from '@aurelia/runtime';\n\nimport { FragmentNodeSequence, INode, INodeSequence } from '../dom';\nimport { IPlatform } from '../platform';\nimport { IRenderer } from '../renderer';\nimport { CustomElementDefinition, PartialCustomElementDefinition } from '../resources/custom-element';\nimport { IViewFactory, ViewFactory } from './view';\nimport type { IHydratableController } from './controller';\nimport { createInterface } from '../utilities-di';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { IInstruction, ITemplateCompiler } from '@aurelia/template-compiler';\n\nexport const IRendering = /*@__PURE__*/createInterface<IRendering>('IRendering', x => x.singleton(Rendering));\nexport interface IRendering {\n  get renderers(): Record<string, IRenderer>;\n\n  compile(\n    definition: CustomElementDefinition,\n    container: IContainer,\n  ): CustomElementDefinition;\n\n  getViewFactory(definition: PartialCustomElementDefinition, container: IContainer): IViewFactory;\n\n  createNodes(definition: CustomElementDefinition): INodeSequence;\n\n  render(\n    controller: IHydratableController,\n    targets: ArrayLike<INode>,\n    definition: CustomElementDefinition,\n    host: INode | null | undefined,\n  ): void;\n}\n\nexport class Rendering implements IRendering {\n  /** @internal */\n  private readonly _ctn: IContainer;\n  /** @internal */\n  private readonly _exprParser: IExpressionParser;\n  /** @internal */\n  private readonly _observerLocator: IObserverLocator;\n  /** @internal */\n  private _renderers: Record<string, IRenderer> | undefined;\n  /** @internal */\n  private readonly _platform: IPlatform;\n  /** @internal */\n  private readonly _compilationCache: WeakMap<PartialCustomElementDefinition, CustomElementDefinition> = new WeakMap();\n  /** @internal */\n  private readonly _fragmentCache: WeakMap<CustomElementDefinition, DocumentFragment | null> = new WeakMap();\n  /** @internal */\n  private readonly _empty: INodeSequence;\n  /** @internal */\n  private readonly _marker: Node;\n\n  public get renderers(): Record<string, IRenderer> {\n    return this._renderers ??= this._ctn.getAll(IRenderer, false).reduce((all, r) => {\n      if (__DEV__) {\n        if (all[r.target] !== void 0) {\n          // eslint-disable-next-line no-console\n          console.warn(`[DEV:aurelia] Renderer for target ${r.target} already exists.`);\n        }\n      }\n      all[r.target] ??= r;\n      return all;\n    }, createLookup<IRenderer>());\n  }\n\n  public constructor() {\n    const ctn = this._ctn = resolve(IContainer).root;\n    const p = this._platform = ctn.get(IPlatform);\n    this._exprParser= ctn.get(IExpressionParser);\n    this._observerLocator = ctn.get(IObserverLocator);\n    this._marker = p.document.createElement('au-m');\n    this._empty = new FragmentNodeSequence(p, p.document.createDocumentFragment());\n  }\n\n  public compile(\n    definition: CustomElementDefinition,\n    container: IContainer,\n  ): CustomElementDefinition {\n    const compiler = container.get(ITemplateCompiler);\n    const compiledMap = this._compilationCache;\n    let compiled = compiledMap.get(definition);\n    if (compiled == null) {\n      compiledMap.set(definition, compiled = CustomElementDefinition.create(\n        definition.needsCompile\n          ? compiler.compile(\n            definition,\n            container,\n          )\n          : definition\n      ));\n    }\n    return compiled;\n  }\n\n  public getViewFactory(definition: PartialCustomElementDefinition, container: IContainer): IViewFactory {\n    return new ViewFactory(container, CustomElementDefinition.getOrCreate(definition));\n  }\n\n  public createNodes(definition: CustomElementDefinition): INodeSequence {\n    if (definition.enhance === true) {\n      return new FragmentNodeSequence(this._platform, this._transformMarker(definition.template as Node) as DocumentFragment);\n    }\n    let fragment: DocumentFragment | null | undefined;\n    let needsImportNode = false;\n    const cache = this._fragmentCache;\n    const p = this._platform;\n    const doc = p.document;\n    if (cache.has(definition)) {\n      fragment = cache.get(definition);\n    } else {\n      const template = definition.template;\n      let tpl: HTMLTemplateElement;\n      if (template == null) {\n        fragment = null;\n      } else if (template instanceof p.Node) {\n        if (template.nodeName === 'TEMPLATE') {\n          fragment = (template as HTMLTemplateElement).content;\n          needsImportNode = true;\n        } else {\n          (fragment = doc.createDocumentFragment()).appendChild(template.cloneNode(true));\n        }\n      } else {\n        tpl = doc.createElement('template');\n        if (isString(template)) {\n          tpl.innerHTML = template;\n        }\n        fragment = tpl.content;\n        needsImportNode = true;\n      }\n      this._transformMarker(fragment);\n\n      cache.set(definition, fragment);\n    }\n    return fragment == null\n      ? this._empty\n      : new FragmentNodeSequence(\n        this._platform,\n        needsImportNode\n          ? doc.importNode(fragment, true)\n          : doc.adoptNode(fragment.cloneNode(true) as DocumentFragment)\n        );\n  }\n\n  public render(\n    controller: IHydratableController,\n    targets: ArrayLike<INode>,\n    definition: CustomElementDefinition,\n    host: INode | null | undefined,\n  ): void {\n    const rows = definition.instructions;\n    const renderers = this.renderers;\n    const ii = targets.length;\n\n    let i = 0;\n    let j = 0;\n    let jj = rows.length;\n    let row: readonly IInstruction[];\n    let instruction: IInstruction;\n    let target: INode;\n\n    if (ii !== jj) {\n      throw createMappedError(ErrorNames.rendering_mismatch_length, ii, jj);\n    }\n\n    if (ii > 0) {\n      while (ii > i) {\n        row = rows[i];\n        target = targets[i];\n        j = 0;\n        jj = row.length;\n        while (jj > j) {\n          instruction = row[j];\n          renderers[instruction.type].render(controller, target, instruction, this._platform, this._exprParser, this._observerLocator);\n          ++j;\n        }\n        ++i;\n      }\n    }\n\n    if (host != null) {\n      row = definition.surrogates;\n      if ((jj = row.length) > 0) {\n        j = 0;\n        while (jj > j) {\n          instruction = row[j];\n          renderers[instruction.type].render(controller, host, instruction, this._platform, this._exprParser, this._observerLocator);\n          ++j;\n        }\n      }\n    }\n  }\n\n  /** @internal */\n  private _transformMarker(fragment: Node | null) {\n    if (fragment == null) {\n      return null;\n    }\n    const walker = this._platform.document.createTreeWalker(fragment, /* NodeFilter.SHOW_COMMENT */ 128);\n    let currentNode: Node | null;\n    while ((currentNode = walker.nextNode()) != null) {\n      if (currentNode.nodeValue === 'au*') {\n        currentNode.parentNode!.replaceChild(walker.currentNode = this._marker.cloneNode(), currentNode);\n      }\n    }\n    return fragment;\n    // below is a homemade \"comment query selector that seems to be as efficient as the TreeWalker\n    // also it works with very minimal set of APIs (.nextSibling, .parentNode, .insertBefore, .removeChild)\n    // while TreeWalker maynot be always available in platform that we may potentially support\n    //\n    // so leaving it here just in case we need it again, TreeWalker is slightly less code\n\n    // let parent: Node = fragment;\n    // let current: Node | null | undefined = parent.firstChild;\n    // let next: Node | null | undefined = null;\n\n    // while (current != null) {\n    //   if (current.nodeType === 8 && current.nodeValue === 'au*') {\n    //     next = current.nextSibling!;\n    //     parent.removeChild(current);\n    //     parent.insertBefore(this._marker(), next);\n    //     if (next.nodeType === 8) {\n    //       current = next.nextSibling;\n    //       // todo: maybe validate?\n    //     } else {\n    //       current = next;\n    //     }\n    //   }\n\n    //   next = current?.firstChild;\n    //   if (next == null) {\n    //     next = current?.nextSibling;\n    //     if (next == null) {\n    //       current = parent.nextSibling;\n    //       parent = parent.parentNode!;\n    //       // needs to keep walking up all the way til a valid next node\n    //       while (current == null && parent != null) {\n    //         current = parent.nextSibling;\n    //         parent = parent.parentNode!;\n    //       }\n    //     } else {\n    //       current = next;\n    //     }\n    //   } else {\n    //     parent = current!;\n    //     current = next;\n    //   }\n    // }\n    // return fragment;\n  }\n}\n", "import { IContainer, createLookup, noop, own, resolve, toArray } from '@aurelia/kernel';\nimport { AppTask } from '../app-task';\nimport { ICssClassMapping } from '../dom';\nimport { IPlatform } from '../platform';\nimport { createInterface, instanceRegistration } from '../utilities-di';\n\nimport type { IRegistry } from '@aurelia/kernel';\nimport { ITemplateCompilerHooks, TemplateCompilerHooks } from '@aurelia/template-compiler';\nimport { objectAssign } from '../utilities';\n\n/**\n * There are 2 implementations of CSS registry: css module registry and shadow dom registry.\n *\n * - CSS registry alters the way class bindings work via altering templates and register interfaces that will alter bindings to class attribute.\n *\n * - Shadow dom registry regisiters some interfaces with the custom element container to handle shadow dom styles.\n * Shadow DOM abtraction summary:\n * CSS registry ---(register)---> IShadowDOMStyleFactory ---(createStyles)---> IShadowDOMStyles ---(applyTo)---> ShadowRoot\n */\n\n/**\n * create a registry to register CSS module handling for a custom element.\n * The resulting registry can be registered as a dependency of a custom element.\n */\nexport function cssModules(...modules: (Record<string, string>)[]): CSSModulesProcessorRegistry {\n  return new CSSModulesProcessorRegistry(modules);\n}\n\nexport class CSSModulesProcessorRegistry implements IRegistry {\n  public constructor(\n    private readonly modules: Record<string, string>[],\n  ) {}\n\n  public register(container: IContainer): void {\n    let existingMapping = container.get(own(ICssClassMapping));\n    if (existingMapping == null) {\n      container.register(\n        instanceRegistration(ICssClassMapping, existingMapping = createLookup()),\n      );\n    }\n    /* istanbul ignore if */\n    if (__DEV__) {\n      for (const mapping of this.modules) {\n        for (const originalClass in mapping) {\n          if (originalClass in existingMapping) {\n            // eslint-disable-next-line no-console\n            console.warn(`[DEV:aurelia] CSS class mapping for class \"${originalClass}\": \"${mapping[originalClass]}\" is overridden by \"${existingMapping[originalClass]}\"`);\n          }\n          existingMapping[originalClass] = mapping[originalClass];\n        }\n      }\n    } else {\n      objectAssign(existingMapping, ...this.modules);\n    }\n\n    class CompilingHook implements ITemplateCompilerHooks {\n      public compiling(template: HTMLElement): void {\n        const isTemplate = template.tagName === 'TEMPLATE';\n        const container = isTemplate\n          ? (template as HTMLTemplateElement).content\n          : template;\n        const plainClasses = [template, ...toArray(container.querySelectorAll('[class]'))];\n        for (const element of plainClasses) {\n          const classes = element.getAttributeNode('class')!;\n          // we always include container, so there's a case where classes is null\n          if (classes == null) {\n            continue;\n          }\n          const newClasses = classes.value.split(/\\s+/g).map(x => existingMapping![x] || x).join(' ');\n          classes.value = newClasses;\n        }\n      }\n    }\n\n    container.register(TemplateCompilerHooks.define(CompilingHook));\n  }\n}\n\n/**\n * Creates a registry to register shadow dom styles handling for a custom element.\n * The resulting registry can be registered as a dependency of a custom element.\n */\nexport function shadowCSS(...css: (string | CSSStyleSheet)[]): ShadowDOMRegistry {\n  return new ShadowDOMRegistry(css);\n}\n\nexport interface IShadowDOMStyleFactory {\n  createStyles(localStyles: (string | CSSStyleSheet)[], sharedStyles: IShadowDOMStyles | null): IShadowDOMStyles;\n}\n\nexport const IShadowDOMStyleFactory = /*@__PURE__*/createInterface<IShadowDOMStyleFactory>('IShadowDOMStyleFactory', x => x.cachedCallback(handler => {\n  if (AdoptedStyleSheetsStyles.supported(handler.get(IPlatform))) {\n    return handler.get(AdoptedStyleSheetsStylesFactory);\n  }\n  return handler.get(StyleElementStylesFactory);\n}));\n\nexport class ShadowDOMRegistry implements IRegistry {\n  public constructor(\n    private readonly css: (string | CSSStyleSheet)[],\n  ) { }\n\n  public register(container: IContainer): void {\n    const sharedStyles = container.get(IShadowDOMGlobalStyles);\n    const factory = container.get(IShadowDOMStyleFactory);\n    container.register(instanceRegistration(IShadowDOMStyles, factory.createStyles(this.css, sharedStyles)));\n  }\n}\n\nclass AdoptedStyleSheetsStylesFactory implements IShadowDOMStyleFactory {\n  private readonly p = resolve(IPlatform);\n  private readonly cache = new Map<string, CSSStyleSheet>();\n\n  public createStyles(localStyles: (string | CSSStyleSheet)[], sharedStyles: IShadowDOMStyles | null): IShadowDOMStyles {\n    return new AdoptedStyleSheetsStyles(this.p, localStyles, this.cache, sharedStyles);\n  }\n}\n\n// not really needed nowadays since all browsers support adopted style sheet\n// though keep it here for a bit longer before removing\n/* istanbul ignore next */\nclass StyleElementStylesFactory implements IShadowDOMStyleFactory {\n  private readonly p = resolve(IPlatform);\n\n  public createStyles(localStyles: string[], sharedStyles: IShadowDOMStyles | null): IShadowDOMStyles {\n    return new StyleElementStyles(this.p, localStyles, sharedStyles);\n  }\n}\n\ntype HasAdoptedStyleSheets = ShadowRoot & {\n  adoptedStyleSheets: CSSStyleSheet[];\n};\n\nexport interface IShadowDOMStyles {\n  applyTo(shadowRoot: ShadowRoot): void;\n}\n\nexport const IShadowDOMStyles = /*@__PURE__*/createInterface<IShadowDOMStyles>('IShadowDOMStyles');\nexport const IShadowDOMGlobalStyles = /*@__PURE__*/createInterface<IShadowDOMStyles>('IShadowDOMGlobalStyles', x => x.instance({ applyTo: noop }));\n\nexport class AdoptedStyleSheetsStyles implements IShadowDOMStyles {\n  private readonly styleSheets: CSSStyleSheet[];\n\n  public constructor(\n    p: IPlatform,\n    localStyles: (string | CSSStyleSheet)[],\n    styleSheetCache: Map<string, CSSStyleSheet>,\n    private readonly sharedStyles: IShadowDOMStyles | null = null\n  ) {\n    this.styleSheets = localStyles.map(x => {\n      let sheet: CSSStyleSheet | undefined;\n\n      if (x instanceof p.CSSStyleSheet) {\n        sheet = x;\n      } else {\n        sheet = styleSheetCache.get(x);\n\n        if (sheet === void 0) {\n          sheet = new p.CSSStyleSheet();\n          sheet.replaceSync(x);\n          styleSheetCache.set(x, sheet);\n        }\n      }\n\n      return sheet;\n    });\n  }\n\n  public static supported(p: IPlatform): boolean {\n    return 'adoptedStyleSheets' in p.ShadowRoot.prototype;\n  }\n\n  public applyTo(shadowRoot: HasAdoptedStyleSheets): void {\n    if (this.sharedStyles !== null) {\n      this.sharedStyles.applyTo(shadowRoot);\n    }\n\n    // https://wicg.github.io/construct-stylesheets/\n    // https://developers.google.com/web/updates/2019/02/constructable-stylesheets\n    shadowRoot.adoptedStyleSheets = [\n      ...shadowRoot.adoptedStyleSheets,\n      ...this.styleSheets\n    ];\n  }\n}\n\nexport class StyleElementStyles implements IShadowDOMStyles {\n  public constructor(\n    private readonly p: IPlatform,\n    private readonly localStyles: string[],\n    private readonly sharedStyles: IShadowDOMStyles | null = null\n  ) { }\n\n  public applyTo(shadowRoot: ShadowRoot): void {\n    const styles = this.localStyles;\n    const p = this.p;\n\n    for (let i = styles.length - 1; i > -1; --i) {\n      const element = p.document.createElement('style');\n      element.innerHTML = styles[i];\n      shadowRoot.prepend(element);\n    }\n\n    if (this.sharedStyles !== null) {\n      this.sharedStyles.applyTo(shadowRoot);\n    }\n  }\n}\n\nexport interface IShadowDOMConfiguration {\n  sharedStyles?: (string | CSSStyleSheet)[];\n}\n\nexport const StyleConfiguration = {\n  shadowDOM(config: IShadowDOMConfiguration): IRegistry {\n    return AppTask.creating(IContainer, container => {\n      if (config.sharedStyles != null) {\n        const factory = container.get(IShadowDOMStyleFactory);\n        container.register(instanceRegistration(IShadowDOMGlobalStyles, factory.createStyles(config.sharedStyles, null)));\n      }\n    });\n  }\n};\n", "import { areEqual, type IServiceLocator } from '@aurelia/kernel';\nimport { IsBindingBehavior } from '@aurelia/expression-parser';\nimport {\n  connectable,\n  ConnectableSwitcher,\n  ProxyObservable,\n  astEvaluate,\n} from '@aurelia/runtime';\nimport { mixinAstEvaluator } from '../binding/binding-utils';\n\nimport type {\n  ICollectionSubscriber,\n  IConnectable,\n  IObservable,\n  IObserverLocator,\n  IObserverLocatorBasedConnectable,\n  ISubscriber,\n  Scope,\n} from '@aurelia/runtime';\nimport type { IWatcherCallback } from '../watch';\nimport { IBinding } from '../binding/interfaces-bindings';\n\nconst { enter, exit } = ConnectableSwitcher;\nconst { wrap, unwrap } = ProxyObservable;\n\n// watchers (Computed & Expression) are basically binding,\n// they are treated as special and setup before all other bindings\n\nexport interface ComputedWatcher extends IObserverLocatorBasedConnectable, IServiceLocator { }\n\nexport class ComputedWatcher implements IBinding, ISubscriber, ICollectionSubscriber {\n  static {\n    connectable(ComputedWatcher, null!);\n  }\n\n  public isBound: boolean = false;\n\n  // todo: maybe use a counter allow recursive call to a certain level\n  private running: boolean = false;\n\n  /** @internal */\n  private _value: unknown = void 0;\n  public get value(): unknown {\n    return this._value;\n  }\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  private readonly _callback: IWatcherCallback<object>;\n\n  public constructor(\n    public readonly obj: IObservable,\n    observerLocator: IObserverLocator,\n    public readonly $get: (obj: object, watcher: IConnectable) => unknown,\n    cb: IWatcherCallback<object>,\n    public readonly useProxy: boolean,\n  ) {\n    this._callback = cb;\n    this.oL = observerLocator;\n  }\n\n  public handleChange(): void {\n    this.run();\n  }\n\n  public handleCollectionChange(): void {\n    this.run();\n  }\n\n  public bind(): void {\n    if (this.isBound) {\n      return;\n    }\n    this.compute();\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) {\n      return;\n    }\n    this.isBound = false;\n    this.obs.clearAll();\n  }\n\n  private run(): void {\n    if (!this.isBound || this.running) {\n      return;\n    }\n    const obj = this.obj;\n    const oldValue = this._value;\n    const newValue = this.compute();\n\n    if (!areEqual(newValue, oldValue)) {\n      // should optionally queue\n      this._callback.call(obj, newValue, oldValue, obj);\n    }\n  }\n\n  private compute(): unknown {\n    this.running = true;\n    this.obs.version++;\n    try {\n      enter(this);\n      return this._value = unwrap(this.$get.call(void 0, this.useProxy ? wrap(this.obj) : this.obj, this));\n    } finally {\n      this.obs.clear();\n      this.running = false;\n      exit(this);\n    }\n  }\n}\n\nexport interface ExpressionWatcher extends IObserverLocatorBasedConnectable, /* a hack, but it's only for internal */IServiceLocator { }\n\nexport class ExpressionWatcher implements IBinding, IObserverLocatorBasedConnectable {\n  static {\n    connectable(ExpressionWatcher, null!);\n    mixinAstEvaluator(ExpressionWatcher);\n  }\n\n  public isBound: boolean = false;\n  /**\n   * @internal\n   */\n  private readonly obj: object;\n\n  /** @internal */\n  private _value: unknown;\n  public get value(): unknown {\n    return this._value;\n  }\n\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  /** @internal */\n  private readonly _expression: IsBindingBehavior;\n\n  /** @internal */\n  private readonly _callback: IWatcherCallback<object>;\n\n  public constructor(\n    public scope: Scope,\n    public l: IServiceLocator,\n    public oL: IObserverLocator,\n    expression: IsBindingBehavior,\n    callback: IWatcherCallback<object>,\n  ) {\n    this.obj = scope.bindingContext;\n    this._expression = expression;\n    this._callback = callback;\n  }\n\n  public handleChange(value: unknown): void {\n    const expr = this._expression;\n    const obj = this.obj;\n    const oldValue = this._value;\n    const canOptimize = expr.$kind === 'AccessScope' && this.obs.count === 1;\n    if (!canOptimize) {\n      this.obs.version++;\n      value = astEvaluate(expr, this.scope, this, this);\n      this.obs.clear();\n    }\n    if (!areEqual(value, oldValue)) {\n      this._value = value;\n      // should optionally queue for batch synchronous\n      this._callback.call(obj, value, oldValue, obj);\n    }\n  }\n\n  public bind(): void {\n    if (this.isBound) {\n      return;\n    }\n    this.obs.version++;\n    this._value = astEvaluate(this._expression, this.scope, this, this);\n    this.obs.clear();\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) {\n      return;\n    }\n    this.isBound = false;\n    this.obs.clearAll();\n    this._value = void 0;\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */\nimport {\n  AnyFunction,\n  IIndexable,\n  ILogger,\n  InstanceProvider,\n  LogLevel,\n  noop,\n  onResolve,\n  onResolveAll,\n  optional,\n  optionalResource,\n  isFunction,\n  isPromise,\n  isString,\n} from '@aurelia/kernel';\nimport { IExpressionParser, IsBindingBehavior, AccessScopeExpression } from '@aurelia/expression-parser';\nimport {\n  ICoercionConfiguration,\n  IObserverLocator,\n  Scope,\n} from '@aurelia/runtime';\nimport { convertToRenderLocation, setRef } from '../dom';\nimport { IPlatform } from '../platform';\nimport { CustomAttributeDefinition, getAttributeDefinition } from '../resources/custom-attribute';\nimport { CustomElementDefinition, elementBaseName, findElementControllerFor, getElementDefinition, isElementType } from '../resources/custom-element';\nimport { etIsProperty, getOwnPropertyNames, objectFreeze } from '../utilities';\nimport { createInterface, registerResolver } from '../utilities-di';\nimport { LifecycleHooks, LifecycleHooksEntry } from './lifecycle-hooks';\nimport { IRendering } from './rendering';\nimport { IShadowDOMGlobalStyles, IShadowDOMStyles } from './styles';\nimport { ComputedWatcher, ExpressionWatcher } from './watchers';\n\nimport type {\n  Constructable,\n  IContainer,\n  IDisposable,\n  IServiceLocator,\n  ResourceDefinition,\n  Writable,\n} from '@aurelia/kernel';\nimport type {\n  IObservable,\n} from '@aurelia/runtime';\nimport type { INode, INodeSequence, IRenderLocation } from '../dom';\nimport { ErrorNames, createMappedError } from '../errors';\nimport type { IInstruction, AttrSyntax } from '@aurelia/template-compiler';\nimport type { PartialCustomElementDefinition } from '../resources/custom-element';\nimport type { IWatchDefinition, IWatcherCallback } from '../watch';\nimport type { LifecycleHooksLookup } from './lifecycle-hooks';\nimport type { IViewFactory } from './view';\nimport { IBinding } from '../binding/interfaces-bindings';\n\nexport class Controller<C extends IViewModel = IViewModel> implements IController<C> {\n\n  public head: IHydratedController | null = null;\n  public tail: IHydratedController | null = null;\n  public next: IHydratedController | null = null;\n\n  public parent: IHydratedController | null = null;\n  public bindings: IBinding[] | null = null;\n  public children: Controller[] | null = null;\n\n  public hasLockedScope: boolean = false;\n\n  public scope: Scope | null = null;\n  public isBound: boolean = false;\n  /** @internal */\n  private _isBindingDone: boolean = false;\n\n  // If a host from another custom element was passed in, then this will be the controller for that custom element (could be `au-viewport` for example).\n  // In that case, this controller will create a new host node (with the definition's name) and use that as the target host for the nodes instead.\n  // That host node is separately mounted to the host controller's original host node.\n  public hostController: Controller | null = null;\n  public mountTarget: MountTarget = targetNone;\n  public shadowRoot: ShadowRoot | null = null;\n  public nodes: INodeSequence | null = null;\n  public location: IRenderLocation | null = null;\n\n  /** @internal */\n  public _lifecycleHooks: LifecycleHooksLookup<ICompileHooks & IActivationHooks<IHydratedController>> | null = null;\n  public get lifecycleHooks(): LifecycleHooksLookup<ICompileHooks & IActivationHooks<IHydratedController>> | null {\n    return this._lifecycleHooks;\n  }\n\n  public state: State = none;\n\n  public get isActive(): boolean {\n    return (this.state & (activating | activated)) > 0 && (this.state & deactivating) === 0;\n  }\n\n  public get name(): string {\n    if (this.parent === null) {\n      switch (this.vmKind) {\n        case vmkCa:\n          return `[${this.definition!.name}]`;\n        case vmkCe:\n          return this.definition!.name;\n        case vmkSynth:\n          return this.viewFactory!.name;\n      }\n    }\n    switch (this.vmKind) {\n      case vmkCa:\n        return `${this.parent.name}>[${this.definition!.name}]`;\n      case vmkCe:\n        return `${this.parent.name}>${this.definition!.name}`;\n      case vmkSynth:\n        return this.viewFactory!.name === this.parent.definition?.name\n          ? `${this.parent.name}[view]`\n          : `${this.parent.name}[view:${this.viewFactory!.name}]`;\n    }\n  }\n\n  /** @internal */\n  private _compiledDef: CustomElementDefinition | undefined;\n  private logger!: ILogger;\n  private debug!: boolean;\n  /** @internal */\n  private _fullyNamed: boolean = false;\n  /** @internal */\n  private readonly _rendering: IRendering;\n\n  /** @internal */\n  public _vmHooks: HooksDefinition;\n\n  /** @internal */\n  public _vm: ControllerBindingContext<C> | null;\n  public get viewModel(): ControllerBindingContext<C> | null {\n    return this._vm;\n  }\n  public set viewModel(v: ControllerBindingContext<C> | null) {\n    this._vm = v;\n    this._vmHooks = v == null || this.vmKind === vmkSynth ? HooksDefinition.none : new HooksDefinition(v);\n  }\n\n  public coercion: ICoercionConfiguration | undefined;\n\n  public get strict() {\n    return (this.definition as CustomElementDefinition)?.strict;\n  }\n\n  public constructor(\n    public container: IContainer,\n    public readonly vmKind: ViewModelKind,\n    public readonly definition: CustomElementDefinition | CustomAttributeDefinition | null,\n    /**\n     * The viewFactory. Only present for synthetic views.\n     */\n    public viewFactory: IViewFactory | null,\n    /**\n     * The backing viewModel. Only present for custom attributes and elements.\n     */\n    viewModel: ControllerBindingContext<C> | null,\n    /**\n     * The physical host dom node.\n     *\n     * For containerless elements, this node will be removed from the DOM and replaced by a comment, which is assigned to the `location` property.\n     *\n     * For ShadowDOM elements, this will be the original declaring element, NOT the shadow root (the shadow root is stored on the `shadowRoot` property)\n     */\n    public host: HTMLElement | null,\n    /**\n     * The render location replacement for the host on containerless elements\n     */\n    location: IRenderLocation | null,\n  ) {\n    this._vm = viewModel;\n    this._vmHooks = vmKind === vmkSynth ? HooksDefinition.none : new HooksDefinition(viewModel!);\n    if (__DEV__) {\n      this.logger = null!;\n      this.debug = false;\n    }\n    this.location = location;\n    this._rendering = container.root.get(IRendering);\n    this.coercion = vmKind === vmkSynth\n      ? void 0\n      : container.get(optionalCoercionConfigResolver);\n  }\n\n  public static getCached<C extends ICustomElementViewModel = ICustomElementViewModel>(viewModel: C): ICustomElementController<C> | undefined {\n    return controllerLookup.get(viewModel) as ICustomElementController<C> | undefined;\n  }\n\n  public static getCachedOrThrow<C extends ICustomElementViewModel = ICustomElementViewModel>(viewModel: C): ICustomElementController<C> {\n    const $el = Controller.getCached(viewModel);\n    if ($el === void 0) {\n      throw createMappedError(ErrorNames.controller_cached_not_found, viewModel);\n    }\n    return $el as ICustomElementController<C>;\n  }\n\n  /**\n   * Create a controller for a custom element based on a given set of parameters\n   *\n   * @param ctn - The own container of the custom element\n   * @param viewModel - The view model object (can be any object if a definition is specified)\n   *\n   * Semi private API\n   */\n  public static $el<C extends ICustomElementViewModel = ICustomElementViewModel>(\n    ctn: IContainer,\n    viewModel: C,\n    host: HTMLElement,\n    hydrationInst: IControllerElementHydrationInstruction | null,\n    // Use this when `instance.constructor` is not a custom element type\n    // to pass on the CustomElement definition\n    definition: CustomElementDefinition | undefined = void 0,\n    // the associated render location of the host\n    // if the element is containerless\n    location: IRenderLocation | null = null,\n  ): ICustomElementController<C> {\n    if (controllerLookup.has(viewModel)) {\n      return controllerLookup.get(viewModel) as unknown as ICustomElementController<C>;\n    }\n\n    if (__DEV__) {\n      if (definition == null) {\n        try {\n          definition = getElementDefinition(viewModel.constructor as Constructable);\n        } catch (ex) {\n          // eslint-disable-next-line\n          console.error(`[DEV:aurelia] Custom element definition not found for creating a controller with host: <${host.nodeName} /> and component ${viewModel.constructor.name || '(Anonymous) class'}`);\n          throw ex;\n        }\n      }\n    } else {\n      definition = definition ?? getElementDefinition(viewModel.constructor as Constructable);\n    }\n\n    registerResolver(ctn, definition.Type, new InstanceProvider<typeof definition.Type>(definition.key, viewModel, definition.Type));\n    const controller = new Controller<C>(\n      /* container      */ctn,\n      /* vmKind         */vmkCe,\n      /* definition     */definition,\n      /* viewFactory    */null,\n      /* viewModel      */viewModel as ControllerBindingContext<C>,\n      /* host           */host,\n      /* location       */location,\n    );\n    // the hydration context this controller is provided with\n    const hydrationContext = ctn.get(optional(IHydrationContext)) as IHydrationContext;\n\n    if (definition.dependencies.length > 0) {\n      ctn.register(...definition.dependencies);\n    }\n    // each CE controller provides its own hydration context for its internal template\n    registerResolver(ctn, IHydrationContext, new InstanceProvider(\n      'IHydrationContext',\n      new HydrationContext(\n        controller as ICustomElementController,\n        hydrationInst,\n        hydrationContext,\n      )\n    ));\n    controllerLookup.set(viewModel, controller as Controller);\n\n    if (hydrationInst == null || hydrationInst.hydrate !== false) {\n      controller._hydrateCustomElement(hydrationInst);\n    }\n\n    return controller as ICustomElementController<C>;\n  }\n\n  /**\n   * Create a controller for a custom attribute based on a given set of parameters\n   *\n   * @param ctn - own container associated with the custom attribute object\n   * @param viewModel - the view model object\n   * @param host - host element where this custom attribute is used\n   * @param flags - todo(comment)\n   * @param definition - the definition of the custom attribute,\n   * will be used to override the definition associated with the view model object contructor if given\n   */\n  public static $attr<C extends ICustomAttributeViewModel = ICustomAttributeViewModel>(\n    ctn: IContainer,\n    viewModel: C,\n    host: HTMLElement,\n    /**\n     * The definition that will be used to hydrate the custom attribute view model\n     *\n     * If not given, will be the one associated with the constructor of the attribute view model given.\n     */\n    definition?: CustomAttributeDefinition,\n  ): ICustomAttributeController<C> {\n    if (controllerLookup.has(viewModel)) {\n      return controllerLookup.get(viewModel) as unknown as ICustomAttributeController<C>;\n    }\n\n    definition = definition ?? getAttributeDefinition(viewModel.constructor as Constructable);\n    registerResolver(ctn, definition.Type, new InstanceProvider<typeof definition.Type>(definition.key, viewModel, definition.Type));\n\n    const controller = new Controller<C>(\n      /* own ct         */ctn,\n      /* vmKind         */vmkCa,\n      /* definition     */definition,\n      /* viewFactory    */null,\n      /* viewModel      */viewModel as ControllerBindingContext<C>,\n      /* host           */host,\n      /* location       */null\n    );\n\n    if (definition.dependencies.length > 0) {\n      ctn.register(...definition.dependencies);\n    }\n\n    controllerLookup.set(viewModel, controller as Controller);\n\n    controller._hydrateCustomAttribute();\n\n    return controller as unknown as ICustomAttributeController<C>;\n  }\n\n  /**\n   * Create a synthetic view (controller) for a given factory\n   *\n   * @param viewFactory - todo(comment)\n   * @param flags - todo(comment)\n   * @param parentController - the parent controller to connect the created view with. Used in activation\n   *\n   * Semi private API\n   */\n  public static $view(\n    viewFactory: IViewFactory,\n    parentController: ISyntheticView | ICustomElementController | ICustomAttributeController | undefined = void 0,\n  ): ISyntheticView {\n    const controller = new Controller(\n      /* container      */viewFactory.container,\n      /* vmKind         */vmkSynth,\n      /* definition     */null,\n      /* viewFactory    */viewFactory,\n      /* viewModel      */null,\n      /* host           */null,\n      /* location       */null\n    );\n    controller.parent = parentController ?? null;\n\n    controller._hydrateSynthetic();\n\n    return controller as unknown as ISyntheticView;\n  }\n\n  /** @internal */\n  public _hydrateCustomElement(\n    hydrationInst: IControllerElementHydrationInstruction | null,\n  ): void {\n    if (__DEV__) {\n      this.logger = this.container.get(ILogger).root;\n      this.debug = this.logger.config.level <= LogLevel.debug;\n      if (this.debug) {\n        this.logger = this.logger.scopeTo(this.name);\n      }\n    }\n\n    const container = this.container;\n    const instance = this._vm!;\n    const definition = this.definition as CustomElementDefinition;\n\n    this.scope = Scope.create(instance, null, true);\n\n    if (definition.watches.length > 0) {\n      createWatchers(this, container, definition, instance);\n    }\n    createObservers(this, definition, instance as IIndexable<ICustomElementViewModel>);\n\n    this._lifecycleHooks = LifecycleHooks.resolve(container);\n    // Support Recursive Components by adding self to own context\n    container.register(definition.Type);\n    // definition.register(container);\n\n    if (definition.injectable !== null) {\n      registerResolver(\n        container,\n        definition.injectable,\n        new InstanceProvider('definition.injectable', instance as ICustomElementViewModel),\n      );\n    }\n\n    // If this is the root controller, then the AppRoot will invoke things in the following order:\n    // - Controller.hydrateCustomElement\n    // - runAppTasks('hydrating') // may return a promise\n    // - Controller.compile\n    // - runAppTasks('hydrated') // may return a promise\n    // - Controller.compileChildren\n    // This keeps hydration synchronous while still allowing the composition root compile hooks to do async work.\n    if (hydrationInst == null || hydrationInst.hydrate !== false) {\n      this._hydrate(hydrationInst?.hostController);\n      this._hydrateChildren();\n    }\n  }\n\n  /** @internal */\n  public _hydrate(hostController?: Controller | null): void {\n    if (this._lifecycleHooks!.hydrating != null) {\n      this._lifecycleHooks!.hydrating.forEach(callHydratingHook, this);\n    }\n    if (this._vmHooks._hydrating) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`invoking hydrating() hook`); }\n      this._vm!.hydrating(this as ICustomElementController);\n    }\n\n    const definition = this.definition!;\n    const compiledDef = this._compiledDef = this._rendering.compile(definition as CustomElementDefinition, this.container);\n    const shadowOptions = compiledDef.shadowOptions;\n    const hasSlots = compiledDef.hasSlots;\n    const containerless = compiledDef.containerless;\n    let host = this.host!;\n    let location: IRenderLocation | null = this.location;\n\n    let createLocation = false;\n    if (hostController != null) {\n      this.hostController = hostController;\n      createLocation = true;\n    } else if ((this.hostController = findElementControllerFor(host, optionalCeFind) as Controller | null) !== null) {\n      host = this.host = this.container.root.get(IPlatform).document.createElement(definition.name);\n      createLocation = true;\n    }\n\n    if (createLocation && containerless && location == null) {\n      location = this.location = convertToRenderLocation(host);\n    }\n\n    setRef(host, elementBaseName, this as IHydratedController);\n    setRef(host, definition.key, this as IHydratedController);\n    if (shadowOptions !== null || hasSlots) {\n      if (location != null) {\n        throw createMappedError(ErrorNames.controller_no_shadow_on_containerless);\n      }\n      setRef(this.shadowRoot = host.attachShadow(shadowOptions ?? defaultShadowOptions), elementBaseName, this as IHydratedController);\n      setRef(this.shadowRoot, definition.key, this as IHydratedController);\n      this.mountTarget = targetShadowRoot;\n    } else if (location != null) {\n      setRef(location, elementBaseName, this as IHydratedController);\n      setRef(location, definition.key, this as IHydratedController);\n      this.mountTarget = targetLocation;\n    } else {\n      this.mountTarget = targetHost;\n    }\n\n    (this._vm as Writable<C>).$controller = this;\n    this.nodes = this._rendering.createNodes(compiledDef);\n\n    if (this._lifecycleHooks!.hydrated !== void 0) {\n      this._lifecycleHooks!.hydrated.forEach(callHydratedHook, this);\n    }\n\n    if (this._vmHooks._hydrated) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`invoking hydrated() hook`); }\n      this._vm!.hydrated(this as ICustomElementController);\n    }\n  }\n\n  /** @internal */\n  public _hydrateChildren(): void {\n    this._rendering.render(\n      /* controller */this as ICustomElementController,\n      /* targets    */this.nodes!.findTargets(),\n      /* definition */this._compiledDef!,\n      /* host       */this.host,\n    );\n\n    if (this._lifecycleHooks!.created !== void 0) {\n      this._lifecycleHooks!.created.forEach(callCreatedHook, this);\n    }\n    if (this._vmHooks._created) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`invoking created() hook`); }\n      this._vm!.created(this as ICustomElementController);\n    }\n  }\n\n  /** @internal */\n  private _hydrateCustomAttribute(): void {\n    const definition = this.definition as CustomAttributeDefinition;\n    const instance = this._vm!;\n\n    if (definition.watches.length > 0) {\n      createWatchers(this, this.container, definition, instance);\n    }\n    createObservers(this, definition, instance as unknown as IIndexable<ICustomAttributeViewModel>);\n\n    (instance as Writable<C>).$controller = this;\n    this._lifecycleHooks = LifecycleHooks.resolve(this.container);\n\n    if (this._lifecycleHooks!.created !== void 0) {\n      this._lifecycleHooks!.created.forEach(callCreatedHook, this);\n    }\n    if (this._vmHooks._created) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`invoking created() hook`); }\n      this._vm!.created(this as ICustomAttributeController);\n    }\n  }\n\n  /** @internal */\n  private _hydrateSynthetic(): void {\n    this._compiledDef = this._rendering.compile(this.viewFactory!.def, this.container);\n    this._rendering.render(\n      /* controller */this as ISyntheticView,\n      /* targets    */(this.nodes = this._rendering.createNodes(this._compiledDef)).findTargets(),\n      /* definition */this._compiledDef,\n      /* host       */void 0,\n    );\n  }\n\n  private $initiator: IHydratedController = null!;\n  public activate(\n    initiator: IHydratedController,\n    parent: IHydratedController | null,\n    scope?: Scope | null,\n  ): void | Promise<void> {\n    switch (this.state) {\n      case none:\n      case deactivated:\n        if (!(parent === null || parent.isActive)) {\n          // If this is not the root, and the parent is either:\n          // 1. Not activated, or activating children OR\n          // 2. Deactivating itself\n          // abort.\n          return;\n        }\n        // Otherwise, proceed normally.\n        // 'deactivated' and 'none' are treated the same because, from an activation perspective, they mean the same thing.\n        this.state = activating;\n        break;\n      case activated:\n        // If we're already activated, no need to do anything.\n        return;\n      case disposed:\n        throw createMappedError(ErrorNames.controller_activating_disposed, this.name);\n      default:\n        throw createMappedError(ErrorNames.controller_activation_unexpected_state, this.name, stringifyState(this.state));\n    }\n\n    this.parent = parent;\n    if (__DEV__ && this.debug && !this._fullyNamed) {\n      this._fullyNamed = true;\n      (this.logger ??= this.container.get(ILogger).root.scopeTo(this.name)).trace(`activate()`);\n    }\n\n    switch (this.vmKind) {\n      case vmkCe:\n        // Custom element scope is created and assigned during hydration\n        (this.scope as Writable<Scope>).parent = scope ?? null;\n        break;\n      case vmkCa:\n        this.scope = scope ?? null;\n        break;\n      case vmkSynth:\n        // maybe only check when there's not already a scope\n        if (scope === void 0 || scope === null) {\n          throw createMappedError(ErrorNames.controller_activation_synthetic_no_scope, this.name);\n        }\n\n        if (!this.hasLockedScope) {\n          this.scope = scope;\n        }\n        break;\n    }\n\n    this.$initiator = initiator;\n\n    // opposing leave is called in attach() (which will trigger attached())\n    this._enterActivating();\n\n    let ret: void | Promise<void> = void 0;\n    if (this.vmKind !== vmkSynth && this._lifecycleHooks!.binding != null) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`lifecycleHooks.binding()`); }\n\n      ret = onResolveAll(...this._lifecycleHooks!.binding!.map(callBindingHook, this));\n    }\n\n    if (this._vmHooks._binding) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`binding()`); }\n\n      ret = onResolveAll(ret, this._vm!.binding(this.$initiator, this.parent));\n    }\n\n    if (isPromise(ret)) {\n      this._ensurePromise();\n      ret.then(() => {\n        this._isBindingDone = true;\n        if (this.state !== activating) {\n          // because controller can be deactivated, during a long running promise in the binding phase\n          this._leaveActivating();\n        } else {\n          this.bind();\n        }\n      }).catch((err: Error) => {\n        this._reject(err);\n      });\n      return this.$promise;\n    }\n\n    this._isBindingDone = true;\n    this.bind();\n    return this.$promise;\n  }\n\n  private bind(): void {\n    /* istanbul ignore next */\n    if (__DEV__ && this.debug) { this.logger!.trace(`bind()`); }\n\n    let i = 0;\n    let ii = 0;\n    let ret: void | Promise<void> = void 0;\n\n    if (this.bindings !== null) {\n      i = 0;\n      ii = this.bindings.length;\n      while (ii > i) {\n        this.bindings[i].bind(this.scope!);\n        ++i;\n      }\n    }\n\n    if (this.vmKind !== vmkSynth && this._lifecycleHooks!.bound != null) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`lifecycleHooks.bound()`); }\n\n      ret = onResolveAll(...this._lifecycleHooks!.bound.map(callBoundHook, this));\n    }\n\n    if (this._vmHooks._bound) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`bound()`); }\n\n      ret = onResolveAll(ret, this._vm!.bound(this.$initiator, this.parent));\n    }\n\n    if (isPromise(ret)) {\n      this._ensurePromise();\n      ret.then(() => {\n        this.isBound = true;\n        // because controller can be deactivated, during a long running promise in the bound phase\n        if (this.state !== activating) {\n          this._leaveActivating();\n        } else {\n          this._attach();\n        }\n      }).catch((err: Error) => {\n        this._reject(err);\n      });\n      return;\n    }\n\n    this.isBound = true;\n    this._attach();\n  }\n\n  /** @internal */\n  private _append(...nodes: Node[]): void {\n    switch (this.mountTarget) {\n      case targetHost:\n        this.host!.append(...nodes);\n        break;\n      case targetShadowRoot:\n        this.shadowRoot!.append(...nodes);\n        break;\n      case targetLocation: {\n        let i = 0;\n        for (; i < nodes.length; ++i) {\n          this.location!.parentNode!.insertBefore(nodes[i], this.location);\n        }\n        break;\n      }\n    }\n  }\n\n  /** @internal */\n  private _attach(): void {\n    /* istanbul ignore next */\n    if (__DEV__ && this.debug) { this.logger!.trace(`attach()`); }\n\n    if (this.hostController !== null) {\n      switch (this.mountTarget) {\n        case targetHost:\n        case targetShadowRoot:\n          this.hostController._append(this.host!);\n          break;\n        case targetLocation:\n          this.hostController._append(this.location!.$start!, this.location!);\n          break;\n      }\n    }\n\n    switch (this.mountTarget) {\n      case targetHost:\n        this.nodes!.appendTo(this.host!, this.definition != null && (this.definition as CustomElementDefinition).enhance);\n        break;\n      case targetShadowRoot: {\n        const container = this.container;\n        const styles = container.has(IShadowDOMStyles, false)\n          ? container.get(IShadowDOMStyles)\n          : container.get(IShadowDOMGlobalStyles);\n        styles.applyTo(this.shadowRoot!);\n        this.nodes!.appendTo(this.shadowRoot!);\n        break;\n      }\n      case targetLocation:\n        this.nodes!.insertBefore(this.location!);\n        break;\n    }\n\n    let i = 0;\n    let ret: Promise<void> | void = void 0;\n\n    if (this.vmKind !== vmkSynth && this._lifecycleHooks!.attaching != null) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`lifecycleHooks.attaching()`); }\n\n      ret = onResolveAll(...this._lifecycleHooks!.attaching!.map(callAttachingHook, this));\n    }\n\n    if (this._vmHooks._attaching) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`attaching()`); }\n\n      ret = onResolveAll(ret, this._vm!.attaching(this.$initiator, this.parent));\n    }\n\n    if (isPromise(ret)) {\n      this._ensurePromise();\n      this._enterActivating();\n      ret.then(() => {\n        this._leaveActivating();\n      }).catch((err: Error) => {\n        this._reject(err);\n      });\n    }\n\n    // attaching() and child activation run in parallel, and attached() is called when both are finished\n    if (this.children !== null) {\n      for (; i < this.children.length; ++i) {\n        // Any promises returned from child activation are cumulatively awaited before this.$promise resolves\n        void this.children[i].activate(this.$initiator, this as IHydratedController, this.scope);\n      }\n    }\n\n    // attached() is invoked by Controller#leaveActivating when `activatingStack` reaches 0\n    this._leaveActivating();\n  }\n\n  public deactivate(\n    initiator: IHydratedController,\n    _parent: IHydratedController | null,\n  ): void | Promise<void> {\n    let prevActivation: void | Promise<void> = void 0;\n    switch ((this.state & ~released)) {\n      case activated:\n        this.state = deactivating;\n        break;\n      case activating:\n        this.state = deactivating;\n        // we are about to deactivate, the error from activation can be ignored\n        prevActivation = this.$promise?.catch(__DEV__\n          /* istanbul-ignore-next */\n          ? err => {\n            this.logger.warn('The activation error will be ignored, as the controller is already scheduled for deactivation. The activation was rejected with: %s', err);\n          }\n          : noop);\n        break;\n      case none:\n      case deactivated:\n      case disposed:\n      case deactivated | disposed:\n        // If we're already deactivated (or even disposed), or never activated in the first place, no need to do anything.\n        return;\n      default:\n        throw createMappedError(ErrorNames.controller_deactivation_unexpected_state, this.name, this.state);\n    }\n\n    /* istanbul-ignore-next */\n    if (__DEV__ && this.debug) { this.logger!.trace(`deactivate()`); }\n\n    this.$initiator = initiator;\n\n    if (initiator === this) {\n      this._enterDetaching();\n    }\n\n    let i = 0;\n    let ret: void | Promise<void>;\n\n    if (this.children !== null) {\n      for (i = 0; i < this.children.length; ++i) {\n        // Child promise results are tracked by enter/leave combo's\n        void this.children[i].deactivate(initiator, this as IHydratedController);\n      }\n    }\n\n    return onResolve(prevActivation, () => {\n      if (this.isBound) {\n        if (this.vmKind !== vmkSynth && this._lifecycleHooks!.detaching != null) {\n          if (__DEV__ && this.debug) { this.logger!.trace(`lifecycleHooks.detaching()`); }\n\n          ret = onResolveAll(...this._lifecycleHooks!.detaching.map(callDetachingHook, this));\n        }\n\n        if (this._vmHooks._detaching) {\n          if (__DEV__ && this.debug) { this.logger!.trace(`detaching()`); }\n\n          ret = onResolveAll(ret, this._vm!.detaching(this.$initiator, this.parent));\n        }\n      }\n\n      if (isPromise(ret)) {\n        this._ensurePromise();\n        (initiator as Controller)._enterDetaching();\n        ret.then(() => {\n          (initiator as Controller)._leaveDetaching();\n        }).catch((err: Error) => {\n          (initiator as Controller)._reject(err);\n        });\n      }\n\n      // Note: if a 3rd party plugin happens to do any async stuff in a template controller before calling deactivate on its view,\n      // then the linking will become out of order.\n      // For framework components, this shouldn't cause issues.\n      // We can only prevent that by linking up after awaiting the detaching promise, which would add an extra tick + a fair bit of\n      // overhead on this hot path, so it's (for now) a deliberate choice to not account for such situation.\n      // Just leaving the note here so that we know to look here if a weird detaching-related timing issue is ever reported.\n      if (initiator.head === null) {\n        initiator.head = this as IHydratedController;\n      } else {\n        initiator.tail!.next = this as IHydratedController;\n      }\n      initiator.tail = this as IHydratedController;\n\n      if (initiator !== this) {\n        // Only detaching is called + the linked list is built when any controller that is not the initiator, is deactivated.\n        // The rest is handled by the initiator.\n        // This means that descendant controllers have to make sure to await the initiator's promise before doing any subsequent\n        // controller api calls, or race conditions might occur.\n        return;\n      }\n\n      this._leaveDetaching();\n      return this.$promise;\n    });\n  }\n\n  private removeNodes(): void {\n    switch (this.vmKind) {\n      case vmkCe:\n      case vmkSynth:\n        this.nodes!.remove();\n        this.nodes!.unlink();\n    }\n\n    if (this.hostController !== null) {\n      switch (this.mountTarget) {\n        case targetHost:\n        case targetShadowRoot:\n          this.host!.remove();\n          break;\n        case targetLocation:\n          this.location!.$start!.remove();\n          this.location!.remove();\n          break;\n      }\n    }\n  }\n\n  private unbind(): void {\n    /* istanbul ignore next */\n    if (__DEV__ && this.debug) { this.logger!.trace(`unbind()`); }\n\n    let i = 0;\n\n    if (this.bindings !== null) {\n      for (; i < this.bindings.length; ++i) {\n        this.bindings[i].unbind();\n      }\n    }\n\n    this.parent = null;\n\n    switch (this.vmKind) {\n      case vmkCa:\n        this.scope = null;\n        break;\n      case vmkSynth:\n        if (!this.hasLockedScope) {\n          this.scope = null;\n        }\n\n        if (\n          (this.state & released) === released &&\n          !this.viewFactory!.tryReturnToCache(this as ISyntheticView) &&\n          this.$initiator === this\n        ) {\n          this.dispose();\n        }\n        break;\n      case vmkCe:\n        (this.scope as Writable<Scope>).parent = null;\n        break;\n    }\n\n    this.state = deactivated;\n    this.$initiator = null!;\n    this._resolve();\n  }\n\n  private $resolve: (() => void) | undefined = void 0;\n  private $reject: ((err: unknown) => void) | undefined = void 0;\n  private $promise: Promise<void> | undefined = void 0;\n\n  /** @internal */\n  private _ensurePromise(): void {\n    if (this.$promise === void 0) {\n      this.$promise = new Promise((resolve, reject) => {\n        this.$resolve = resolve;\n        this.$reject = reject;\n      });\n      if (this.$initiator !== this) {\n        (this.parent as Controller)._ensurePromise();\n      }\n    }\n  }\n\n  /** @internal */\n  private _resolve(): void {\n    if (this.$promise !== void 0) {\n      _resolve = this.$resolve!;\n      this.$resolve = this.$reject = this.$promise = void 0;\n      _resolve();\n      _resolve = void 0;\n    }\n  }\n\n  /** @internal */\n  private _reject(err: Error): void {\n    if (this.$promise !== void 0) {\n      _reject = this.$reject!;\n      this.$resolve = this.$reject = this.$promise = void 0;\n      _reject(err);\n      _reject = void 0;\n    }\n    if (this.$initiator !== this) {\n      (this.parent as Controller)._reject(err);\n    }\n  }\n\n  /** @internal */\n  private _activatingStack: number = 0;\n  /** @internal */\n  private _enterActivating(): void {\n    ++this._activatingStack;\n    if (this.$initiator !== this) {\n      (this.parent as Controller)._enterActivating();\n    }\n  }\n  /** @internal */\n  private _leaveActivating(): void {\n    if (this.state !== activating) {\n      --this._activatingStack;\n      // skip doing rest of the work if the controller is deactivated.\n      this._resolve();\n      if (this.$initiator !== this) {\n        (this.parent as Controller)._leaveActivating();\n      }\n      return;\n    }\n    if (--this._activatingStack === 0) {\n      if (this.vmKind !== vmkSynth && this._lifecycleHooks!.attached != null) {\n        _retPromise = onResolveAll(...this._lifecycleHooks!.attached.map(callAttachedHook, this));\n      }\n\n      if (this._vmHooks._attached) {\n        /* istanbul ignore next */\n        if (__DEV__ && this.debug) { this.logger!.trace(`attached()`); }\n\n        _retPromise = onResolveAll(_retPromise, this._vm!.attached!(this.$initiator));\n      }\n\n      if (isPromise(_retPromise)) {\n        this._ensurePromise();\n        _retPromise.then(() => {\n          this.state = activated;\n          // Resolve this.$promise, signaling that activation is done (path 1 of 2)\n          this._resolve();\n          if (this.$initiator !== this) {\n            (this.parent as Controller)._leaveActivating();\n          }\n        }).catch((err: Error) => {\n          this._reject(err);\n        });\n        _retPromise = void 0;\n        return;\n      }\n      _retPromise = void 0;\n\n      this.state = activated;\n      // Resolve this.$promise (if present), signaling that activation is done (path 2 of 2)\n      this._resolve();\n    }\n    if (this.$initiator !== this) {\n      (this.parent as Controller)._leaveActivating();\n    }\n  }\n\n  /** @internal */\n  private _detachingStack: number = 0;\n  /** @internal */\n  private _enterDetaching(): void {\n    ++this._detachingStack;\n  }\n  /** @internal */\n  private _leaveDetaching(): void {\n    if (--this._detachingStack === 0) {\n      // Note: this controller is the initiator (detach is only ever called on the initiator)\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`detach()`); }\n\n      this._enterUnbinding();\n      this.removeNodes();\n\n      let cur = this.$initiator.head as Controller | null;\n      let ret: void | Promise<void> = void 0;\n\n      while (cur !== null) {\n        if (cur !== this) {\n          /* istanbul ignore next */\n          if (cur.debug) { cur.logger!.trace(`detach()`); }\n\n          cur.removeNodes();\n        }\n\n        if (cur._isBindingDone) {\n          if (cur.vmKind !== vmkSynth && cur._lifecycleHooks!.unbinding != null) {\n            ret = onResolveAll(...cur._lifecycleHooks!.unbinding.map(callUnbindingHook, cur));\n          }\n\n          if (cur._vmHooks._unbinding) {\n            if (cur.debug) { cur.logger!.trace('unbinding()'); }\n\n            ret = onResolveAll(ret, cur.viewModel!.unbinding(cur.$initiator, cur.parent));\n          }\n        }\n\n        if (isPromise(ret)) {\n          this._ensurePromise();\n          this._enterUnbinding();\n          ret.then(() => {\n            this._leaveUnbinding();\n          }).catch((err: Error) => {\n            this._reject(err);\n          });\n        }\n\n        ret = void 0;\n\n        cur = cur.next as Controller;\n      }\n\n      this._leaveUnbinding();\n    }\n  }\n\n  /** @internal */\n  private _unbindingStack: number = 0;\n  /** @internal */\n  private _enterUnbinding(): void {\n    ++this._unbindingStack;\n  }\n  /** @internal */\n  private _leaveUnbinding(): void {\n    if (--this._unbindingStack === 0) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`unbind()`); }\n\n      let cur = this.$initiator.head as Controller | null;\n      let next: Controller | null = null;\n      while (cur !== null) {\n        if (cur !== this) {\n          cur._isBindingDone = false;\n          cur.isBound = false;\n          cur.unbind();\n        }\n        next = cur.next as Controller;\n        cur.next = null;\n        cur = next;\n      }\n\n      this.head = this.tail = null;\n      this._isBindingDone = false;\n      this.isBound = false;\n      this.unbind();\n    }\n  }\n\n  public addBinding(binding: IBinding): void {\n    if (this.bindings === null) {\n      this.bindings = [binding];\n    } else {\n      this.bindings[this.bindings.length] = binding;\n    }\n  }\n\n  public addChild(controller: Controller): void {\n    if (this.children === null) {\n      this.children = [controller];\n    } else {\n      this.children[this.children.length] = controller;\n    }\n  }\n\n  public is(name: string): boolean {\n    switch (this.vmKind) {\n      case vmkCa:\n      case vmkCe: {\n        return (this.definition as ResourceDefinition).name === name;\n      }\n      case vmkSynth:\n        return this.viewFactory!.name === name;\n    }\n  }\n\n  public lockScope(scope: Writable<Scope>): void {\n    this.scope = scope;\n    this.hasLockedScope = true;\n  }\n\n  public setHost(host: HTMLElement): this {\n    if (this.vmKind === vmkCe) {\n      setRef(host, elementBaseName, this as IHydratedController);\n      setRef(host, this.definition!.key, this as IHydratedController);\n    }\n    this.host = host;\n    this.mountTarget = targetHost;\n    return this;\n  }\n\n  public setShadowRoot(shadowRoot: ShadowRoot): this {\n    if (this.vmKind === vmkCe) {\n      setRef(shadowRoot, elementBaseName, this as IHydratedController);\n      setRef(shadowRoot, this.definition!.key, this as IHydratedController);\n    }\n    this.shadowRoot = shadowRoot;\n    this.mountTarget = targetShadowRoot;\n    return this;\n  }\n\n  public setLocation(location: IRenderLocation): this {\n    if (this.vmKind === vmkCe) {\n      setRef(location, elementBaseName, this as IHydratedController);\n      setRef(location, this.definition!.key, this as IHydratedController);\n    }\n    this.location = location;\n    this.mountTarget = targetLocation;\n    return this;\n  }\n\n  public release(): void {\n    this.state |= released;\n  }\n\n  public dispose(): void {\n    /* istanbul ignore next */\n    if (__DEV__ && this.debug) { this.logger!.trace(`dispose()`); }\n\n    if ((this.state & disposed) === disposed) {\n      return;\n    }\n    this.state |= disposed;\n\n    if (this._vmHooks._dispose) {\n      this._vm!.dispose();\n    }\n\n    if (this.children !== null) {\n      this.children.forEach(callDispose);\n      this.children = null;\n    }\n\n    this.hostController = null;\n    this.scope = null;\n\n    this.nodes = null;\n    this.location = null;\n\n    this.viewFactory = null;\n    if (this._vm !== null) {\n      controllerLookup.delete(this._vm);\n      this._vm = null;\n    }\n    this._vm = null;\n    this.host = null;\n    this.shadowRoot = null;\n    this.container.disposeResolvers();\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    if (visitor(this as IHydratedController) === true) {\n      return true;\n    }\n\n    if (this._vmHooks._accept && this._vm!.accept(visitor) === true) {\n      return true;\n    }\n\n    if (this.children !== null) {\n      const { children } = this;\n      for (let i = 0, ii = children.length; i < ii; ++i) {\n        if (children[i].accept(visitor) === true) {\n          return true;\n        }\n      }\n    }\n  }\n}\n\nconst controllerLookup: WeakMap<object, Controller> = new WeakMap();\n\nexport type ControllerBindingContext<C extends IViewModel> = Required<ICompileHooks> & Required<IActivationHooks<IHydratedController | null>> & C;\n\nconst targetNone = 0;\nconst targetHost = 1;\nconst targetShadowRoot = 2;\nconst targetLocation = 3;\n\n/**\n * Describes the type of the host node/location of a controller\n * - `none` / 1:       no host\n * - `host` / 2:       an HTML element is the host of a controller\n * - `shadowRoot` / 3: a shadow root is the host of a controller\n * - `location` / 4:   a render location is the location of a controller, this is often used for template controllers\n */\nexport const MountTarget = objectFreeze({\n  none: targetNone,\n  host: targetHost,\n  shadowRoot: targetShadowRoot,\n  location: targetLocation,\n});\nexport type MountTarget = typeof MountTarget[keyof typeof MountTarget];\n\nconst optionalCeFind = { optional: true } as const;\nconst optionalCoercionConfigResolver = optionalResource(ICoercionConfiguration);\n\nfunction createObservers(\n  controller: Controller,\n  definition: CustomElementDefinition | CustomAttributeDefinition,\n  instance: IIndexable<ICustomElementViewModel | ICustomAttributeViewModel>,\n): void {\n  const bindables = definition.bindables;\n  const observableNames = getOwnPropertyNames(bindables);\n  const length = observableNames.length;\n  const locator = controller.container.get(IObserverLocator);\n  const hasAggregatedCallbacks = 'propertiesChanged' in instance;\n\n  if (length === 0) return;\n\n  const queueCallback = hasAggregatedCallbacks\n    ? (() => {\n        let changes: Record<string, { newValue: unknown; oldValue: unknown }> = {};\n        let promise: Promise<void> | void = void 0;\n        let changeCount = 0;\n        const resolvedPromise = Promise.resolve();\n        const callPropertiesChanged = () => {\n          if (promise == null) {\n            promise = resolvedPromise.then(() => {\n              const $changes = changes;\n              changes = {};\n              changeCount = 0;\n              promise = void 0;\n              if (controller.isBound) {\n                instance.propertiesChanged?.($changes);\n                if (changeCount > 0) {\n                  callPropertiesChanged();\n                }\n              }\n            });\n          }\n        };\n\n        return (key: string, newValue: unknown, oldValue: unknown) => {\n          changes[key] = { newValue, oldValue };\n          changeCount++;\n          callPropertiesChanged();\n        };\n    })()\n    : noop;\n\n  for (let i = 0; i < length; ++i) {\n    const name = observableNames[i];\n    const bindable = bindables[name];\n    const handler = bindable.callback;\n    const obs = locator.getObserver(instance, name);\n\n    if (bindable.set !== noop) {\n      if (obs.useCoercer?.(bindable.set, controller.coercion) !== true) {\n        throw createMappedError(ErrorNames.controller_property_not_coercible, name);\n      }\n    }\n    if (instance[handler] != null\n      || instance.propertyChanged != null\n      || hasAggregatedCallbacks\n    ) {\n      const callback = (newValue: unknown, oldValue: unknown) => {\n        if (controller.isBound) {\n          (instance[handler] as AnyFunction)?.(newValue, oldValue);\n          instance.propertyChanged?.(name, newValue, oldValue);\n          queueCallback(name, newValue, oldValue);\n        }\n      };\n      if (obs.useCallback?.(callback) !== true) {\n        throw createMappedError(ErrorNames.controller_property_no_change_handler, name);\n      }\n    }\n  }\n}\n\nconst AccessScopeAstMap = new Map<PropertyKey, AccessScopeExpression>();\nconst getAccessScopeAst = (key: PropertyKey) => {\n  let ast = AccessScopeAstMap.get(key);\n  if (ast == null) {\n    ast = new AccessScopeExpression(key as string, 0);\n    AccessScopeAstMap.set(key, ast);\n  }\n  return ast;\n};\n\nfunction createWatchers(\n  controller: Controller,\n  context: IServiceLocator,\n  definition: CustomElementDefinition | CustomAttributeDefinition,\n  instance: object,\n) {\n  const observerLocator = context!.get(IObserverLocator);\n  const expressionParser = context.get(IExpressionParser);\n  const watches = definition.watches;\n  const scope: Scope = controller.vmKind === vmkCe\n    ? controller.scope!\n    // custom attribute does not have own scope\n    : Scope.create(instance, null, true);\n  const ii = watches.length;\n  let expression: IWatchDefinition['expression'];\n  let callback: IWatchDefinition['callback'];\n  let ast: IsBindingBehavior;\n  let i = 0;\n\n  for (; ii > i; ++i) {\n    ({ expression, callback } = watches[i]);\n    callback = isFunction(callback)\n      ? callback\n      : Reflect.get(instance, callback) as IWatcherCallback<object>;\n    if (!isFunction(callback)) {\n      throw createMappedError(ErrorNames.controller_watch_invalid_callback, callback);\n    }\n    if (isFunction(expression)) {\n      controller.addBinding(new ComputedWatcher(\n        instance as IObservable,\n        observerLocator,\n        expression,\n        callback,\n        true,\n      ));\n    } else {\n      ast = isString(expression)\n        ? expressionParser.parse(expression, etIsProperty)\n        : getAccessScopeAst(expression);\n\n      controller.addBinding(new ExpressionWatcher(\n        scope,\n        context,\n        observerLocator,\n        ast,\n        callback\n      ) as unknown as IBinding);\n    }\n  }\n}\n\nexport function isCustomElementController<C extends ICustomElementViewModel = ICustomElementViewModel>(value: unknown): value is ICustomElementController<C> {\n  return value instanceof Controller && value.vmKind === vmkCe;\n}\n\nexport function isCustomElementViewModel(value: unknown): value is ICustomElementViewModel {\n  return isElementType(value?.constructor);\n}\n\nclass HooksDefinition {\n  public static readonly none: Readonly<HooksDefinition> = new HooksDefinition({});\n\n  public readonly _define: boolean;\n\n  public readonly _hydrating: boolean;\n  public readonly _hydrated: boolean;\n  public readonly _created: boolean;\n\n  public readonly _binding: boolean;\n  public readonly _bound: boolean;\n  public readonly _attaching: boolean;\n  public readonly _attached: boolean;\n\n  public readonly _detaching: boolean;\n  public readonly _unbinding: boolean;\n\n  public readonly _dispose: boolean;\n  public readonly _accept: boolean;\n\n  public constructor(target: object) {\n    this._define = 'define' in target;\n\n    this._hydrating = 'hydrating' in target;\n    this._hydrated = 'hydrated' in target;\n    this._created = 'created' in target;\n\n    this._binding = 'binding' in target;\n    this._bound = 'bound' in target;\n    this._attaching = 'attaching' in target;\n    this._attached = 'attached' in target;\n\n    this._detaching = 'detaching' in target;\n    this._unbinding = 'unbinding' in target;\n\n    this._dispose = 'dispose' in target;\n    this._accept = 'accept' in target;\n  }\n}\n\nconst defaultShadowOptions = {\n  mode: 'open' as 'open' | 'closed'\n};\n\n/** @internal */ export const vmkCe = 'customElement' as const;\n/** @internal */ export const vmkCa = 'customAttribute' as const;\nconst vmkSynth = 'synthetic' as const;\nexport type ViewModelKind = typeof vmkCe | typeof vmkCa | typeof vmkSynth;\n\n/**\n * A controller that is ready for activation. It can be `ISyntheticView`, `ICustomElementController` or `ICustomAttributeController`.\n *\n * In terms of specificity this is identical to `IController`. The only difference is that this\n * type is further initialized and thus has more properties and APIs available.\n */\nexport type IHydratedController = ISyntheticView | ICustomElementController | ICustomAttributeController;\n/**\n * A controller that is ready for activation. It can be `ICustomElementController` or `ICustomAttributeController`.\n *\n * This type of controller is backed by a real component (hence the name) and therefore has ViewModel and may have lifecycle hooks.\n *\n * In contrast, `ISyntheticView` has neither a view model nor lifecycle hooks (but its child controllers, if any, may).\n */\nexport type IHydratedComponentController = ICustomElementController | ICustomAttributeController;\n/**\n * A controller that is ready for activation. It can be `ISyntheticView` or `ICustomElementController`.\n *\n * This type of controller may have child controllers (hence the name) and bindings directly placed on it during hydration.\n *\n * In contrast, `ICustomAttributeController` has neither child controllers nor bindings directly placed on it (but the backing component may).\n *\n * Note: the parent of a `ISyntheticView` is always a `IHydratedComponentController` because views cannot directly own other views. Views may own components, and components may own views or components.\n */\nexport type IHydratedParentController = ISyntheticView | ICustomElementController;\n\n/**\n * A callback that is invoked on each controller in the component tree.\n *\n * Return `true` to stop traversal.\n */\nexport type ControllerVisitor = (controller: IHydratedController) => void | true;\n\n/**\n * The base type for all controller types.\n *\n * Every controller, regardless of their type and state, will have at least the properties/methods in this interface.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface IController<C extends IViewModel = IViewModel> extends IDisposable {\n  /**\n   * The container associated with this controller.\n   * By default, CE should have their own container while custom attribute & synthetic view\n   * will use the parent container one, since they do not need to manage one\n   */\n  readonly name: string;\n  readonly container: IContainer;\n  readonly vmKind: ViewModelKind;\n  readonly definition: CustomElementDefinition | CustomAttributeDefinition | null;\n  readonly host: HTMLElement | null;\n  readonly state: State;\n  readonly isActive: boolean;\n  readonly parent: IHydratedController | null;\n  readonly isBound: boolean;\n  readonly bindings: readonly IBinding[] | null;\n\n  addBinding(binding: IBinding): void;\n\n  /** @internal */head: IHydratedController | null;\n  /** @internal */tail: IHydratedController | null;\n  /** @internal */next: IHydratedController | null;\n\n  /**\n   * Return `true` to stop traversal.\n   */\n  accept(visitor: ControllerVisitor): void | true;\n}\n\n/**\n * The base type for `ICustomAttributeController` and `ICustomElementController`.\n *\n * Both of those types have the `viewModel` property which represent the user instance containing the bound properties and hooks for this component.\n */\nexport interface IComponentController<C extends IViewModel = IViewModel> extends IController<C> {\n  readonly vmKind: 'customAttribute' | 'customElement';\n  readonly definition: CustomElementDefinition | CustomAttributeDefinition;\n\n  /**\n   * The user instance containing the bound properties. This is always an instance of a class, which may either be user-defined, or generated by a view locator.\n   */\n  readonly viewModel: C;\n\n  /**\n   * Coercion configuration associated with a component (attribute/element) or an application\n   */\n  readonly coercion: ICoercionConfiguration | undefined;\n}\n\n/**\n * The base type for `ISyntheticView` and `ICustomElementController`.\n *\n * Both of those types can:\n * - Have `children` which are populated during hydration (hence, 'Hydratable').\n * - Have physical DOM nodes that can be mounted.\n */\nexport interface IHydratableController<C extends IViewModel = IViewModel> extends IController<C> {\n  readonly vmKind: 'customElement' | 'synthetic';\n  readonly mountTarget: MountTarget;\n  readonly definition: CustomElementDefinition | null;\n  readonly strict: boolean | undefined | null;\n\n  readonly children: readonly IHydratedController[] | null;\n\n  addChild(controller: IController): void;\n}\n\n/** @internal */ export const none         = 0b00_00_00;\n/** @internal */ export const activating   = 0b00_00_01;\n/** @internal */ export const activated    = 0b00_00_10;\n/** @internal */ export const deactivating = 0b00_01_00;\n/** @internal */ export const deactivated  = 0b00_10_00;\n/** @internal */ export const released     = 0b01_00_00;\n/** @internal */ export const disposed     = 0b10_00_00;\n\nexport const State = /*@__PURE__*/ objectFreeze({\n  none,\n  activating,\n  activated,\n  deactivating,\n  deactivated,\n  released,\n  disposed,\n});\nexport type State = typeof State[keyof typeof State];\n\nexport function stringifyState(state: State): string {\n  const names: string[] = [];\n\n  if ((state & activating) === activating) { names.push('activating'); }\n  if ((state & activated) === activated) { names.push('activated'); }\n  if ((state & deactivating) === deactivating) { names.push('deactivating'); }\n  if ((state & deactivated) === deactivated) { names.push('deactivated'); }\n  if ((state & released) === released) { names.push('released'); }\n  if ((state & disposed) === disposed) { names.push('disposed'); }\n\n  return names.length === 0 ? 'none' : names.join('|');\n}\n\n/**\n * The controller for a synthetic view, that is, a controller created by an `IViewFactory`.\n *\n * A synthetic view, typically created when composing a template controller (`if`, `repeat`, etc), is a hydratable component with mountable DOM nodes that has no user view model.\n *\n * It has either its own synthetic binding context or is locked to some externally sourced scope (in the case of `au-compose`)\n */\nexport interface ISyntheticView extends IHydratableController {\n  readonly vmKind: 'synthetic';\n  readonly definition: null;\n  readonly viewModel: null;\n  /**\n   * The physical DOM nodes that will be appended during the attach operation.\n   */\n  readonly nodes: INodeSequence;\n\n  activate(\n    initiator: IHydratedController,\n    parent: IHydratedController,\n    scope: Scope,\n  ): void | Promise<void>;\n  deactivate(\n    initiator: IHydratedController,\n    parent: IHydratedController,\n  ): void | Promise<void>;\n  /**\n   * Lock this view's scope to the provided `Scope`. The scope, which is normally set during `activate()`, will then not change anymore.\n   *\n   * This is used by `au-render` to set the binding context of a view to a particular component instance.\n   *\n   * @param scope - The scope to lock this view to.\n   */\n  lockScope(scope: Scope): void;\n  /**\n   * The scope that belongs to this view. This property will always be defined when the `state` property of this view indicates that the view is currently bound.\n   *\n   * The `scope` may be set during `activate()` and unset during `deactivate()`, or it may be statically set during composing with `lockScope()`.\n   */\n  readonly scope: Scope;\n\n  /**\n   * Set the render location that this view will be inserted before.\n   */\n  setLocation(location: IRenderLocation): this;\n  /**\n   * The DOM node that this view will be inserted before (if set).\n   */\n  readonly location: IRenderLocation | null;\n\n  /**\n   * Set the host that this view will be appended to.\n   */\n  setHost(host: Node & ParentNode): this;\n  /**\n   * The DOM node that this view will be appended to (if set).\n   */\n  readonly host: HTMLElement | null;\n\n  /**\n   * Set the `ShadowRoot` that this view will be appended to.\n   */\n  setShadowRoot(shadowRoot: ShadowRoot): this;\n  /**\n   * The ShadowRoot that this view will be appended to (if set).\n   */\n  readonly shadowRoot: ShadowRoot | null;\n\n  /**\n   * Mark this view as not-in-use, so that it can either be disposed or returned to cache after finishing the deactivate lifecycle.\n   *\n   * If this view is cached and later retrieved from the cache, it will be marked as in-use again before starting the activate lifecycle, so this method must be called each time.\n   *\n   * If this method is *not* called before `deactivate()`, this view will neither be cached nor disposed.\n   */\n  release(): void;\n}\n\nexport interface ICustomAttributeController<C extends ICustomAttributeViewModel = ICustomAttributeViewModel> extends IComponentController<C> {\n  readonly vmKind: 'customAttribute';\n  readonly definition: CustomAttributeDefinition;\n  /**\n   * @inheritdoc\n   */\n  readonly viewModel: C;\n  readonly lifecycleHooks: LifecycleHooksLookup;\n  /**\n   * The scope that belongs to this custom attribute. This property will always be defined when the `state` property of this view indicates that the view is currently bound.\n   *\n   * The `scope` will be set during `activate()` and unset during `deactivate()`.\n   *\n   * The scope's `bindingContext` will be the same instance as this controller's `viewModel` property.\n   */\n  readonly scope: Scope;\n  readonly children: null;\n  readonly bindings: null;\n  activate(\n    initiator: IHydratedController,\n    parent: IHydratedController,\n    scope: Scope,\n  ): void | Promise<void>;\n  deactivate(\n    initiator: IHydratedController,\n    parent: IHydratedController,\n  ): void | Promise<void>;\n}\n\n/**\n * A representation of `IController` specific to a custom element whose `create` hook is about to be invoked (if present).\n *\n * It is not yet hydrated (hence 'dry') with any render-specific information.\n */\nexport interface IDryCustomElementController<C extends IViewModel = IViewModel> extends IComponentController<C>, IHydratableController<C> {\n  readonly vmKind: 'customElement';\n  readonly definition: CustomElementDefinition;\n  readonly strict: boolean | undefined | null;\n  /**\n   * The scope that belongs to this custom element. This property is set immediately after the controller is created and is always guaranteed to be available.\n   *\n   * It may be overwritten by end user during the `create()` hook.\n   *\n   * By default, the scope's `bindingContext` will be the same instance as this controller's `viewModel` property.\n   */\n  scope: Scope;\n  /**\n   * The original host dom node.\n   *\n   * For containerless elements, this node will be removed from the DOM and replaced by a comment, which is assigned to the `location` property.\n   *\n   * For ShadowDOM elements, this will be the original declaring element, NOT the shadow root (the shadow root is stored on the `shadowRoot` property)\n   */\n  readonly host: HTMLElement;\n}\n\n/**\n * A representation of `IController` specific to a custom element whose `hydrating` hook is about to be invoked (if present).\n *\n * It has the same properties as `IDryCustomElementController`, as well as a render context (hence 'contextual').\n */\nexport interface IContextualCustomElementController<C extends IViewModel = IViewModel> extends IDryCustomElementController<C> {\n\n}\n\n/**\n * A representation of `IController` specific to a custom element whose `hydrated` hook is about to be invoked (if present).\n *\n * It has the same properties as `IContextualCustomElementController`, except the context is now compiled (hence 'compiled'), as well as the nodes, and projector.\n */\nexport interface ICompiledCustomElementController<C extends IViewModel = IViewModel> extends IContextualCustomElementController<C> {\n  /**\n   * The ShadowRoot, if this custom element uses ShadowDOM.\n   */\n  readonly shadowRoot: ShadowRoot | null;\n  /**\n   * The renderLocation, if this is a `containerless` custom element.\n   */\n  readonly location: IRenderLocation | null;\n  /**\n   * The physical DOM nodes that will be appended during the `mount()` operation.\n   */\n  readonly nodes: INodeSequence;\n}\n\n/**\n * A fully hydrated custom element controller.\n */\nexport interface ICustomElementController<C extends ICustomElementViewModel = ICustomElementViewModel> extends ICompiledCustomElementController<C> {\n  /**\n   * @inheritdoc\n   */\n  readonly viewModel: C;\n  readonly lifecycleHooks: LifecycleHooksLookup;\n\n  activate(\n    initiator: IHydratedController,\n    parent: IHydratedController | null,\n    scope?: Scope,\n  ): void | Promise<void>;\n  deactivate(\n    initiator: IHydratedController,\n    parent: IHydratedController | null,\n  ): void | Promise<void>;\n}\n\nexport const IController = /*@__PURE__*/createInterface<IController>('IController');\n\nexport const IHydrationContext = /*@__PURE__*/createInterface<IHydrationContext>('IHydrationContext');\nexport interface IHydrationContext<T extends ICustomElementViewModel = ICustomElementViewModel> {\n  readonly controller: ICustomElementController<T>;\n  readonly instruction: IControllerElementHydrationInstruction | null;\n  readonly parent: IHydrationContext | undefined;\n}\n\n/** @internal */\nexport class HydrationContext<T extends ICustomElementViewModel> implements IHydrationContext<T> {\n  public readonly controller: ICustomElementController<T>;\n  public constructor(\n    controller: ICustomElementController,\n    public readonly instruction: IControllerElementHydrationInstruction | null,\n    public readonly parent: IHydrationContext | undefined,\n  ) {\n    this.controller = controller as ICustomElementController<T>;\n  }\n}\n\nexport interface IActivationHooks<TParent> {\n  binding?(\n    initiator: IHydratedController,\n    parent: TParent,\n  ): void | Promise<void>;\n  bound?(\n    initiator: IHydratedController,\n    parent: TParent,\n  ): void | Promise<void>;\n  attaching?(\n    initiator: IHydratedController,\n    parent: TParent,\n  ): void | Promise<void>;\n  attached?(\n    initiator: IHydratedController,\n  ): void | Promise<void>;\n\n  detaching?(\n    initiator: IHydratedController,\n    parent: TParent,\n  ): void | Promise<void>;\n  unbinding?(\n    initiator: IHydratedController,\n    parent: TParent,\n  ): void | Promise<void>;\n\n  dispose?(): void;\n  /**\n   * If this component controls the instantiation and lifecycles of one or more controllers,\n   * implement this hook to enable component tree traversal for plugins that use it (such as the router).\n   *\n   * Return `true` to stop traversal.\n   */\n  accept?(visitor: ControllerVisitor): void | true;\n}\n\nexport interface ICompileHooks {\n  define?(\n    controller: IDryCustomElementController<this>,\n    /**\n     * The context where this element is hydrated.\n     *\n     * This is created by the controller associated with the CE creating this this controller\n     */\n    hydrationContext: IHydrationContext | null,\n    definition: CustomElementDefinition,\n  ): PartialCustomElementDefinition | void;\n  hydrating?(\n    controller: IContextualCustomElementController<this>,\n  ): void;\n  hydrated?(\n    controller: ICompiledCustomElementController<this>,\n  ): void;\n  created?(\n    controller: ICustomElementController<this> | ICustomAttributeController<this>,\n  ): void;\n}\n\n/**\n * Defines optional lifecycle hooks that will be called only when they are implemented.\n */\nexport interface IViewModel {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  constructor: Function;\n  readonly $controller?: IController<this>;\n}\n\nexport interface ICustomElementViewModel extends IViewModel, IActivationHooks<IHydratedController | null>, ICompileHooks {\n  readonly $controller?: ICustomElementController<this>;\n  created?(\n    controller: ICustomElementController<this>,\n  ): void;\n  propertyChanged?(key: PropertyKey, newValue: unknown, oldValue: unknown): void;\n  propertiesChanged?(changes: Record<string, { newValue: unknown; oldValue: unknown }>): void;\n}\n\nexport interface ICustomAttributeViewModel extends IViewModel, IActivationHooks<IHydratedController> {\n  readonly $controller?: ICustomAttributeController<this>;\n  link?(\n    controller: IHydratableController,\n    childController: ICustomAttributeController,\n    target: INode,\n    instruction: IInstruction,\n  ): void;\n  created?(\n    controller: ICustomAttributeController<this>,\n  ): void;\n  propertyChanged?(key: PropertyKey, newValue: unknown, oldValue: unknown): void;\n  propertiesChanged?(changes: Record<string, { newValue: unknown; oldValue: unknown }>): void;\n}\n\nexport interface IHydratedCustomElementViewModel extends ICustomElementViewModel {\n  readonly $controller: ICustomElementController<this>;\n}\n\nexport interface IHydratedCustomAttributeViewModel extends ICustomAttributeViewModel {\n  readonly $controller: ICustomAttributeController<this>;\n}\n\nexport interface IControllerElementHydrationInstruction {\n  /**\n   * An internal mechanism to manually halt + resume hydration process\n   *\n   * - 0: no hydration\n   * - 1: hydrate until define() lifecycle\n   *\n   * @internal\n   */\n  readonly hydrate?: boolean;\n  readonly projections: Record<string, PartialCustomElementDefinition> | null;\n  /**\n   * A list of captured attributes/binding in raw format\n   */\n  readonly captures?: AttrSyntax[];\n  /**\n   * Indicates whether the custom element was used with \"containerless\" attribute\n   */\n  readonly containerless?: boolean;\n  /**\n   * When provided, the controller is used while hydrating the custom element.\n   * Otherwise, the host controller is resolved in the Controller; this is the default behavior.\n   */\n  readonly hostController?: Controller | null;\n}\n\nfunction callDispose(disposable: IDisposable): void {\n  disposable.dispose();\n}\n\nfunction callCreatedHook(this: Controller, l: LifecycleHooksEntry<ICompileHooks, 'created'>) {\n  l.instance.created(this._vm!, this as IHydratedComponentController);\n}\n\nfunction callHydratingHook(this: Controller, l: LifecycleHooksEntry<ICompileHooks, 'hydrating'>) {\n  l.instance.hydrating(this._vm!, this as IContextualCustomElementController<ICompileHooks>);\n}\n\nfunction callHydratedHook(this: Controller, l: LifecycleHooksEntry<ICompileHooks, 'hydrated'>) {\n  l.instance.hydrated(this._vm!, this as ICompiledCustomElementController<ICompileHooks>);\n}\n\nfunction callBindingHook(this: Controller, l: LifecycleHooksEntry<IActivationHooks<IHydratedController>, 'binding'>) {\n  return l.instance.binding(this._vm!, this['$initiator'], this.parent!);\n}\n\nfunction callBoundHook(this: Controller, l: LifecycleHooksEntry<IActivationHooks<IHydratedController>, 'bound'>) {\n  return l.instance.bound(this._vm!, this['$initiator'], this.parent!);\n}\n\nfunction callAttachingHook(this: Controller, l: LifecycleHooksEntry<IActivationHooks<IHydratedController>, 'attaching'>) {\n  return l.instance.attaching(this._vm!, this['$initiator'], this.parent!);\n}\n\nfunction callAttachedHook(this: Controller, l: LifecycleHooksEntry<IActivationHooks<IHydratedController>, 'attached'>) {\n  return l.instance.attached(this._vm!, this['$initiator']);\n}\n\nfunction callDetachingHook(this: Controller, l: LifecycleHooksEntry<IActivationHooks<IHydratedController>, 'detaching'>) {\n  return l.instance.detaching(this._vm!, this['$initiator'], this.parent!);\n}\n\nfunction callUnbindingHook(this: Controller, l: LifecycleHooksEntry<IActivationHooks<IHydratedController>, 'unbinding'>) {\n  return l.instance.unbinding(this._vm!, this['$initiator'], this.parent!);\n}\n\n// some reuseable variables to avoid creating nested blocks inside hot paths of controllers\nlet _resolve: undefined | (() => unknown);\nlet _reject: undefined | ((err: unknown) => unknown);\nlet _retPromise: void | Promise<void>;\n", "import { IContainer, IResolver, InstanceProvider, emptyArray, type Writable } from '@aurelia/kernel';\nimport { IAppRoot } from './app-root';\nimport { IPlatform } from './platform';\nimport { findElementControllerFor } from './resources/custom-element';\nimport { MountTarget } from './templating/controller';\nimport type { IHydratedController } from './templating/controller';\nimport { createInterface, registerResolver } from './utilities-di';\n\nexport class Refs {\n  [key: string]: IHydratedController | undefined;\n}\n\nexport function getRef(node: INode, name: string): IHydratedController | null {\n  return node.$au?.[name] ?? null;\n}\n\nexport function setRef(node: INode, name: string, controller: IHydratedController): void {\n  ((node as Writable<INode>).$au ??= new Refs())[name] = controller;\n}\n\nexport type INode<T extends Node = Node> = T & {\n  readonly $au?: Refs;\n};\nexport const INode = /*@__PURE__*/createInterface<INode>('INode');\n\nexport type IEventTarget<T extends EventTarget = EventTarget> = T;\nexport const IEventTarget = /*@__PURE__*/createInterface<IEventTarget>('IEventTarget', x => x.cachedCallback(handler => {\n  if (handler.has(IAppRoot, true)) {\n    return handler.get(IAppRoot).host;\n  }\n  return handler.get(IPlatform).document;\n}));\n\n/**\n * An interface describing a marker.\n * Components can use this to anchor where their content should be rendered in place of a host element.\n */\nexport const IRenderLocation = /*@__PURE__*/createInterface<IRenderLocation>('IRenderLocation');\nexport type IRenderLocation<T extends ChildNode = ChildNode> = T & {\n  $start?: IRenderLocation<T>;\n};\n\n/** @internal */\nexport const ICssClassMapping = /*@__PURE__*/createInterface<Record<string, string>>('ICssClassMapping');\n/** @internal */\nexport const cssMappings: IResolver<Record<string, string>[]> = {\n  $isResolver: true,\n  resolve(_, requestor) {\n    if (requestor.has(ICssClassMapping, false)) {\n      return requestor.getAll(ICssClassMapping);\n    }\n    return emptyArray;\n  }\n};\n\n/**\n * Represents a DocumentFragment with a memory of what it has.\n * This is known as many names, a live fragment for example.\n *\n * Relevant discussion at https://github.com/whatwg/dom/issues/736\n */\nexport interface INodeSequence<T extends INode = INode> {\n  readonly platform: IPlatform;\n\n  readonly next?: INodeSequence<T>;\n\n  /**\n   * The nodes of this sequence.\n   */\n  readonly childNodes: ArrayLike<T>;\n\n  readonly firstChild: T | null;\n\n  readonly lastChild: T | null;\n\n  /**\n   * Find all instruction targets in this sequence.\n   */\n  findTargets(): ArrayLike<T>;\n\n  /**\n   * Insert this sequence as a sibling before refNode\n   */\n  insertBefore(refNode: T | IRenderLocation): void;\n\n  /**\n   * Append this sequence as a child to parent\n   */\n  appendTo(parent: T, enhance?: boolean): void;\n\n  /**\n   * Remove this sequence from the DOM.\n   */\n  remove(): void;\n\n  addToLinked(): void;\n\n  unlink(): void;\n\n  link(next: INodeSequence<T> | IRenderLocation | undefined): void;\n}\n\n_START_CONST_ENUM();\nconst enum NodeType {\n  Element = 1,\n  Attr = 2,\n  Text = 3,\n  CDATASection = 4,\n  EntityReference = 5,\n  Entity = 6,\n  ProcessingInstruction = 7,\n  Comment = 8,\n  Document = 9,\n  DocumentType = 10,\n  DocumentFragment = 11,\n  Notation = 12\n}\n_END_CONST_ENUM();\n\nconst effectiveParentNodeOverrides = new WeakMap<Node, Node>();\n\n/**\n * Returns the effective parentNode according to Aurelia's component hierarchy.\n *\n * Used by Aurelia to find the closest parent controller relative to a node.\n *\n * This method supports 3 additional scenarios that `node.parentNode` does not support:\n * - Containerless elements. The parentNode in this case is a comment precending the element under specific conditions, rather than a node wrapping the element.\n * - ShadowDOM. If a `ShadowRoot` is encountered, this method retrieves the associated controller via the metadata api to locate the original host.\n * - Portals. If the provided node was moved to a different location in the DOM by a `portal` attribute, then the original parent of the node will be returned.\n *\n * @param node - The node to get the parent for.\n * @returns Either the closest parent node, the closest `IRenderLocation` (comment node that is the containerless host), original portal host, or `null` if this is either the absolute document root or a disconnected node.\n */\nexport function getEffectiveParentNode(node: Node): Node | null {\n  // TODO: this method needs more tests!\n  // First look for any overrides\n  if (effectiveParentNodeOverrides.has(node)) {\n    return effectiveParentNodeOverrides.get(node)!;\n  }\n\n  // Then try to get the nearest au-start render location, which would be the containerless parent,\n  // again looking for any overrides along the way.\n  // otherwise return the normal parent node\n  let containerlessOffset = 0;\n  let next = node.nextSibling;\n  while (next !== null) {\n    if (next.nodeType === NodeType.Comment) {\n      switch (next.textContent) {\n        case 'au-start':\n          // If we see an au-start before we see au-end, it will precede the host of a sibling containerless element rather than a parent.\n          // So we use the offset to ignore the next au-end\n          ++containerlessOffset;\n          break;\n        case 'au-end':\n          if (containerlessOffset-- === 0) {\n            return next;\n          }\n      }\n    }\n    next = next.nextSibling;\n  }\n\n  if (node.parentNode === null && node.nodeType === NodeType.DocumentFragment) {\n    // Could be a shadow root; see if there's a controller and if so, get the original host via the projector\n    const controller = findElementControllerFor(node, { optional: true });\n    if (controller == null) {\n      // Not a shadow root (or at least, not one created by Aurelia)\n      // Nothing more we can try, just return null\n      return null;\n    }\n    if (controller.mountTarget === MountTarget.shadowRoot) {\n      return getEffectiveParentNode(controller.host);\n    }\n  }\n\n  return node.parentNode;\n}\n\n/**\n * Set the effective parentNode, overriding the DOM-based structure that `getEffectiveParentNode` otherwise defaults to.\n *\n * Used by Aurelia's `portal` template controller to retain the linkage between the portaled nodes (after they are moved to the portal target) and the original `portal` host.\n *\n * @param nodeSequence - The node sequence whose children that, when `getEffectiveParentNode` is called on, return the supplied `parentNode`.\n * @param parentNode - The node to return when `getEffectiveParentNode` is called on any child of the supplied `nodeSequence`.\n */\nexport function setEffectiveParentNode(nodeSequence: INodeSequence, parentNode: Node): void;\n/**\n * Set the effective parentNode, overriding the DOM-based structure that `getEffectiveParentNode` otherwise defaults to.\n *\n * Used by Aurelia's `portal` template controller to retain the linkage between the portaled nodes (after they are moved to the portal target) and the original `portal` host.\n *\n * @param childNode - The node that, when `getEffectiveParentNode` is called on, returns the supplied `parentNode`.\n * @param parentNode - The node to return when `getEffectiveParentNode` is called on the supplied `childNode`.\n */\nexport function setEffectiveParentNode(childNode: Node, parentNode: Node): void;\nexport function setEffectiveParentNode(childNodeOrNodeSequence: Node | INodeSequence, parentNode: Node): void {\n  if ((childNodeOrNodeSequence as INodeSequence).platform !== void 0 && !(childNodeOrNodeSequence instanceof (childNodeOrNodeSequence as INodeSequence).platform.Node)) {\n    const nodes = childNodeOrNodeSequence.childNodes;\n    for (let i = 0, ii = nodes.length; i < ii; ++i) {\n      effectiveParentNodeOverrides.set(nodes[i] as Node, parentNode);\n    }\n  } else {\n    effectiveParentNodeOverrides.set(childNodeOrNodeSequence as Node, parentNode);\n  }\n}\n\nexport function convertToRenderLocation(node: Node): IRenderLocation {\n  if (isRenderLocation(node)) {\n    return node; // it's already a IRenderLocation (converted by FragmentNodeSequence)\n  }\n\n  const locationEnd = node.ownerDocument!.createComment('au-end') as IRenderLocation;\n  const locationStart = locationEnd.$start = node.ownerDocument!.createComment('au-start') as IRenderLocation;\n  const parentNode = node.parentNode;\n\n  if (parentNode !== null) {\n    parentNode.replaceChild(locationEnd, node);\n    parentNode.insertBefore(locationStart, locationEnd);\n  }\n\n  return locationEnd;\n}\n\nexport function isRenderLocation(node: INode | INodeSequence): node is IRenderLocation {\n  return (node as Comment).textContent === 'au-end';\n}\n\nexport class FragmentNodeSequence implements INodeSequence {\n  /** @internal */\n  private readonly _firstChild: Node | null;\n  public get firstChild(): Node | null {\n    return this._firstChild;\n  }\n\n  /** @internal */\n  private readonly _lastChild: Node | null;\n  public get lastChild(): Node | null {\n    return this._lastChild;\n  }\n\n  public childNodes: Node[];\n\n  public next?: INodeSequence = void 0;\n\n  /** @internal */\n  private _isMounted: boolean = false;\n\n  /** @internal */\n  private _isLinked: boolean = false;\n\n  /** @internal */\n  private ref?: Node | null = null;\n\n  /** @internal */\n  private readonly t: ArrayLike<Node>;\n\n  /** @internal */\n  private readonly f: DocumentFragment;\n\n  public constructor(\n    public readonly platform: IPlatform,\n    fragment: DocumentFragment,\n  ) {\n    const targetNodeList = (this.f = fragment).querySelectorAll('au-m');\n    let i = 0;\n    let ii = targetNodeList.length;\n    // eslint-disable-next-line\n    let targets = this.t = Array(ii);\n    let target: Node | IRenderLocation;\n    let marker: Element;\n\n    while (ii > i) {\n      marker = targetNodeList[i];\n      target = marker.nextSibling!;\n      marker.remove();\n      if (target.nodeType === 8) {\n        marker = target as Element;\n        (target = target.nextSibling as IRenderLocation).$start = marker as unknown as Comment;\n      }\n      targets[i] = target;\n      ++i;\n    }\n\n    const childNodeList = fragment.childNodes;\n    const childNodes = this.childNodes = Array(ii = childNodeList.length) as Node[];\n    i = 0;\n    while (ii > i) {\n      childNodes[i] = childNodeList[i];\n      ++i;\n    }\n\n    this._firstChild = fragment.firstChild;\n    this._lastChild = fragment.lastChild;\n  }\n\n  public findTargets(): ArrayLike<Node> {\n    return this.t;\n  }\n\n  public insertBefore(refNode: IRenderLocation & Comment): void {\n    if (this._isLinked && !!this.ref) {\n      this.addToLinked();\n    } else {\n      const parent = refNode.parentNode!;\n      if (this._isMounted) {\n        let current = this._firstChild;\n        let next: Node;\n        const end = this._lastChild;\n\n        while (current != null) {\n          next = current.nextSibling!;\n          parent.insertBefore(current, refNode);\n\n          if (current === end) {\n            break;\n          }\n\n          current = next;\n        }\n      } else {\n        this._isMounted = true;\n        refNode.parentNode!.insertBefore(this.f, refNode);\n      }\n    }\n  }\n\n  public appendTo(parent: Node, enhance: boolean = false): void {\n    if (this._isMounted) {\n      let current = this._firstChild;\n      let next: Node;\n      const end = this._lastChild;\n\n      while (current != null) {\n        next = current.nextSibling!;\n        parent.appendChild(current);\n\n        if (current === end) {\n          break;\n        }\n\n        current = next;\n      }\n    } else {\n      this._isMounted = true;\n      if (!enhance) {\n        parent.appendChild(this.f);\n      }\n    }\n  }\n\n  public remove(): void {\n    if (this._isMounted) {\n      this._isMounted = false;\n\n      const fragment = this.f;\n      const end = this._lastChild;\n      let next: Node;\n\n      let current = this._firstChild;\n      while (current !== null) {\n        next = current.nextSibling!;\n        fragment.appendChild(current);\n\n        if (current === end) {\n          break;\n        }\n\n        current = next;\n      }\n    }\n  }\n\n  public addToLinked(): void {\n    const refNode = this.ref!;\n    const parent = refNode.parentNode!;\n    if (this._isMounted) {\n      let current = this._firstChild;\n      let next: Node;\n      const end = this._lastChild;\n\n      while (current != null) {\n        next = current.nextSibling!;\n        parent.insertBefore(current, refNode);\n\n        if (current === end) {\n          break;\n        }\n\n        current = next;\n      }\n    } else {\n      this._isMounted = true;\n      parent.insertBefore(this.f, refNode);\n    }\n  }\n\n  public unlink(): void {\n    this._isLinked = false;\n    this.next = void 0;\n    this.ref = void 0;\n  }\n\n  public link(next: INodeSequence | IRenderLocation & Comment | undefined): void {\n    this._isLinked = true;\n    if (isRenderLocation(next!)) {\n      this.ref = next;\n    } else {\n      this.next = next;\n      this._obtainRefNode();\n    }\n  }\n\n  /** @internal */\n  private _obtainRefNode(): void {\n    if (this.next !== void 0) {\n      this.ref = this.next.firstChild;\n    } else {\n      this.ref = void 0;\n    }\n  }\n}\n\nexport const IWindow = /*@__PURE__*/createInterface<IWindow>('IWindow', x => x.callback(handler => handler.get(IPlatform).window));\nexport interface IWindow extends Window { }\n\nexport const ILocation = /*@__PURE__*/createInterface<ILocation>('ILocation', x => x.callback(handler => handler.get(IWindow).location));\nexport interface ILocation extends Location { }\n\nexport const IHistory = /*@__PURE__*/createInterface<IHistory>('IHistory', x => x.callback(handler => handler.get(IWindow).history));\n// NOTE: `IHistory` is documented\n/**\n * https://developer.mozilla.org/en-US/docs/Web/API/History\n *\n * A convenience interface that (unless explicitly overridden in DI) resolves directly to the native browser `history` object.\n *\n * Allows manipulation of the browser session history, that is the pages visited in the tab or frame that the current page is loaded in.\n */\nexport interface IHistory extends History {\n  /**\n   * Returns an integer representing the number of elements in the session history, including the currently loaded page.\n   * For example, for a page loaded in a new tab this property returns 1.\n   */\n  readonly length: number;\n  /**\n   * Allows web applications to explicitly set default scroll restoration behavior on history navigation.\n   *\n   * - `auto` The location on the page to which the user has scrolled will be restored.\n   * - `manual` The location on the page is not restored. The user will have to scroll to the location manually.\n   */\n  scrollRestoration: ScrollRestoration;\n  /**\n   * Returns a value representing the state at the top of the history stack.\n   * This is a way to look at the state without having to wait for a popstate event\n   */\n  readonly state: unknown;\n  /**\n   * Causes the browser to move back one page in the session history.\n   * It has the same effect as calling history.go(-1).\n   * If there is no previous page, this method call does nothing.\n   *\n   * This method is asynchronous.\n   * Add a listener for the `popstate` event in order to determine when the navigation has completed.\n   */\n  back(): void;\n  /**\n   * Causes the browser to move forward one page in the session history.\n   * It has the same effect as calling `history.go(1)`.\n   *\n   * This method is asynchronous.\n   * Add a listener for the `popstate` event in order to determine when the navigation has completed.\n   */\n  forward(): void;\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/History/go\n   *\n   * Loads a specific page from the session history.\n   * You can use it to move forwards and backwards through the history depending on the value of a parameter.\n   *\n   * This method is asynchronous.\n   * Add a listener for the `popstate` event in order to determine when the navigation has completed.\n   *\n   * @param delta - The position in the history to which you want to move, relative to the current page.\n   * A negative value moves backwards, a positive value moves forwards.\n   * So, for example, `history.go(2)` moves forward two pages and `history.go(-2)` moves back two pages.\n   * If no value is passed or if `delta` equals 0, it has the same result as calling `location.reload()`.\n   */\n  go(delta?: number): void;\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/History/pushState\n   *\n   * Adds a state to the browser's session history stack.\n   *\n   * @param state - An object which is associated with the new history entry created by `pushState`.\n   * Whenever the user navigates to the new state, a `popstate` event is fired, and the state property of the event contains a copy of the history entry's state object.\n   * The state object can be anything that can be serialized.\n   * @param title - Most browsers currently ignores this parameter, although they may use it in the future.\n   * Passing the empty string here should be safe against future changes to the method.\n   * Alternatively, you could pass a short title for the state.\n   * @param url - The new history entry's URL is given by this parameter.\n   * Note that the browser won't attempt to load this URL after a call to pushState(), but it might attempt to load the URL later, for instance after the user restarts the browser.\n   * The new URL does not need to be absolute; if it's relative, it's resolved relative to the current URL.\n   * The new URL must be of the same origin as the current URL; otherwise, pushState() will throw an exception.\n   * If this parameter isn't specified, it's set to the document's current URL.\n   */\n  pushState(state: {} | null, title: string, url?: string | null): void;\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n   *\n   * Modifies the current history entry, replacing it with the stateObj, title, and URL passed in the method parameters.\n   *\n   * This method is particularly useful when you want to update the state object or URL of the current history entry in response to some user action.\n   *\n   * @param state - An object which is associated with the history entry passed to the `replaceState` method.\n   * @param title - Most browsers currently ignores this parameter, although they may use it in the future.\n   * Passing the empty string here should be safe against future changes to the method.\n   * Alternatively, you could pass a short title for the state.\n   * @param url - The URL of the history entry.\n   * The new URL must be of the same origin as the current URL; otherwise `replaceState` throws an exception.\n   */\n  replaceState(state: {} | null, title: string, url?: string | null): void;\n}\n\n/**\n * An utility to register a host node with the container with all the commonly used keys.\n */\nexport const registerHostNode = (container: IContainer, host: INode | null, platform = container.get(IPlatform)) => {\n  registerResolver(\n    container,\n    platform.HTMLElement,\n    registerResolver(\n      container,\n      platform.Element,\n      registerResolver(container, INode, new InstanceProvider('ElementResolver', host))\n    )\n  );\n  return container;\n};\n", "import {\n  mergeArrays,\n  fromDefinitionOrDefault,\n  pascalCase,\n  fromAnnotationOrTypeOrDefault,\n  fromAnnotationOrDefinitionOrTypeOrDefault,\n  emptyArray,\n  resourceBaseName,\n  getResourceKeyFor,\n  isFunction,\n  isString,\n  isSymbol,\n} from '@aurelia/kernel';\nimport { Bindable } from '../bindable';\nimport { getEffectiveParentNode, getRef } from '../dom';\nimport { Watch } from '../watch';\nimport { defineMetadata, getAnnotationKeyFor, getMetadata, hasMetadata } from '../utilities-metadata';\nimport { def, objectAssign, objectFreeze } from '../utilities';\nimport { aliasRegistration, singletonRegistration } from '../utilities-di';\n\nimport type {\n  Constructable,\n  IContainer,\n  ResourceType,\n  PartialResourceDefinition,\n  Key,\n  ResourceDefinition,\n  IResolver,\n  Writable,\n  StaticResourceType,\n  InterfaceSymbol,\n} from '@aurelia/kernel';\nimport type { BindableDefinition } from '../bindable';\nimport type { INode } from '../dom';\nimport type { Controller, ICustomElementViewModel, ICustomElementController } from '../templating/controller';\nimport { ProcessContentHook, type IElementComponentDefinition, IInstruction } from '@aurelia/template-compiler';\nimport type { IWatchDefinition } from '../watch';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { dtElement, getDefinitionFromStaticAu, type IResourceKind } from './resources-shared';\n\nexport type PartialCustomElementDefinition<TBindables extends string = string> = PartialResourceDefinition<Omit<IElementComponentDefinition<TBindables>, 'type'> & {\n  /**\n   * An semi internal property used to signal the rendering process not to try to compile the template again\n   */\n  readonly injectable?: InterfaceSymbol | null;\n  readonly enhance?: boolean;\n  readonly watches?: IWatchDefinition[];\n  readonly strict?: boolean;\n}>;\n\nexport type CustomElementStaticAuDefinition<TBindables extends string = string> = PartialCustomElementDefinition<TBindables> & {\n  type: 'custom-element';\n};\n\nexport type CustomElementType<C extends Constructable = Constructable> = ResourceType<C, ICustomElementViewModel & (C extends Constructable<infer P> ? P : object), PartialCustomElementDefinition>;\nexport type CustomElementKind = IResourceKind & {\n  /**\n   * Returns the closest controller that is associated with either this node (if it is a custom element) or the first\n   * parent node (including containerless) that is a custom element.\n   *\n   * As long as the provided node was directly or indirectly created by Aurelia, this method is guaranteed to return a controller.\n   *\n   * @param node - The node relative to which to get the closest controller.\n   * @param searchParents - Also search the parent nodes (including containerless).\n   * @returns The closest controller relative to the provided node.\n   * @throws - If neither the node or any of its effective parent nodes host a custom element, an error will be thrown.\n   */\n  for<C extends ICustomElementViewModel = ICustomElementViewModel>(node: Node, opts: { searchParents: true }): ICustomElementController<C>;\n  /**\n   * Returns the controller that is associated with this node, if it is a custom element with the provided name.\n   *\n   * @param node - The node to retrieve the controller for, if it is a custom element with the provided name.\n   * @returns The controller associated with the provided node, if it is a custom element with the provided name, or otherwise `undefined`.\n   * @throws - If the node does not host a custom element, an error will be thrown.\n   */\n  for<C extends ICustomElementViewModel = ICustomElementViewModel>(node: Node, opts: { name: string }): ICustomElementController<C> | undefined;\n  /**\n   * Returns the closest controller that is associated with either this node (if it is a custom element) or the first\n   * parent node (including containerless) that is a custom element with the provided name.\n   *\n   * @param node - The node relative to which to get the closest controller of a custom element with the provided name.\n   * @param searchParents - Also search the parent nodes (including containerless).\n   * @returns The closest controller of a custom element with the provided name, relative to the provided node, if one can be found, or otherwise `undefined`.\n   * @throws - If neither the node or any of its effective parent nodes host a custom element, an error will be thrown.\n   */\n  for<C extends ICustomElementViewModel = ICustomElementViewModel>(node: Node, opts: { name: string; searchParents: true }): ICustomElementController<C> | undefined;\n  /**\n   * Returns the controller that is associated with this node, if it is a custom element.\n   *\n   * @param node - The node to retrieve the controller for, if it is a custom element.\n   * @param optional - If `true`, do not throw if the provided node is not a custom element.\n   * @returns The controller associated with the provided node, if it is a custom element\n   * @throws - If the node does not host a custom element, an error will be thrown.\n   */\n  for<C extends ICustomElementViewModel = ICustomElementViewModel>(node: Node): ICustomElementController<C>;\n  /**\n   * Returns the controller that is associated with this node, if it is a custom element.\n   *\n   * @param node - The node to retrieve the controller for, if it is a custom element.\n   * @param optional - If `true`, do not throw if the provided node is not a custom element.\n   * @returns The controller associated with the provided node, if it is a custom element, otherwise `null`\n   */\n  for<C extends ICustomElementViewModel = ICustomElementViewModel>(node: Node, opts: { optional: true }): ICustomElementController<C> | null;\n  isType<C>(value: C, context?: DecoratorContext): value is (C extends Constructable ? CustomElementType<C> : never);\n  define<C extends Constructable>(name: string, Type: C): CustomElementType<C>;\n  define<C extends Constructable>(def: PartialCustomElementDefinition, Type: C): CustomElementType<C>;\n  define<C extends Constructable>(def: PartialCustomElementDefinition, Type?: null): CustomElementType<C>;\n  define<C extends Constructable>(nameOrDef: string | PartialCustomElementDefinition, Type: C): CustomElementType<C>;\n  getDefinition<C extends Constructable>(Type: C, context?: DecoratorContext | null): CustomElementDefinition<C>;\n  // eslint-disable-next-line\n  getDefinition<C extends Constructable>(Type: Function, context?: DecoratorContext | null): CustomElementDefinition<C>;\n  annotate<K extends keyof PartialCustomElementDefinition>(Type: Constructable, prop: K, value: PartialCustomElementDefinition[K], context: DecoratorContext): void;\n  getAnnotation<K extends keyof PartialCustomElementDefinition>(Type: Constructable, prop: K, context: DecoratorContext | null): PartialCustomElementDefinition[K] | undefined;\n  generateName(): string;\n  createInjectable<T extends Key = Key>(): InterfaceSymbol<T>;\n  generateType<P extends {} = {}>(\n    name: string,\n    proto?: P,\n  ): CustomElementType<Constructable<P>>;\n  find(container: IContainer, name: string): CustomElementDefinition | null;\n};\n\nexport type CustomElementDecorator = <T extends Constructable>(Type: T, context: ClassDecoratorContext) => CustomElementType<T>;\n\n/**\n * Decorator: Indicates that the decorated class is a custom element.\n */\nexport function customElement(definition: PartialCustomElementDefinition): CustomElementDecorator;\nexport function customElement(name: string): CustomElementDecorator;\nexport function customElement(nameOrDef: string | PartialCustomElementDefinition): CustomElementDecorator;\nexport function customElement(nameOrDef: string | PartialCustomElementDefinition): CustomElementDecorator {\n  return function <T extends Constructable>(target: T, context: ClassDecoratorContext) {\n    context.addInitializer(function (this) {\n      defineElement(nameOrDef, this as Constructable);\n    });\n    return target as CustomElementType<T>;\n  };\n}\n\ntype ShadowOptions = PartialCustomElementDefinition['shadowOptions'];\n\n/**\n * Decorator: Indicates that the custom element should render its view in ShadowDOM.\n */\nexport function useShadowDOM(options?: ShadowOptions): (target: Constructable, context: ClassDecoratorContext) => void;\n/**\n * Decorator: Indicates that the custom element should render its view in ShadowDOM.\n */\nexport function useShadowDOM(target: Constructable): void;\nexport function useShadowDOM(targetOrOptions?: Constructable | ShadowOptions, context?: ClassDecoratorContext): void | ((target: Constructable, context: ClassDecoratorContext) => void) {\n  if (targetOrOptions === void 0) {\n    return function ($target: Constructable, context: ClassDecoratorContext) {\n      context.addInitializer(function (this) {\n        annotateElementMetadata(this as Constructable, 'shadowOptions', { mode: 'open' });\n      });\n    };\n  }\n\n  if (!isFunction(targetOrOptions)) {\n    return function ($target: Constructable, context: ClassDecoratorContext) {\n      context.addInitializer(function (this) {\n        annotateElementMetadata(this as Constructable, 'shadowOptions', targetOrOptions);\n      });\n    };\n  }\n\n  context!.addInitializer(function (this) {\n    annotateElementMetadata(this as Constructable, 'shadowOptions', { mode: 'open' });\n  });\n}\n\n/**\n * Decorator: Indicates that the custom element should be rendered without its element container.\n */\nexport function containerless(target: Constructable, context: ClassDecoratorContext): void;\n/**\n * Decorator: Indicates that the custom element should be rendered without its element container.\n */\nexport function containerless(): (target: Constructable, context: ClassDecoratorContext) => void;\nexport function containerless(target?: Constructable, context?: ClassDecoratorContext): void | ((target: Constructable, context: ClassDecoratorContext) => void) {\n  if (target === void 0) {\n    return function ($target: Constructable, $context: ClassDecoratorContext) {\n      $context.addInitializer(function (this) {\n        markContainerless($target);\n      });\n    };\n  }\n\n  context!.addInitializer(function (this) {\n    markContainerless(target);\n  });\n}\n\n/** Manipulates the `containerless` property of the custom element definition for the type, when present else it annotates the type. */\nfunction markContainerless(target: Constructable) {\n  const def = getMetadata<CustomElementDefinition>(elementBaseName, target);\n  if(def === void 0) {\n    annotateElementMetadata(target, 'containerless', true);\n    return;\n  }\n  (def as Writable<CustomElementDefinition>).containerless = true;\n}\n\nconst definitionLookup = new WeakMap<PartialCustomElementDefinition, CustomElementDefinition>();\n\nexport class CustomElementDefinition<C extends Constructable = Constructable> implements ResourceDefinition<C, ICustomElementViewModel, PartialCustomElementDefinition> {\n  public get type(): 'custom-element' { return dtElement; }\n  private constructor(\n    public readonly Type: CustomElementType<C>,\n    public readonly name: string,\n    public readonly aliases: string[],\n    public readonly key: string,\n    public readonly capture: boolean | ((attr: string) => boolean),\n    public readonly template: null | string | Node,\n    public readonly instructions: readonly IInstruction[][],\n    public readonly dependencies: Key[],\n    public readonly injectable: InterfaceSymbol<C> | null,\n    public readonly needsCompile: boolean,\n    public readonly surrogates: readonly IInstruction[],\n    public readonly bindables: Record<string, BindableDefinition>,\n    public readonly containerless: boolean,\n    public readonly shadowOptions: { mode: 'open' | 'closed' } | null,\n    /**\n     * Indicates whether the custom element has <slot/> in its template\n     */\n    public readonly hasSlots: boolean,\n    public readonly enhance: boolean,\n    public readonly watches: IWatchDefinition[],\n    public readonly strict: boolean | undefined,\n    public readonly processContent: ProcessContentHook | null,\n  ) { }\n\n  public static create(\n    def: PartialCustomElementDefinition,\n    Type?: null,\n  ): CustomElementDefinition;\n  public static create(\n    name: string,\n    Type: CustomElementType,\n  ): CustomElementDefinition;\n  public static create<T extends Constructable = Constructable>(\n    nameOrDef: string | PartialCustomElementDefinition,\n    Type?: CustomElementType<T> | null,\n  ): CustomElementDefinition<T>;\n  public static create(\n    nameOrDef: string | PartialCustomElementDefinition,\n    Type: CustomElementType | null = null,\n  ): CustomElementDefinition {\n    if (Type === null) {\n      const def = nameOrDef;\n      if (isString(def)) {\n        throw createMappedError(ErrorNames.element_only_name, nameOrDef);\n      }\n\n      const name = fromDefinitionOrDefault('name', def, generateElementName);\n      if (isFunction((def as CustomElementDefinition).Type)) {\n        // This needs to be a clone (it will usually be the compiler calling this signature)\n\n        // TODO: we need to make sure it's documented that passing in the type via the definition (while passing in null\n        // as the \"Type\" parameter) effectively skips type analysis, so it should only be used this way for cloning purposes.\n        Type = (def as CustomElementDefinition).Type;\n      } else {\n        Type = generateElementType(pascalCase(name));\n      }\n\n      for(const bindable of Object.values(Bindable.from(def.bindables))) {\n        Bindable._add(bindable, Type);\n      }\n      return new CustomElementDefinition(\n        Type,\n        name,\n        mergeArrays(def.aliases),\n        fromDefinitionOrDefault('key', def as CustomElementDefinition, () => getElementKeyFrom(name)),\n        fromAnnotationOrDefinitionOrTypeOrDefault('capture', def, Type, returnFalse),\n        fromDefinitionOrDefault('template', def, returnNull),\n        mergeArrays(def.instructions),\n        mergeArrays(getElementAnnotation(Type, 'dependencies'), def.dependencies),\n        fromDefinitionOrDefault('injectable', def, returnNull),\n        fromDefinitionOrDefault('needsCompile', def, returnTrue),\n        mergeArrays(def.surrogates),\n        Bindable.from(getElementAnnotation(Type, 'bindables'), def.bindables),\n        fromAnnotationOrDefinitionOrTypeOrDefault('containerless', def, Type, returnFalse),\n        fromDefinitionOrDefault('shadowOptions', def, returnNull),\n        fromDefinitionOrDefault('hasSlots', def, returnFalse),\n        fromDefinitionOrDefault('enhance', def, returnFalse),\n        fromDefinitionOrDefault('watches', def as CustomElementDefinition, returnEmptyArray),\n        // casting is incorrect, but it's good enough\n        fromDefinitionOrDefault('strict', def, returnUndefined as () => boolean),\n        fromAnnotationOrTypeOrDefault('processContent', Type, returnNull as () => ProcessContentHook | null),\n\n      );\n    }\n\n    // If a type is passed in, we ignore the Type property on the definition if it exists.\n    // TODO: document this behavior\n\n    if (isString(nameOrDef)) {\n      return new CustomElementDefinition(\n        Type,\n        nameOrDef,\n        mergeArrays(getElementAnnotation(Type, 'aliases'), Type.aliases),\n        getElementKeyFrom(nameOrDef),\n        fromAnnotationOrTypeOrDefault('capture', Type, returnFalse),\n        fromAnnotationOrTypeOrDefault('template', Type, returnNull as () => string | Node | null),\n        mergeArrays(getElementAnnotation(Type, 'instructions'), Type.instructions),\n        mergeArrays(getElementAnnotation(Type, 'dependencies'), Type.dependencies),\n        fromAnnotationOrTypeOrDefault('injectable', Type, returnNull as () => InterfaceSymbol | null),\n        fromAnnotationOrTypeOrDefault('needsCompile', Type, returnTrue),\n        mergeArrays(getElementAnnotation(Type, 'surrogates'), Type.surrogates),\n        Bindable.from(\n          ...Bindable.getAll(Type),\n          getElementAnnotation(Type, 'bindables'),\n          Type.bindables,\n        ),\n        fromAnnotationOrTypeOrDefault('containerless', Type, returnFalse),\n        fromAnnotationOrTypeOrDefault('shadowOptions', Type, returnNull as () => { mode: 'open' | 'closed' } | null),\n        fromAnnotationOrTypeOrDefault('hasSlots', Type, returnFalse),\n        fromAnnotationOrTypeOrDefault('enhance', Type, returnFalse),\n        mergeArrays(Watch.getDefinitions(Type), Type.watches),\n        fromAnnotationOrTypeOrDefault('strict', Type, returnUndefined as () => boolean),\n        fromAnnotationOrTypeOrDefault('processContent', Type, returnNull as () => ProcessContentHook | null),\n      );\n    }\n\n    // This is the typical default behavior, e.g. from regular CustomElement.define invocations or from @customElement deco\n    // The ViewValueConverter also uses this signature and passes in a definition where everything except for the 'hooks'\n    // property needs to be copied. So we have that exception for 'hooks', but we may need to revisit that default behavior\n    // if this turns out to be too opinionated.\n\n    const name = fromDefinitionOrDefault('name', nameOrDef, generateElementName);\n\n    for(const bindable of Object.values(Bindable.from(nameOrDef.bindables))) {\n      Bindable._add(bindable, Type);\n    }\n    return new CustomElementDefinition(\n      Type,\n      name,\n      mergeArrays(getElementAnnotation(Type, 'aliases'), nameOrDef.aliases, Type.aliases),\n      getElementKeyFrom(name),\n      fromAnnotationOrDefinitionOrTypeOrDefault('capture', nameOrDef, Type, returnFalse),\n      fromAnnotationOrDefinitionOrTypeOrDefault('template', nameOrDef, Type, returnNull),\n      mergeArrays(getElementAnnotation(Type, 'instructions'), nameOrDef.instructions, Type.instructions),\n      mergeArrays(getElementAnnotation(Type, 'dependencies'), nameOrDef.dependencies, Type.dependencies),\n      fromAnnotationOrDefinitionOrTypeOrDefault('injectable', nameOrDef, Type, returnNull),\n      fromAnnotationOrDefinitionOrTypeOrDefault('needsCompile', nameOrDef, Type, returnTrue),\n      mergeArrays(getElementAnnotation(Type, 'surrogates'), nameOrDef.surrogates, Type.surrogates),\n      Bindable.from(\n        ...Bindable.getAll(Type),\n        getElementAnnotation(Type, 'bindables'),\n        Type.bindables,\n        nameOrDef.bindables,\n      ),\n      fromAnnotationOrDefinitionOrTypeOrDefault('containerless', nameOrDef, Type, returnFalse),\n      fromAnnotationOrDefinitionOrTypeOrDefault('shadowOptions', nameOrDef, Type, returnNull),\n      fromAnnotationOrDefinitionOrTypeOrDefault('hasSlots', nameOrDef, Type, returnFalse),\n      fromAnnotationOrDefinitionOrTypeOrDefault('enhance', nameOrDef, Type, returnFalse),\n      mergeArrays(nameOrDef.watches, Watch.getDefinitions(Type), Type.watches),\n      fromAnnotationOrDefinitionOrTypeOrDefault('strict', nameOrDef, Type, returnUndefined as () => boolean),\n      fromAnnotationOrDefinitionOrTypeOrDefault('processContent', nameOrDef, Type, returnNull),\n    );\n  }\n\n  public static getOrCreate(partialDefinition: PartialCustomElementDefinition): CustomElementDefinition {\n    if (partialDefinition instanceof CustomElementDefinition) {\n      return partialDefinition;\n    }\n\n    if (definitionLookup.has(partialDefinition)) {\n      return definitionLookup.get(partialDefinition)!;\n    }\n\n    const definition = CustomElementDefinition.create(partialDefinition);\n    definitionLookup.set(partialDefinition, definition);\n    // Make sure the full definition can be retrieved from dynamically created classes as well\n    defineMetadata(definition, definition.Type, elementBaseName);\n    return definition;\n  }\n\n  public register(container: IContainer, aliasName?: string | undefined): void {\n    const $Type = this.Type;\n    const key = typeof aliasName === 'string' ? getElementKeyFrom(aliasName) : this.key;\n    const aliases = this.aliases;\n\n    /* istanbul ignore next */\n    if (container.has(key, false)) {\n      // eslint-disable-next-line no-console\n      console.warn(createMappedError(ErrorNames.element_existed, this.name));\n      return;\n    }\n    container.register(\n      container.has($Type, false) ? null : singletonRegistration($Type, $Type),\n      aliasRegistration($Type, key),\n      ...aliases.map(alias => aliasRegistration($Type, getElementKeyFrom(alias)))\n    );\n  }\n\n  public toString() {\n    return `au:ce:${this.name}`;\n  }\n}\n\ntype ForOpts = {\n  name?: string;\n  searchParents?: boolean;\n  optional?: boolean;\n};\nconst defaultForOpts: ForOpts = {\n  name: undefined,\n  searchParents: false,\n  optional: false,\n};\nconst returnNull = <T>(): T | null => null;\nconst returnUndefined = <T>(): T | undefined => void 0;\nconst returnFalse = () => false;\nconst returnTrue = () => true;\nconst returnEmptyArray = () => emptyArray;\n\n/** @internal */ export const elementTypeName = 'custom-element';\n/** @internal */ export const elementBaseName = /*@__PURE__*/getResourceKeyFor(elementTypeName);\n\n/** @internal */\nexport const getElementKeyFrom = (name: string): string => `${elementBaseName}:${name}`;\n\n/** @internal */\nexport const generateElementName = /*@__PURE__*/(id => () => `unnamed-${++id}`)(0);\n\nconst annotateElementMetadata = <K extends keyof PartialCustomElementDefinition>(Type: Constructable, prop: K, value: PartialCustomElementDefinition[K]): void => {\n  defineMetadata(value, Type, getAnnotationKeyFor(prop));\n};\n\n/** @internal */\nexport const defineElement = <C extends Constructable>(nameOrDef: string | PartialCustomElementDefinition, Type: C | null): CustomElementType<C> => {\n  const definition = CustomElementDefinition.create(nameOrDef, Type as CustomElementType<C>);\n  const $Type = definition.Type;\n\n  // this is the case, where the APi is invoked directly without a decorator\n  // registration of resource name is a requirement for the resource system in kernel (module-loader)\n  defineMetadata(definition, $Type, elementBaseName, resourceBaseName);\n\n  return $Type;\n};\n\n/** @internal */\nexport const isElementType = <C>(value: C): value is (C extends Constructable ? CustomElementType<C> : never) => {\n  return isFunction(value)\n    && (hasMetadata(elementBaseName, value)\n      || (value as StaticResourceType).$au?.type === elementTypeName\n    );\n};\n\n/** @internal */\nexport const findElementControllerFor = <C extends ICustomElementViewModel = ICustomElementViewModel>(node: Node, opts: ForOpts = defaultForOpts): ICustomElementController<C> => {\n  if (opts.name === void 0 && opts.searchParents !== true) {\n    const controller = getRef(node, elementBaseName) as Controller<C> | null;\n    if (controller === null) {\n      if (opts.optional === true) {\n        return null!;\n      }\n      throw createMappedError(ErrorNames.node_is_not_a_host, node);\n    }\n    return controller as unknown as ICustomElementController<C>;\n  }\n  if (opts.name !== void 0) {\n    if (opts.searchParents !== true) {\n      const controller = getRef(node, elementBaseName) as Controller<C> | null;\n      if (controller === null) {\n        throw createMappedError(ErrorNames.node_is_not_a_host2, node);\n      }\n\n      if (controller.is(opts.name)) {\n        return controller as unknown as ICustomElementController<C>;\n      }\n\n      return (void 0)!;\n    }\n\n    let cur = node as INode | null;\n    let foundAController = false;\n    while (cur !== null) {\n      const controller = getRef(cur, elementBaseName) as Controller<C> | null;\n      if (controller !== null) {\n        foundAController = true;\n        if (controller.is(opts.name)) {\n          return controller as unknown as ICustomElementController<C>;\n        }\n      }\n\n      cur = getEffectiveParentNode(cur);\n    }\n\n    if (foundAController) {\n      return (void 0)!;\n    }\n\n    throw createMappedError(ErrorNames.node_is_not_part_of_aurelia_app, node);\n  }\n\n  let cur = node as INode | null;\n  while (cur !== null) {\n    const controller = getRef(cur, elementBaseName) as Controller<C> | null;\n    if (controller !== null) {\n      return controller as unknown as ICustomElementController<C>;\n    }\n\n    cur = getEffectiveParentNode(cur);\n  }\n\n  throw createMappedError(ErrorNames.node_is_not_part_of_aurelia_app2, node);\n};\n\nconst getElementAnnotation = <K extends keyof PartialCustomElementDefinition>(\n  Type: Constructable,\n  prop: K,\n): PartialCustomElementDefinition[K] | undefined => getMetadata(getAnnotationKeyFor(prop), Type);\n\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const getElementDefinition = <C extends Constructable>(Type: C | Function): CustomElementDefinition<C> => {\n  const def: CustomElementDefinition<C> = getMetadata<CustomElementDefinition<C>>(elementBaseName, Type)\n    ?? getDefinitionFromStaticAu<CustomElementDefinition<C>>(Type as CustomElementType, elementTypeName, CustomElementDefinition.create);\n  if (def == null) {\n    throw createMappedError(ErrorNames.element_def_not_found, Type);\n  }\n\n  return def;\n};\n\n/** @internal */\nexport const createElementInjectable = <K extends Key = Key>(): InterfaceSymbol<K> => {\n  const $injectable = {\n    // Old code is kept around. Needs to be refactored when TC39 supports argument decorator.\n    // function(target: Injectable | AbstractInjectable, property: string | symbol | undefined, index?: number): Injectable | AbstractInjectable {\n    //   const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target as Constructable);\n    //   annotationParamtypes[index!] = $injectable;\n    //   return target;\n    // },\n    $isInterface: false,\n    register(): IResolver {\n      return {\n        $isResolver: true,\n        resolve(container, requestor) {\n          if (requestor.has($injectable, true)) {\n            return requestor.get($injectable);\n          } else {\n            return null;\n          }\n        }\n      };\n    }\n  };\n\n  return $injectable;\n};\n\n/** @internal */\nexport const generateElementType = /*@__PURE__*/(function () {\n  const nameDescriptor: PropertyDescriptor = {\n    value: '',\n    writable: false,\n    enumerable: false,\n    configurable: true,\n  };\n\n  const defaultProto = {};\n\n  return function <P extends {} = {}>(\n    name: string,\n    proto: P = defaultProto as P,\n  ): CustomElementType<Constructable<P>> {\n    // Anonymous class ensures that minification cannot cause unintended side-effects, and keeps the class\n    // looking similarly from the outside (when inspected via debugger, etc).\n    const Type = class Anonymous { } as CustomElementType<Constructable<P>>;\n\n    // Define the name property so that Type.name can be used by end users / plugin authors if they really need to,\n    // even when minified.\n    nameDescriptor.value = name;\n    def(Type, 'name', nameDescriptor);\n\n    // Assign anything from the prototype that was passed in\n    if (proto !== defaultProto) {\n      objectAssign(Type.prototype, proto);\n    }\n\n    return Type;\n  };\n})();\n\nexport const CustomElement = /*@__PURE__*/ objectFreeze<CustomElementKind>({\n  name: elementBaseName,\n  keyFrom: getElementKeyFrom,\n  isType: isElementType,\n  for: findElementControllerFor,\n  define: defineElement,\n  getDefinition: getElementDefinition,\n  annotate: annotateElementMetadata,\n  getAnnotation: getElementAnnotation,\n  generateName: generateElementName,\n  createInjectable: createElementInjectable,\n  generateType: generateElementType,\n  find(c, name) {\n    const Type = c.find<CustomElementType>(elementTypeName, name);\n    return Type == null\n      ? null\n      : getMetadata(elementBaseName, Type) ?? getDefinitionFromStaticAu(Type, elementTypeName, CustomElementDefinition.create) ?? null;\n  }\n});\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype DecoratorFactoryMethod = (target: Function, context: ClassMethodDecoratorContext) => void;\n\nconst pcHookMetadataProperty = /*@__PURE__*/getAnnotationKeyFor('processContent');\nexport function processContent(hook: ProcessContentHook | string | symbol): CustomElementDecorator;\nexport function processContent(): DecoratorFactoryMethod;\nexport function processContent<TClass extends Constructable>(hook?: ProcessContentHook | string | symbol): CustomElementDecorator | DecoratorFactoryMethod {\n  return hook === void 0\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    ? function (target: Function, context: ClassMethodDecoratorContext) {\n        if (!context.static || context.kind !== 'method') throw createMappedError(ErrorNames.invalid_process_content_hook, target);\n        // As the method is ensured to be static, the following initializer will be invoked in static fashion, before executing the initializers added via a class decorator.\n        // Refer: https://tinyurl.com/ts-static-method-deco\n        context.addInitializer(function (this) {\n          defineMetadata(target, this, pcHookMetadataProperty);\n        });\n    }\n    : function (target: TClass, context: ClassDecoratorContext<TClass>) {\n        context.addInitializer(function (this) {\n          if (isString(hook) || isSymbol(hook)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-explicit-any\n            hook = (this as any)[hook] as ProcessContentHook;\n          }\n          if (!isFunction(hook)) throw createMappedError(ErrorNames.invalid_process_content_hook, hook);\n\n          const def = getMetadata<CustomElementDefinition>(elementBaseName, this);\n          if (def !== void 0) {\n            (def as Writable<CustomElementDefinition>).processContent = hook;\n          } else {\n            defineMetadata(hook, this, pcHookMetadataProperty);\n          }\n        });\n        return target as CustomElementType<TClass>;\n    } as CustomElementDecorator;\n}\n\n/**\n * Decorator: Indicates that the custom element should capture all attributes and bindings that are not template controllers or bindables\n */\nexport function capture(filter: (attr: string) => boolean): (target: Constructable, context: ClassDecoratorContext) => void;\n/**\n * Decorator: Indicates that the custom element should be rendered with the strict binding option. undefined/null -> 0 or '' based on type\n */\nexport function capture(): (target: Constructable, context: ClassDecoratorContext) => void ;\nexport function capture(targetOrFilter?: (attr: string) => boolean): ((target: Constructable, context: ClassDecoratorContext) => void) {\n  return function ($target: Constructable, context: ClassDecoratorContext) {\n    const value = isFunction(targetOrFilter) ? targetOrFilter : true;\n    context.addInitializer(function (this) {\n      annotateElementMetadata(this as Constructable, 'capture', value);\n\n      // also do this to make order of the decorator irrelevant\n      if (isElementType(this)) {\n        (getElementDefinition(this) as Writable<CustomElementDefinition>).capture = value;\n      }\n    });\n  };\n}\n", "import { BrowserPlatform } from '@aurelia/platform-browser';\nimport { InstanceProvider, onResolve, onResolveAll, isFunction } from '@aurelia/kernel';\nimport { IAppTask } from './app-task';\nimport { CustomElementDefinition, generateElementName } from './resources/custom-element';\nimport { Controller, IControllerElementHydrationInstruction } from './templating/controller';\nimport { createInterface, instanceRegistration, registerResolver } from './utilities-di';\n\nimport type { Constructable, IContainer, IDisposable } from '@aurelia/kernel';\nimport type { TaskSlot } from './app-task';\nimport type { ICustomElementViewModel, ICustomElementController } from './templating/controller';\nimport { IPlatform } from './platform';\nimport { IEventTarget, registerHostNode } from './dom';\nimport { ErrorNames, createMappedError } from './errors';\n\nexport interface IAppRootConfig<T extends object = object> {\n  host: HTMLElement;\n  component: T | Constructable<T>;\n  /**\n   * When a HTML form is submitted, the default behavior is to \"redirect\" the page to the action of the form\n   * This is not desirable for SPA applications, so by default, this behavior is prevented.\n   *\n   * This option re-enables the default behavior of HTML forms.\n   */\n  allowActionlessForm?: boolean;\n  /**\n   * Indicates strictness of expression evaluation.\n   *\n   * When strictBinding is true, standard JS behavior applies, which means accessing a property of undefined will throw an error.\n   * Use optional syntaxes (?./?.()/?.[]) to prevent errors.\n   *\n   * When strictBinding is false (default), the behavior is more lenient, which means accessing a property of undefined will return undefined.\n   * In this mode, calling an undefined function will return undefined as well.\n   */\n  strictBinding?: boolean;\n}\n\nexport interface IAppRoot<C extends object = object> extends IDisposable {\n  readonly config: IAppRootConfig<C>;\n  /**\n   * The host element of an application\n   */\n  readonly host: HTMLElement;\n  /**\n   * The root container of an application\n   */\n  readonly container: IContainer;\n  /**\n   * The controller of the root custom element of an application\n   */\n  readonly controller: ICustomElementController<C>;\n  /**\n   * The platform of an application for providing globals & DOM APIs\n   */\n  readonly platform: IPlatform;\n\n  activate(): void | Promise<void>;\n  deactivate(): void | Promise<void>;\n}\nexport const IAppRoot = /*@__PURE__*/createInterface<IAppRoot>('IAppRoot');\n\nexport class AppRoot<\n  T extends object,\n  K extends ICustomElementViewModel = ICustomElementViewModel & (T extends Constructable<infer R> ? R : T),\n> implements IAppRoot<K> {\n\n  /** @internal */\n  private _hydratePromise: Promise<void> | void = void 0;\n\n  /** @internal */\n  private _controller!: ICustomElementController<K>;\n\n  /** @internal */\n  private readonly _useOwnAppTasks: boolean;\n\n  public readonly host: HTMLElement;\n  public readonly platform: IPlatform;\n  public get controller() {\n    return this._controller;\n  }\n\n  public constructor(\n    public readonly config: IAppRootConfig<K>,\n    public readonly container: IContainer,\n    rootProvider: InstanceProvider<IAppRoot>,\n    enhance: boolean = false,\n  ) {\n    this._useOwnAppTasks = enhance;\n    const host = this.host = config.host;\n    rootProvider.prepare(this);\n\n    registerResolver(container, IEventTarget, new InstanceProvider<IEventTarget>('IEventTarget', host));\n    registerHostNode(container, host, this.platform = this._createPlatform(container, host));\n\n    this._hydratePromise = onResolve(this._runAppTasks('creating'), () => {\n      if (!config.allowActionlessForm !== false) {\n        host.addEventListener('submit', (e: Event) => {\n          const target = e.target as HTMLFormElement;\n          const noAction = !target.getAttribute('action');\n\n          if (target.tagName === 'FORM' && noAction) {\n            e.preventDefault();\n          }\n        }, false);\n      }\n\n      const childCtn = enhance ? container : container.createChild();\n      const component = config.component as Constructable | ICustomElementViewModel;\n      let instance: object;\n      if (isFunction(component)) {\n        instance = childCtn.invoke(component);\n        instanceRegistration(component, instance);\n      } else {\n        instance = config.component as ICustomElementViewModel;\n      }\n\n      const hydrationInst: IControllerElementHydrationInstruction = { hydrate: false, projections: null };\n      const definition = enhance\n        ? CustomElementDefinition.create({ name: generateElementName(), template: this.host, enhance: true, strict: config.strictBinding })\n        // leave the work of figuring out the definition to the controller\n        // there's proper error messages in case of failure inside the $el() call\n        : void 0;\n      const controller = (this._controller = Controller.$el<K>(\n        childCtn,\n        instance as K,\n        host,\n        hydrationInst,\n        definition\n      )) as Controller<K>;\n\n      controller._hydrateCustomElement(hydrationInst);\n      return onResolve(this._runAppTasks('hydrating'), () => {\n        controller._hydrate();\n        return onResolve(this._runAppTasks('hydrated'), () => {\n          controller._hydrateChildren();\n          this._hydratePromise = void 0;\n        });\n      });\n    });\n  }\n\n  public activate(): void | Promise<void> {\n    return onResolve(this._hydratePromise, () => {\n      return onResolve(this._runAppTasks('activating'), () => {\n        return onResolve(this._controller.activate(this._controller, null, void 0), () => {\n          return this._runAppTasks('activated');\n        });\n      });\n    });\n  }\n\n  public deactivate(): void | Promise<void> {\n    return onResolve(this._runAppTasks('deactivating'), () => {\n      return onResolve(this._controller.deactivate(this._controller, null), () => {\n        return this._runAppTasks('deactivated');\n      });\n    });\n  }\n\n  /** @internal */\n  private _runAppTasks(slot: TaskSlot): void | Promise<void> {\n    const container = this.container;\n    const appTasks = this._useOwnAppTasks && !container.has(IAppTask, false)\n      ? []\n      : container.getAll(IAppTask);\n    return onResolveAll(...appTasks.reduce((results, task) => {\n      if (task.slot === slot) {\n        results.push(task.run());\n      }\n      return results;\n    }, [] as (void | Promise<void>)[]));\n  }\n\n  /** @internal */\n  private _createPlatform(container: IContainer, host: HTMLElement): IPlatform {\n    let p: IPlatform;\n    if (!container.has(IPlatform, false)) {\n      if (host.ownerDocument.defaultView === null) {\n        throw createMappedError(ErrorNames.invalid_platform_impl);\n      }\n      p = new BrowserPlatform(host.ownerDocument.defaultView);\n      container.register(instanceRegistration(IPlatform, p));\n    } else {\n      p = container.get(IPlatform);\n    }\n    return p;\n  }\n\n  public dispose(): void {\n    this._controller?.dispose();\n  }\n}\n", "import { isPromise, DI, InstanceProvider, onResolve } from '@aurelia/kernel';\nimport { AppRoot, IAppRoot, IAppRootConfig } from './app-root';\nimport { createInterface, registerResolver } from './utilities-di';\n\nimport type {\n  Constructable,\n  IContainer,\n  IDisposable,\n} from '@aurelia/kernel';\nimport { ErrorNames, createMappedError } from './errors';\n\nexport interface IAurelia extends Aurelia {}\nexport const IAurelia = /*@__PURE__*/createInterface<IAurelia>('IAurelia');\n\nexport class Aurelia implements IDisposable {\n  /** @internal */\n  private _isRunning: boolean = false;\n  public get isRunning(): boolean { return this._isRunning; }\n  /** @internal */\n  private _isStarting: boolean = false;\n  public get isStarting(): boolean { return this._isStarting; }\n  /** @internal */\n  private _isStopping: boolean = false;\n  public get isStopping(): boolean { return this._isStopping; }\n\n  // TODO:\n  // root should just be a controller,\n  // in all other parts of the framework, root of something is always the same type of that thing\n  // i.e: container.root => a container, RouteContext.root => a RouteContext\n  // Aurelia.root of a controller hierarchy should behave similarly\n  /** @internal */\n  private _root: IAppRoot | undefined = void 0;\n  public get root(): IAppRoot {\n    if (this._root == null) {\n      if (this.next == null) {\n        throw createMappedError(ErrorNames.root_not_found);\n      }\n      return this.next;\n    }\n    return this._root;\n  }\n\n  private next: IAppRoot | undefined = void 0;\n\n  /** @internal */\n  private readonly _rootProvider: InstanceProvider<IAppRoot>;\n\n  public constructor(\n    public readonly container: IContainer = DI.createContainer(),\n  ) {\n    if (container.has(IAurelia, true) || container.has(Aurelia, true)) {\n      throw createMappedError(ErrorNames.aurelia_instance_existed_in_container);\n    }\n\n    registerResolver(container, IAurelia, new InstanceProvider<IAurelia>('IAurelia', this));\n    registerResolver(container, Aurelia, new InstanceProvider<IAurelia>('Aurelia', this));\n    registerResolver(container, IAppRoot, this._rootProvider = new InstanceProvider('IAppRoot'));\n  }\n\n  public register(...params: unknown[]): this {\n    this.container.register(...params);\n    return this;\n  }\n\n  public app(config: ISinglePageAppConfig): Omit<this, 'register' | 'app' | 'enhance'> {\n    this.next = new AppRoot(config, this.container, this._rootProvider);\n    return this;\n  }\n\n  /**\n   * @param parentController - The owning controller of the view created by this enhance call\n   */\n  public enhance<T extends object>(config: IEnhancementConfig<T>): IAppRoot<T> | Promise<IAppRoot<T>> {\n    const container = (config.container ?? this.container.createChild());\n    const rootProvider = registerResolver(container, IAppRoot, new InstanceProvider<IAppRoot<T>>('IAppRoot'));\n    const appRoot: IAppRoot<T> = new AppRoot(\n      { host: config.host as HTMLElement, component: config.component },\n      container,\n      rootProvider,\n      true\n    );\n    return onResolve(appRoot.activate(), () => appRoot);\n  }\n\n  public async waitForIdle(): Promise<void> {\n    const platform = this.root.platform;\n    await platform.domQueue.yield();\n    await platform.taskQueue.yield();\n  }\n\n  /** @internal */\n  private _startPromise: Promise<void> | void = void 0;\n  public start(root: IAppRoot | undefined = this.next): void | Promise<void> {\n    if (root == null) {\n      throw createMappedError(ErrorNames.no_composition_root);\n    }\n\n    if (isPromise(this._startPromise)) {\n      return this._startPromise;\n    }\n\n    return this._startPromise = onResolve(this.stop(), () => {\n      Reflect.set(root.host, '$aurelia', this);\n      this._rootProvider.prepare(this._root = root);\n      this._isStarting = true;\n\n      return onResolve(root.activate(), () => {\n        this._isRunning = true;\n        this._isStarting = false;\n        this._startPromise = void 0;\n        this._dispatchEvent(root, 'au-started', root.host);\n      });\n    });\n  }\n\n  /** @internal */\n  private _stopPromise: Promise<void> | void = void 0;\n  public stop(dispose: boolean = false): void | Promise<void> {\n    if (isPromise(this._stopPromise)) {\n      return this._stopPromise;\n    }\n\n    if (this._isRunning === true) {\n      const root = this._root!;\n      this._isRunning = false;\n      this._isStopping = true;\n\n      return this._stopPromise = onResolve(root.deactivate(), () => {\n        Reflect.deleteProperty(root.host, '$aurelia');\n        if (dispose) {\n          root.dispose();\n        }\n        this._root = void 0;\n        this._rootProvider.dispose();\n        this._isStopping = false;\n        this._dispatchEvent(root, 'au-stopped', root.host);\n      });\n    }\n  }\n\n  public dispose(): void {\n    if (this._isRunning || this._isStopping) {\n      throw createMappedError(ErrorNames.invalid_dispose_call);\n    }\n    this.container.dispose();\n  }\n\n  /** @internal */\n  private _dispatchEvent(root: IAppRoot, name: string, target: HTMLElement): void {\n    const ev = new root.platform.window.CustomEvent(name, { detail: this, bubbles: true, cancelable: true });\n    target.dispatchEvent(ev);\n  }\n}\n\nexport type ISinglePageAppConfig<T extends object = object> = Omit<IAppRootConfig<T>, 'strictBinding'> & {\n  host: Element;\n};\n\nexport type IEnhancementConfig<T extends object = object> = IAppRootConfig<T> & {\n  host: Element;\n  /**\n   * The binding context of the enhancement. Will be instantiate by DI if a constructor is given\n   */\n  component: T | Constructable<T>;\n  /**\n   * A predefined container for the enhanced view.\n   */\n  container?: IContainer;\n};\n", "import { IPlatform } from '../platform';\nimport { objectAssign } from '../utilities';\nimport { aliasRegistration, createInterface, singletonRegistration } from '../utilities-di';\n\nimport { createLookup, isString, resolve, type IContainer } from '@aurelia/kernel';\nimport type { INode } from '../dom';\n\nexport interface ISVGAnalyzer extends NoopSVGAnalyzer {}\nexport const ISVGAnalyzer = /*@__PURE__*/createInterface<ISVGAnalyzer>('ISVGAnalyzer', x => x.singleton(NoopSVGAnalyzer));\n\nconst o = (keys: string | string[]): Record<string, true | undefined> => {\n  const lookup = createLookup<true | undefined>();\n  keys = isString(keys) ? keys.split(' ') : keys;\n  let key: string;\n  for (key of keys) {\n    lookup[key] = true;\n  }\n  return lookup;\n};\nexport class NoopSVGAnalyzer {\n  public isStandardSvgAttribute(_node: INode, _attributeName: string): boolean {\n    return false;\n  }\n}\n\nexport class SVGAnalyzer {\n  public static register(container: IContainer): void {\n    container.register(\n      singletonRegistration(this, this),\n      aliasRegistration(this, ISVGAnalyzer)\n    );\n  }\n\n  /** @internal */\n  private readonly _svgElements: Record<string, Record<string, true | undefined> | undefined> = objectAssign(createLookup<Record<string, true | undefined> | undefined>(), {\n    'a':                    o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures style systemLanguage target transform xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'altGlyph':             o('class dx dy externalResourcesRequired format glyphRef id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures rotate style systemLanguage x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'altglyph':             createLookup<true | undefined>(),\n    'altGlyphDef':          o('id xml:base xml:lang xml:space'),\n    'altglyphdef':          createLookup<true | undefined>(),\n    'altGlyphItem':         o('id xml:base xml:lang xml:space'),\n    'altglyphitem':         createLookup<true | undefined>(),\n    'animate':              o('accumulate additive attributeName attributeType begin by calcMode dur end externalResourcesRequired fill from id keySplines keyTimes max min onbegin onend onload onrepeat repeatCount repeatDur requiredExtensions requiredFeatures restart systemLanguage to values xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'animateColor':         o('accumulate additive attributeName attributeType begin by calcMode dur end externalResourcesRequired fill from id keySplines keyTimes max min onbegin onend onload onrepeat repeatCount repeatDur requiredExtensions requiredFeatures restart systemLanguage to values xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'animateMotion':        o('accumulate additive begin by calcMode dur end externalResourcesRequired fill from id keyPoints keySplines keyTimes max min onbegin onend onload onrepeat origin path repeatCount repeatDur requiredExtensions requiredFeatures restart rotate systemLanguage to values xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'animateTransform':     o('accumulate additive attributeName attributeType begin by calcMode dur end externalResourcesRequired fill from id keySplines keyTimes max min onbegin onend onload onrepeat repeatCount repeatDur requiredExtensions requiredFeatures restart systemLanguage to type values xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'circle':               o('class cx cy externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup r requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'clipPath':             o('class clipPathUnits externalResourcesRequired id requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'color-profile':        o('id local name rendering-intent xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'cursor':               o('externalResourcesRequired id requiredExtensions requiredFeatures systemLanguage x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'defs':                 o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'desc':                 o('class id style xml:base xml:lang xml:space'),\n    'ellipse':              o('class cx cy externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures rx ry style systemLanguage transform xml:base xml:lang xml:space'),\n    'feBlend':              o('class height id in in2 mode result style width x xml:base xml:lang xml:space y'),\n    'feColorMatrix':        o('class height id in result style type values width x xml:base xml:lang xml:space y'),\n    'feComponentTransfer':  o('class height id in result style width x xml:base xml:lang xml:space y'),\n    'feComposite':          o('class height id in in2 k1 k2 k3 k4 operator result style width x xml:base xml:lang xml:space y'),\n    'feConvolveMatrix':     o('bias class divisor edgeMode height id in kernelMatrix kernelUnitLength order preserveAlpha result style targetX targetY width x xml:base xml:lang xml:space y'),\n    'feDiffuseLighting':    o('class diffuseConstant height id in kernelUnitLength result style surfaceScale width x xml:base xml:lang xml:space y'),\n    'feDisplacementMap':    o('class height id in in2 result scale style width x xChannelSelector xml:base xml:lang xml:space y yChannelSelector'),\n    'feDistantLight':       o('azimuth elevation id xml:base xml:lang xml:space'),\n    'feFlood':              o('class height id result style width x xml:base xml:lang xml:space y'),\n    'feFuncA':              o('amplitude exponent id intercept offset slope tableValues type xml:base xml:lang xml:space'),\n    'feFuncB':              o('amplitude exponent id intercept offset slope tableValues type xml:base xml:lang xml:space'),\n    'feFuncG':              o('amplitude exponent id intercept offset slope tableValues type xml:base xml:lang xml:space'),\n    'feFuncR':              o('amplitude exponent id intercept offset slope tableValues type xml:base xml:lang xml:space'),\n    'feGaussianBlur':       o('class height id in result stdDeviation style width x xml:base xml:lang xml:space y'),\n    'feImage':              o('class externalResourcesRequired height id preserveAspectRatio result style width x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'feMerge':              o('class height id result style width x xml:base xml:lang xml:space y'),\n    'feMergeNode':          o('id xml:base xml:lang xml:space'),\n    'feMorphology':         o('class height id in operator radius result style width x xml:base xml:lang xml:space y'),\n    'feOffset':             o('class dx dy height id in result style width x xml:base xml:lang xml:space y'),\n    'fePointLight':         o('id x xml:base xml:lang xml:space y z'),\n    'feSpecularLighting':   o('class height id in kernelUnitLength result specularConstant specularExponent style surfaceScale width x xml:base xml:lang xml:space y'),\n    'feSpotLight':          o('id limitingConeAngle pointsAtX pointsAtY pointsAtZ specularExponent x xml:base xml:lang xml:space y z'),\n    'feTile':               o('class height id in result style width x xml:base xml:lang xml:space y'),\n    'feTurbulence':         o('baseFrequency class height id numOctaves result seed stitchTiles style type width x xml:base xml:lang xml:space y'),\n    'filter':               o('class externalResourcesRequired filterRes filterUnits height id primitiveUnits style width x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'font':                 o('class externalResourcesRequired horiz-adv-x horiz-origin-x horiz-origin-y id style vert-adv-y vert-origin-x vert-origin-y xml:base xml:lang xml:space'),\n    'font-face':            o('accent-height alphabetic ascent bbox cap-height descent font-family font-size font-stretch font-style font-variant font-weight hanging id ideographic mathematical overline-position overline-thickness panose-1 slope stemh stemv strikethrough-position strikethrough-thickness underline-position underline-thickness unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical widths x-height xml:base xml:lang xml:space'),\n    'font-face-format':     o('id string xml:base xml:lang xml:space'),\n    'font-face-name':       o('id name xml:base xml:lang xml:space'),\n    'font-face-src':        o('id xml:base xml:lang xml:space'),\n    'font-face-uri':        o('id xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'foreignObject':        o('class externalResourcesRequired height id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures style systemLanguage transform width x xml:base xml:lang xml:space y'),\n    'g':                    o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'glyph':                o('arabic-form class d glyph-name horiz-adv-x id lang orientation style unicode vert-adv-y vert-origin-x vert-origin-y xml:base xml:lang xml:space'),\n    'glyphRef':             o('class dx dy format glyphRef id style x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'glyphref':             createLookup<true | undefined>(),\n    'hkern':                o('g1 g2 id k u1 u2 xml:base xml:lang xml:space'),\n    'image':                o('class externalResourcesRequired height id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup preserveAspectRatio requiredExtensions requiredFeatures style systemLanguage transform width x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'line':                 o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures style systemLanguage transform x1 x2 xml:base xml:lang xml:space y1 y2'),\n    'linearGradient':       o('class externalResourcesRequired gradientTransform gradientUnits id spreadMethod style x1 x2 xlink:arcrole xlink:href xlink:role xlink:title xlink:type xml:base xml:lang xml:space y1 y2'),\n    'marker':               o('class externalResourcesRequired id markerHeight markerUnits markerWidth orient preserveAspectRatio refX refY style viewBox xml:base xml:lang xml:space'),\n    'mask':                 o('class externalResourcesRequired height id maskContentUnits maskUnits requiredExtensions requiredFeatures style systemLanguage width x xml:base xml:lang xml:space y'),\n    'metadata':             o('id xml:base xml:lang xml:space'),\n    'missing-glyph':        o('class d horiz-adv-x id style vert-adv-y vert-origin-x vert-origin-y xml:base xml:lang xml:space'),\n    'mpath':                o('externalResourcesRequired id xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'path':                 o('class d externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup pathLength requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'pattern':              o('class externalResourcesRequired height id patternContentUnits patternTransform patternUnits preserveAspectRatio requiredExtensions requiredFeatures style systemLanguage viewBox width x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'polygon':              o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup points requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'polyline':             o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup points requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'radialGradient':       o('class cx cy externalResourcesRequired fx fy gradientTransform gradientUnits id r spreadMethod style xlink:arcrole xlink:href xlink:role xlink:title xlink:type xml:base xml:lang xml:space'),\n    'rect':                 o('class externalResourcesRequired height id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures rx ry style systemLanguage transform width x xml:base xml:lang xml:space y'),\n    'script':               o('externalResourcesRequired id type xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'set':                  o('attributeName attributeType begin dur end externalResourcesRequired fill id max min onbegin onend onload onrepeat repeatCount repeatDur requiredExtensions requiredFeatures restart systemLanguage to xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'stop':                 o('class id offset style xml:base xml:lang xml:space'),\n    'style':                o('id media title type xml:base xml:lang xml:space'),\n    'svg':                  o('baseProfile class contentScriptType contentStyleType externalResourcesRequired height id onabort onactivate onclick onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onresize onscroll onunload onzoom preserveAspectRatio requiredExtensions requiredFeatures style systemLanguage version viewBox width x xml:base xml:lang xml:space y zoomAndPan'),\n    'switch':               o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'symbol':               o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup preserveAspectRatio style viewBox xml:base xml:lang xml:space'),\n    'text':                 o('class dx dy externalResourcesRequired id lengthAdjust onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures rotate style systemLanguage textLength transform x xml:base xml:lang xml:space y'),\n    'textPath':             o('class externalResourcesRequired id lengthAdjust method onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures spacing startOffset style systemLanguage textLength xlink:arcrole xlink:href xlink:role xlink:title xlink:type xml:base xml:lang xml:space'),\n    'title':                o('class id style xml:base xml:lang xml:space'),\n    'tref':                 o('class dx dy externalResourcesRequired id lengthAdjust onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures rotate style systemLanguage textLength x xlink:arcrole xlink:href xlink:role xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'tspan':                o('class dx dy externalResourcesRequired id lengthAdjust onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures rotate style systemLanguage textLength x xml:base xml:lang xml:space y'),\n    'use':                  o('class externalResourcesRequired height id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures style systemLanguage transform width x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'view':                 o('externalResourcesRequired id preserveAspectRatio viewBox viewTarget xml:base xml:lang xml:space zoomAndPan'),\n    'vkern':                o('g1 g2 id k u1 u2 xml:base xml:lang xml:space'),\n  });\n\n  /** @internal */\n  private readonly _svgPresentationElements = o('a altGlyph animate animateColor circle clipPath defs ellipse feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feFlood feGaussianBlur feImage feMerge feMorphology feOffset feSpecularLighting feTile feTurbulence filter font foreignObject g glyph glyphRef image line linearGradient marker mask missing-glyph path pattern polygon polyline radialGradient rect stop svg switch symbol text textPath tref tspan use');\n\n  /** @internal */\n  private readonly _svgPresentationAttributes = o('alignment-baseline baseline-shift clip-path clip-rule clip color-interpolation-filters color-interpolation color-profile color-rendering color cursor direction display dominant-baseline enable-background fill-opacity fill-rule fill filter flood-color flood-opacity font-family font-size-adjust font-size font-stretch font-style font-variant font-weight glyph-orientation-horizontal glyph-orientation-vertical image-rendering kerning letter-spacing lighting-color marker-end marker-mid marker-start mask opacity overflow pointer-events shape-rendering stop-color stop-opacity stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width stroke text-anchor text-decoration text-rendering unicode-bidi visibility word-spacing writing-mode');\n\n  /** @internal */\n  private readonly SVGElement: typeof SVGElement;\n  public constructor() {\n    const platform = resolve(IPlatform);\n    this.SVGElement = platform.globalThis.SVGElement;\n\n    const div = platform.document.createElement('div');\n    div.innerHTML = '<svg><altGlyph /></svg>';\n    if (div.firstElementChild!.nodeName === 'altglyph') {\n      // handle chrome casing inconsistencies.\n      const svg = this._svgElements;\n      let tmp = svg.altGlyph;\n      svg.altGlyph = svg.altglyph;\n      svg.altglyph = tmp;\n      tmp = svg.altGlyphDef;\n      svg.altGlyphDef = svg.altglyphdef;\n      svg.altglyphdef = tmp;\n      tmp = svg.altGlyphItem;\n      svg.altGlyphItem = svg.altglyphitem;\n      svg.altglyphitem = tmp;\n      tmp = svg.glyphRef;\n      svg.glyphRef = svg.glyphref;\n      svg.glyphref = tmp;\n    }\n  }\n\n  public isStandardSvgAttribute(node: INode, attributeName: string): boolean {\n    if (!(node instanceof this.SVGElement)) {\n      return false;\n    }\n\n    return (\n      this._svgPresentationElements[node.nodeName] === true && this._svgPresentationAttributes[attributeName] === true ||\n      this._svgElements[node.nodeName]?.[attributeName] === true\n    );\n  }\n}\n", "import { isDataAttribute } from '../utilities';\nimport { ISVGAnalyzer } from '../observation/svg-analyzer';\nimport { createLookup, createImplementationRegister, resolve } from '@aurelia/kernel';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { IAttrMapper, type IsTwoWayPredicate } from '@aurelia/template-compiler';\n\nexport class AttrMapper implements IAttrMapper {\n  public static register = /*@__PURE__*/ createImplementationRegister(IAttrMapper);\n\n  /** @internal */ private readonly fns: IsTwoWayPredicate[] = [];\n  /** @internal */ private readonly _tagAttrMap: Record<string, Record<string, PropertyKey>> = createLookup();\n  /** @internal */ private readonly _globalAttrMap: Record<string, PropertyKey> = createLookup();\n  private readonly svg = resolve(ISVGAnalyzer);\n\n  public constructor() {\n    this.useMapping({\n      LABEL: { for: 'htmlFor' },\n      IMG: { usemap: 'useMap' },\n      INPUT: {\n        maxlength: 'maxLength',\n        minlength: 'minLength',\n        formaction: 'formAction',\n        formenctype: 'formEncType',\n        formmethod: 'formMethod',\n        formnovalidate: 'formNoValidate',\n        formtarget: 'formTarget',\n        inputmode: 'inputMode',\n      },\n      TEXTAREA: { maxlength: 'maxLength' },\n      TD: { rowspan: 'rowSpan', colspan: 'colSpan' },\n      TH: { rowspan: 'rowSpan', colspan: 'colSpan' },\n    });\n    this.useGlobalMapping({\n      accesskey: 'accessKey',\n      contenteditable: 'contentEditable',\n      tabindex: 'tabIndex',\n      textcontent: 'textContent',\n      innerhtml: 'innerHTML',\n      scrolltop: 'scrollTop',\n      scrollleft: 'scrollLeft',\n      readonly: 'readOnly',\n    });\n  }\n\n  /**\n   * Allow application to teach Aurelia how to define how to map attributes to properties\n   * based on element tagName\n   */\n  public useMapping(config: Record<string, Record<string, PropertyKey>>): void {\n    let newAttrMapping: Record<string, PropertyKey>;\n    let targetAttrMapping: Record<string, PropertyKey>;\n    let tagName: string;\n    let attr: string;\n    for (tagName in config) {\n      newAttrMapping = config[tagName];\n      targetAttrMapping = this._tagAttrMap[tagName] ??= createLookup();\n      for (attr in newAttrMapping) {\n        if (targetAttrMapping[attr] !== void 0) {\n          throw createError(attr, tagName);\n        }\n        targetAttrMapping[attr] = newAttrMapping[attr];\n      }\n    }\n  }\n\n  /**\n   * Allow applications to teach Aurelia how to define how to map attributes to properties\n   * for all elements\n   */\n  public useGlobalMapping(config: Record<string, PropertyKey>): void {\n    const mapper = this._globalAttrMap;\n    for (const attr in config) {\n      if (mapper[attr] !== void 0) {\n        throw createError(attr, '*');\n      }\n      mapper[attr] = config[attr];\n    }\n  }\n\n  /**\n   * Add a given function to a list of fns that will be used\n   * to check if `'bind'` command can be understood as `'two-way'` command.\n   */\n  public useTwoWay(fn: IsTwoWayPredicate): void {\n    this.fns.push(fn);\n  }\n\n  /**\n   * Returns true if an attribute should be two way bound based on an element\n   */\n  public isTwoWay(node: Element, attrName: string): boolean {\n    return shouldDefaultToTwoWay(node, attrName)\n      || this.fns.length > 0 && this.fns.some(fn => fn(node, attrName));\n  }\n\n  /**\n   * Retrieves the mapping information this mapper have for an attribute on an element\n   */\n  public map(node: Element, attr: string): string | null {\n    return this._tagAttrMap[node.nodeName]?.[attr] as string\n      ?? this._globalAttrMap[attr]\n      ?? (isDataAttribute(node, attr, this.svg)\n        ? attr\n        : null);\n  }\n}\n\nfunction shouldDefaultToTwoWay(element: Element, attr: string): boolean {\n  switch (element.nodeName) {\n    case 'INPUT':\n      switch ((element as HTMLInputElement).type) {\n        case 'checkbox':\n        case 'radio':\n          return attr === 'checked';\n        // note:\n        // ideally, it should check for corresponding input type first\n        // as 'files' shouldn't be two way on a number input, for example\n        // but doing it this way is acceptable-ish, as the common user expectations,\n        // and the behavior of the control for these properties are the same,\n        // regardless the type of the <input>\n        default:\n          return attr === 'value' || attr === 'files' || attr === 'value-as-number' || attr === 'value-as-date';\n      }\n    case 'TEXTAREA':\n    case 'SELECT':\n      return attr === 'value';\n    default:\n      switch (attr) {\n        case 'textcontent':\n        case 'innerhtml':\n          return element.hasAttribute('contenteditable');\n        case 'scrolltop':\n        case 'scrollleft':\n          return true;\n        default:\n          return false;\n      }\n  }\n}\n\nfunction createError(attr: string, tagName: string) {\n  return createMappedError(ErrorNames.compiler_attr_mapper_duplicate_mapping, attr, tagName);\n}\n", "import {\n  createLookup,\n  createImplementationRegister,\n  type IContainer,\n  type IRegistry\n} from '@aurelia/kernel';\nimport {\n  type IAttributeBindablesInfo,\n  type IElementBindablesInfo,\n  IResourceResolver,\n  TemplateCompiler,\n} from '@aurelia/template-compiler';\nimport { BindableDefinition } from '../bindable';\nimport { defaultMode } from '../binding/interfaces-bindings';\nimport { CustomAttribute } from '../resources/custom-attribute';\nimport { CustomElement, CustomElementDefinition } from '../resources/custom-element';\n\nimport { ErrorNames, createMappedError } from '../errors';\nimport type { CustomAttributeDefinition } from '../resources/custom-attribute';\nimport { AttrMapper } from './attribute-mapper';\n\n/**\n * A group of registrations to connect the template compiler with the aurelia runtime implementation\n */\nexport const RuntimeTemplateCompilerImplementation: IRegistry = {\n  register(container) {\n    container.register(\n      TemplateCompiler,\n      AttrMapper,\n      ResourceResolver,\n    );\n  }\n};\n\nclass BindablesInfo {\n  public constructor(\n    public readonly attrs: Record<string, BindableDefinition>,\n    public readonly bindables: Record<string, BindableDefinition>,\n    public readonly primary: BindableDefinition | null,\n  ) {}\n}\n\nclass ResourceResolver implements IResourceResolver<CustomElementDefinition, CustomAttributeDefinition> {\n  public static register = /*@__PURE__*/ createImplementationRegister(IResourceResolver);\n\n  /** @internal */\n  private readonly _resourceCache = new WeakMap<IContainer, RecordCache>();\n\n  public el(c: IContainer, name: string): CustomElementDefinition | null {\n    let record = this._resourceCache.get(c);\n    if (record == null) {\n      this._resourceCache.set(c, record = new RecordCache());\n    }\n    return name in record._element ? record._element[name] : (record._element[name] = CustomElement.find(c, name));\n  }\n\n  public attr(c: IContainer, name: string): CustomAttributeDefinition | null {\n    let record = this._resourceCache.get(c);\n    if (record == null) {\n      this._resourceCache.set(c, record = new RecordCache());\n    }\n    return name in record._attr ? record._attr[name] : (record._attr[name] = CustomAttribute.find(c, name));\n  }\n\n  /** @internal */\n  private readonly _bindableCache = new WeakMap<CustomElementDefinition | CustomAttributeDefinition, BindablesInfo>();\n\n  public bindables(def: CustomAttributeDefinition): IAttributeBindablesInfo;\n  public bindables(def: CustomElementDefinition): IElementBindablesInfo;\n  public bindables(def: CustomAttributeDefinition | CustomElementDefinition): IAttributeBindablesInfo | IElementBindablesInfo {\n    let info = this._bindableCache.get(def);\n    if (info == null) {\n      const bindables = def.bindables;\n      const attrs = createLookup<BindableDefinition>();\n      let bindable: BindableDefinition | undefined;\n      let prop: string;\n      let hasPrimary: boolean = false;\n      let primary: BindableDefinition | undefined;\n      let attr: string;\n\n      // from all bindables, pick the first primary bindable\n      // if there is no primary, pick the first bindable\n      // if there's no bindables, create a new primary with property value\n      for (prop in bindables) {\n        bindable = bindables[prop];\n        attr = bindable.attribute;\n        if (bindable.primary === true) {\n          if (hasPrimary) {\n            throw createMappedError(ErrorNames.compiler_primary_already_existed, def);\n          }\n          hasPrimary = true;\n          primary = bindable;\n        } else if (!hasPrimary && primary == null) {\n          primary = bindable;\n        }\n\n        attrs[attr] = BindableDefinition.create(prop, bindable);\n      }\n      if (bindable == null && def.type === 'custom-attribute') {\n        // if no bindables are present, default to \"value\"\n        primary = attrs.value = BindableDefinition.create(\n          'value',\n          { mode: def.defaultBindingMode ?? defaultMode }\n        );\n      }\n\n      this._bindableCache.set(def, info = new BindablesInfo(attrs, bindables, primary ?? null));\n    }\n    return info;\n  }\n}\n\nclass RecordCache {\n  public _element = createLookup<CustomElementDefinition | null>();\n  public _attr = createLookup<CustomAttributeDefinition | null>();\n}\n", "import { createLookup } from '@aurelia/kernel';\nimport { atLayout, atNode } from '../utilities';\n\nimport type { AccessorType, IAccessor } from '@aurelia/runtime';\nimport { mixinNoopSubscribable } from './observation-utils';\n\nconst nsMap: Record<string, AttributeNSAccessor> = createLookup();\n\n/**\n * Attribute accessor in a XML document/element that can be accessed via a namespace.\n * Wraps [`getAttributeNS`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNS).\n */\nexport class AttributeNSAccessor implements IAccessor<string | null> {\n  static {\n    mixinNoopSubscribable(AttributeNSAccessor);\n  }\n\n  public static forNs(ns: string): AttributeNSAccessor {\n    return nsMap[ns] ??= new AttributeNSAccessor(ns);\n  }\n\n  // ObserverType.Layout is not always true, it depends on the property\n  // but for simplicity, always treat as such\n  public type: AccessorType = (atNode | atLayout) as AccessorType;\n\n  public constructor(\n    /**\n     * The namespace associated with this accessor\n     */\n    public readonly ns: string,\n  ) {\n  }\n\n  public getValue(obj: HTMLElement, propertyKey: string): string | null {\n    return obj.getAttributeNS(this.ns, propertyKey);\n  }\n\n  public setValue(newValue: string | null, obj: HTMLElement, key: string): void {\n    if (newValue == null) {\n      obj.removeAttributeNS(this.ns, key);\n    } else {\n      obj.setAttributeNS(this.ns, key, newValue);\n    }\n  }\n}\n", "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { IObserver, type AccessorType, type IAccessor, type PropertyAccessor } from '@aurelia/runtime';\nimport { mixinNoopSubscribable } from './observation-utils';\nimport { atLayout, atNode } from '../utilities';\n\n/**\n * Attribute accessor for HTML elements.\n * Note that Aurelia works with properties, so in all case it will try to assign to property instead of attributes.\n * Unless the property falls into a special set, then it will use attribute for it.\n *\n * @see PropertyAccessor\n */\nexport class DataAttributeAccessor implements IAccessor<string | null>, IObserver {\n  static {\n    mixinNoopSubscribable(DataAttributeAccessor);\n  }\n\n  // ObserverType.Layout is not always true, it depends on the property\n  // but for simplicity, always treat as such\n  public type: AccessorType = (atNode | atLayout) as AccessorType;\n\n  // the followings come from the noop mixing\n  public subscribe!: () => void;\n  public unsubscribe!: () => void;\n\n  public getValue(obj: HTMLElement, key: string): string | null {\n    return obj.getAttribute(key);\n  }\n\n  public setValue(newValue: string | null, obj: HTMLElement, key: string): void {\n    if (newValue == null) {\n      obj.removeAttribute(key);\n    } else {\n      obj.setAttribute(key, newValue);\n    }\n  }\n}\n\nexport const attrAccessor = /*@__PURE__*/new DataAttributeAccessor();\n", "import {\n  subscriberCollection,\n  type AccessorType,\n  type ICollectionObserver,\n  type IObserverLocator,\n  type ISubscriberCollection,\n} from '@aurelia/runtime';\n\nimport type { INode } from '../dom';\nimport { atLayout, atNode, atObserver, hasOwnProperty } from '../utilities';\nimport { INodeObserver, INodeObserverConfigBase } from './observer-locator';\nimport { mixinNodeObserverUseConfig } from './observation-utils';\nimport { createMutationObserver } from '../utilities-dom';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { isArray } from '@aurelia/kernel';\n\nexport interface ISelectElement extends HTMLSelectElement {\n  options: HTMLCollectionOf<IOptionElement> & Pick<HTMLOptionsCollection, 'length' | 'selectedIndex' | 'add' | 'remove'>;\n  matcher?: (a: unknown, b: unknown) => boolean;\n}\nexport interface IOptionElement extends HTMLOptionElement {\n  model?: unknown;\n}\n\nexport interface SelectValueObserver extends ISubscriberCollection {}\n\nexport class SelectValueObserver implements INodeObserver {\n  static {\n    mixinNodeObserverUseConfig(SelectValueObserver);\n    subscriberCollection(SelectValueObserver, null!);\n  }\n\n  /** @internal */\n  private static _getSelectedOptions(options: ArrayLike<IOptionElement>): unknown[] {\n    const selection: unknown[] = [];\n    if (options.length === 0) {\n      return selection;\n    }\n    const ii = options.length;\n    let i = 0;\n    let option: IOptionElement;\n    while (ii > i) {\n      option = options[i];\n      if (option.selected) {\n        selection[selection.length] = hasOwnProperty.call(option, 'model') ? option.model : option.value;\n      }\n      ++i;\n    }\n    return selection;\n  }\n\n  /** @internal */\n  private static _defaultMatcher(a: unknown, b: unknown): boolean {\n    return a === b;\n  }\n\n  // ObserverType.Layout is not always true\n  // but for simplicity, always treat as such\n  public type: AccessorType = (atNode | atObserver | atLayout) as AccessorType;\n\n  /** @internal */\n  private _value: unknown = void 0;\n\n  /** @internal */\n  private _oldValue: unknown = void 0;\n\n  /** @internal */\n  public readonly _el: ISelectElement;\n\n  /** @internal */\n  private _hasChanges: boolean = false;\n  /** @internal */\n  private _arrayObserver?: ICollectionObserver<'array'> = void 0;\n  /** @internal */\n  private _nodeObserver?: MutationObserver = void 0;\n\n  /** @internal */\n  private _observing: boolean = false;\n\n  /** @internal */\n  private readonly _observerLocator: IObserverLocator;\n\n  /**\n   * Used by mixing defined methods subscribe/unsubscribe\n   *\n   * @internal\n   */\n  public _listened: boolean = false;\n\n  /** @internal */\n  public _config: INodeObserverConfigBase;\n\n  /**\n   * Comes from mixin\n   */\n  public useConfig!: (config: INodeObserverConfigBase) => void;\n\n  public constructor(\n    obj: INode,\n    // deepscan-disable-next-line\n    _key: PropertyKey,\n    config: INodeObserverConfigBase,\n    observerLocator: IObserverLocator,\n  ) {\n    this._el = obj as ISelectElement;\n    this._observerLocator = observerLocator;\n    this._config = config;\n  }\n\n  public getValue(): unknown {\n    // is it safe to assume the observer has the latest value?\n    // todo: ability to turn on/off cache based on type\n    return this._observing\n      ? this._value\n      : this._el.multiple\n        // todo: maybe avoid double iteration?\n        ? SelectValueObserver._getSelectedOptions(this._el.options)\n        : this._el.value;\n  }\n\n  public setValue(newValue: unknown): void {\n    this._oldValue = this._value;\n    this._value = newValue;\n    this._hasChanges = newValue !== this._oldValue;\n    this._observeArray(newValue instanceof Array ? newValue : null);\n    this._flushChanges();\n  }\n\n  /** @internal */\n  private _flushChanges(): void {\n    if (this._hasChanges) {\n      this._hasChanges = false;\n      this.syncOptions();\n    }\n  }\n\n  public handleCollectionChange(): void {\n    // always sync \"selected\" property of <options/>\n    // immediately whenever the array notifies its mutation\n    this.syncOptions();\n  }\n\n  public syncOptions(): void {\n    const value = this._value;\n    const obj = this._el;\n    const $isArray = isArray(value);\n    const matcher = obj.matcher ?? SelectValueObserver._defaultMatcher;\n    const options = obj.options;\n    let i = options.length;\n\n    while (i-- > 0) {\n      const option = options[i];\n      const optionValue = hasOwnProperty.call(option, 'model') ? option.model : option.value;\n      if ($isArray) {\n        option.selected = value.findIndex(item => !!matcher(optionValue, item)) !== -1;\n        continue;\n      }\n      option.selected = !!matcher(optionValue, value);\n    }\n  }\n\n  public syncValue(): boolean {\n    // Spec for synchronizing value from `<select/>`  to `SelectObserver`\n    // When synchronizing value to observed <select/> element, do the following steps:\n    // A. If `<select/>` is multiple\n    //    1. Check if current value, called `currentValue` is an array\n    //      a. If not an array, return true to signal value has changed\n    //      b. If is an array:\n    //        i. gather all current selected <option/>, in to array called `values`\n    //        ii. loop through the `currentValue` array and remove items that are nolonger selected based on matcher\n    //        iii. loop through the `values` array and add items that are selected based on matcher\n    //        iv. Return false to signal value hasn't changed\n    // B. If the select is single\n    //    1. Let `value` equal the first selected option, if no option selected, then `value` is `null`\n    //    2. assign `this.currentValue` to `this.oldValue`\n    //    3. assign `value` to `this.currentValue`\n    //    4. return `true` to signal value has changed\n    const obj = this._el;\n    const options = obj.options;\n    const len = options.length;\n    const currentValue = this._value;\n    let i = 0;\n\n    if (obj.multiple) {\n      // A.\n      if (!(currentValue instanceof Array)) {\n        // A.1.a\n        return true;\n      }\n      // A.1.b\n      // multi select\n      let option: IOptionElement;\n      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n      const matcher = obj.matcher || SelectValueObserver._defaultMatcher;\n      // A.1.b.i\n      const values: unknown[] = [];\n      while (i < len) {\n        option = options[i];\n        if (option.selected) {\n          values.push(hasOwnProperty.call(option, 'model')\n            ? option.model\n            : option.value\n          );\n        }\n        ++i;\n      }\n      let a: unknown;\n      // A.1.b.ii\n      i = 0;\n      while (i < currentValue.length) {\n        a = currentValue[i];\n        // Todo: remove arrow fn\n        if (values.findIndex(b => !!matcher(a, b)) === -1) {\n          currentValue.splice(i, 1);\n        } else {\n          ++i;\n        }\n      }\n      // A.1.b.iii\n      i = 0;\n      while (i < values.length) {\n        a = values[i];\n        // Todo: remove arrow fn\n        if (currentValue.findIndex(b => !!matcher(a, b)) === -1) {\n          currentValue.push(a);\n        }\n        ++i;\n      }\n      // A.1.b.iv\n      return false;\n    }\n    // B. single select\n    // B.1\n    let value: unknown = null;\n    let option: IOptionElement;\n    while (i < len) {\n      option = options[i];\n      if (option.selected) {\n        value = hasOwnProperty.call(option, 'model')\n          ? option.model\n          : option.value;\n        break;\n      }\n      ++i;\n    }\n    // B.2\n    this._oldValue = this._value;\n    // B.3\n    this._value = value;\n    // B.4\n    return true;\n  }\n\n  /**\n   * Used by mixing defined methods subscribe\n   *\n   * @internal\n   */\n  public _start(): void {\n    (this._nodeObserver = createMutationObserver(this._el, this._handleNodeChange.bind(this))).observe(this._el, {\n      childList: true,\n      subtree: true,\n      characterData: true\n    });\n    this._observeArray(this._value instanceof Array ? this._value : null);\n    this._observing = true;\n  }\n\n  /**\n   * Used by mixing defined method unsubscribe\n   *\n   * @internal\n   */\n  public _stop(): void {\n    this._nodeObserver!.disconnect();\n    this._arrayObserver?.unsubscribe(this);\n    this._nodeObserver\n      = this._arrayObserver\n      = void 0;\n    this._observing = false;\n  }\n\n  // todo: observe all kind of collection\n  /** @internal */\n  private _observeArray(array: unknown[] | null): void {\n    this._arrayObserver?.unsubscribe(this);\n    this._arrayObserver = void 0;\n    if (array != null) {\n      if (!this._el.multiple) {\n        throw createMappedError(ErrorNames.select_observer_array_on_non_multi_select);\n      }\n      (this._arrayObserver = this._observerLocator.getArrayObserver(array)).subscribe(this);\n    }\n  }\n\n  public handleEvent(): void {\n    const shouldNotify = this.syncValue();\n    if (shouldNotify) {\n      this._flush();\n    }\n  }\n\n  /** @internal */\n  private _handleNodeChange(_records: MutationRecord[]): void {\n    // syncing options first means forcing the UI to take the existing state from the model\n    // example: if existing state has only 3 selected option\n    //          and it's adding a 4th <option/> with selected state\n    //          [selected] state will be disregarded as it's not present in the model\n    //          this force uni-direction flow: where UI update is only via user event, or model changes\n    //          Cons:\n    //          Sometimes, an <option selected /> maybe added to the UI, and causes confusion, as it's not selected anymore after the sync\n    //          Consider this before entering release candidate\n    this.syncOptions();\n    const shouldNotify = this.syncValue();\n    if (shouldNotify) {\n      this._flush();\n    }\n  }\n\n  /** @internal */\n  private _flush(): void {\n    const oV = this._oldValue;\n    this._oldValue = this._value;\n    this.subs.notify(this._value, oV);\n  }\n}\n", "import { emptyArray, kebabCase, isFunction, isString } from '@aurelia/kernel';\nimport { atLayout, atNode, hasOwnProperty } from '../utilities';\nimport type { AccessorType, IAccessor } from '@aurelia/runtime';\nimport { mixinNoopSubscribable } from './observation-utils';\n\nconst customPropertyPrefix: string = '--';\n\nexport class StyleAttributeAccessor implements IAccessor {\n  static {\n    mixinNoopSubscribable(StyleAttributeAccessor);\n  }\n\n  public type: AccessorType = (atNode | atLayout) as AccessorType;\n\n  /** @internal */\n  private _value: unknown = '';\n\n  /** @internal */\n  private _oldValue: unknown = '';\n\n  public styles: Record<string, number> = {};\n  public version: number = 0;\n\n  /** @internal */\n  private _hasChanges: boolean = false;\n\n  public constructor(\n    public readonly obj: HTMLElement,\n  ) {\n  }\n\n  public getValue(): string {\n    return this.obj.style.cssText;\n  }\n\n  public setValue(newValue: unknown): void {\n    this._value = newValue;\n    this._hasChanges = newValue !== this._oldValue;\n    this._flushChanges();\n  }\n\n  /** @internal */\n  private _getStyleTuplesFromString(currentValue: string): [string, string][] {\n    const styleTuples: [string, string][] = [];\n    const urlRegexTester = /url\\([^)]+$/;\n    let offset = 0;\n    let currentChunk = '';\n    let nextSplit: number;\n    let indexOfColon: number;\n    let attribute: string;\n    let value: string;\n    while (offset < currentValue.length) {\n      nextSplit = currentValue.indexOf(';', offset);\n      if (nextSplit === -1) { nextSplit = currentValue.length; }\n      currentChunk += currentValue.substring(offset, nextSplit);\n      offset = nextSplit + 1;\n\n      // Make sure we never split a url so advance to next\n      if (urlRegexTester.test(currentChunk)) {\n        currentChunk += ';';\n        continue;\n      }\n\n      indexOfColon = currentChunk.indexOf(':');\n      attribute = currentChunk.substring(0, indexOfColon).trim();\n      value = currentChunk.substring(indexOfColon + 1).trim();\n      styleTuples.push([attribute, value]);\n      currentChunk = '';\n    }\n\n    return styleTuples;\n  }\n\n  /** @internal */\n  private _getStyleTuplesFromObject(currentValue: Record<string, unknown>): [string, string][] {\n    let value: unknown;\n    let property: string;\n    const styles: [string, string][] = [];\n    for (property in currentValue) {\n      value = currentValue[property];\n      if (value == null) {\n        continue;\n      }\n      if (isString(value)) {\n        // Custom properties should not be tampered with\n        if (property.startsWith(customPropertyPrefix)) {\n          styles.push([property, value]);\n          continue;\n        }\n        styles.push([kebabCase(property), value]);\n        continue;\n      }\n\n      styles.push(...this._getStyleTuples(value));\n    }\n\n    return styles;\n  }\n\n  /** @internal */\n  private _getStyleTuplesFromArray(currentValue: unknown[]): [string, string][] {\n    const len = currentValue.length;\n    if (len > 0) {\n      const styles: [string, string][] = [];\n      let i = 0;\n      for (; len > i; ++i) {\n        styles.push(...this._getStyleTuples(currentValue[i]));\n      }\n      return styles;\n    }\n    return emptyArray;\n  }\n\n  /** @internal */\n  private _getStyleTuples(currentValue: unknown): [string, string][] {\n    if (isString(currentValue)) {\n      return this._getStyleTuplesFromString(currentValue);\n    }\n\n    if (currentValue instanceof Array) {\n      return this._getStyleTuplesFromArray(currentValue);\n    }\n\n    if (currentValue instanceof Object) {\n      return this._getStyleTuplesFromObject(currentValue as Record<string, unknown>);\n    }\n\n    return emptyArray;\n  }\n\n  /** @internal */\n  private _flushChanges(): void {\n    if (this._hasChanges) {\n      this._hasChanges = false;\n      const currentValue = this._value;\n      const styles = this.styles;\n      const styleTuples = this._getStyleTuples(currentValue);\n\n      let style: string;\n      let version = this.version;\n\n      this._oldValue = currentValue;\n\n      let tuple: [string, string];\n      let name: string;\n      let value: string;\n      let i = 0;\n      const len = styleTuples.length;\n      for (; i < len; ++i) {\n        tuple = styleTuples[i];\n        name = tuple[0];\n        value = tuple[1];\n        this.setProperty(name, value);\n        styles[name] = version;\n      }\n\n      this.styles = styles;\n      this.version += 1;\n      if (version === 0) {\n        return;\n      }\n\n      version -= 1;\n      for (style in styles) {\n        if (!hasOwnProperty.call(styles, style) || styles[style] !== version) {\n          continue;\n        }\n        this.obj.style.removeProperty(style);\n      }\n    }\n  }\n\n  public setProperty(style: string, value: string): void {\n    let priority = '';\n\n    if (value != null && isFunction(value.indexOf) && value.includes('!important')) {\n      priority = 'important';\n      value = value.replace('!important', '');\n    }\n\n    this.obj.style.setProperty(style, value, priority);\n  }\n\n  public bind(): void {\n    this._value = this._oldValue = this.obj.style.cssText;\n  }\n\n  // the followings come from the noop mixing\n  /** @internal */ public subscribe!: () => void;\n  /** @internal */ public unsubscribe!: () => void;\n}\n", "import { type IIndexable, areEqual } from '@aurelia/kernel';\nimport { subscriberCollection } from '@aurelia/runtime';\nimport { mixinNodeObserverUseConfig } from './observation-utils';\nimport { atLayout, atNode, atObserver } from '../utilities';\n\nimport type { AccessorType, ISubscriberCollection } from '@aurelia/runtime';\nimport type { INode } from '../dom';\nimport type { INodeObserver, INodeObserverConfigBase } from './observer-locator';\n\nexport interface ValueAttributeObserver extends ISubscriberCollection {}\n/**\n * Observer for non-radio, non-checkbox input.\n */\nexport class ValueAttributeObserver implements INodeObserver {\n  static {\n    mixinNodeObserverUseConfig(ValueAttributeObserver);\n    subscriberCollection(ValueAttributeObserver, null!);\n  }\n\n  // ObserverType.Layout is not always true, it depends on the element & property combo\n  // but for simplicity, always treat as such\n  public type: AccessorType = (atNode | atObserver | atLayout) as AccessorType;\n\n  /** @internal */\n  public readonly _el: INode & IIndexable;\n\n  /** @internal */\n  private readonly _key: PropertyKey;\n\n  /** @internal */\n  private _value: unknown = '';\n\n  /** @internal */\n  private _oldValue: unknown = '';\n\n  /** @internal */\n  private _hasChanges: boolean = false;\n\n  /**\n   * Used by mixing defined methods subscribe/unsubscribe\n   *\n   * @internal\n   */\n  public _listened: boolean = false;\n\n  /** @internal */\n  public _config: INodeObserverConfigBase;\n\n  /**\n   * Comes from mixin\n   */\n  public useConfig!: (config: INodeObserverConfigBase) => void;\n\n  public constructor(\n    obj: INode,\n    key: PropertyKey,\n    config:  INodeObserverConfigBase,\n  ) {\n    this._el = obj as INode & IIndexable;\n    this._key = key;\n    this._config = config;\n  }\n\n  public getValue(): unknown {\n    // is it safe to assume the observer has the latest value?\n    // todo: ability to turn on/off cache based on type\n    return this._value;\n  }\n\n  public setValue(newValue: string | null): void {\n    if (areEqual(newValue, this._value)) {\n      return;\n    }\n    this._oldValue = this._value;\n    this._value = newValue;\n    this._hasChanges = true;\n    if (!this._config.readonly) {\n      this._flushChanges();\n    }\n  }\n\n  /** @internal */\n  private _flushChanges(): void {\n    if (this._hasChanges) {\n      this._hasChanges = false;\n      this._el[this._key as string] = this._value ?? this._config.default;\n      this._flush();\n    }\n  }\n\n  public handleEvent(): void {\n    this._oldValue = this._value;\n    this._value = this._el[this._key as string];\n    if (this._oldValue !== this._value) {\n      this._hasChanges = false;\n      this._flush();\n    }\n  }\n\n  /**\n   * Used by mixing defined methods subscribe\n   *\n   * @internal\n   */\n  public _start(): void {\n    this._value = this._oldValue = this._el[this._key as string];\n  }\n\n  /** @internal */\n  private _flush() {\n    const oV = this._oldValue;\n    this._oldValue = this._value;\n    this.subs.notify(this._value, oV);\n  }\n}\n", "import { createImplementationRegister, createLookup, emptyObject, IServiceLocator, isString, resolve } from '@aurelia/kernel';\nimport {\n  getObserverLookup,\n  IDirtyChecker,\n  INodeObserverLocator,\n  IObserverLocator,\n  PropertyAccessor,\n  SetterObserver,\n} from '@aurelia/runtime';\nimport { IPlatform } from '../platform';\nimport { AttributeNSAccessor } from './attribute-ns-accessor';\nimport { CheckedObserver } from './checked-observer';\nimport { ClassAttributeAccessor } from './class-attribute-accessor';\nimport { attrAccessor } from './data-attribute-accessor';\nimport { SelectValueObserver } from './select-value-observer';\nimport { StyleAttributeAccessor } from './style-attribute-accessor';\nimport { ISVGAnalyzer } from './svg-analyzer';\nimport { ValueAttributeObserver } from './value-attribute-observer';\nimport { atLayout, atNode, isDataAttribute, objectAssign } from '../utilities';\n\nimport type { IIndexable } from '@aurelia/kernel';\nimport type { AccessorType, IAccessor, IObserver, ICollectionObserver, CollectionKind } from '@aurelia/runtime';\nimport type { INode } from '../dom';\nimport { createMappedError, ErrorNames } from '../errors';\n\nconst nsAttributes = (() => {\n  // https://infra.spec.whatwg.org/#namespaces\n  // const htmlNS = 'http://www.w3.org/1999/xhtml';\n  // const mathmlNS = 'http://www.w3.org/1998/Math/MathML';\n  // const svgNS = 'http://www.w3.org/2000/svg';\n  const xlinkNS = 'http://www.w3.org/1999/xlink';\n  const xmlNS = 'http://www.w3.org/XML/1998/namespace';\n  const xmlnsNS = 'http://www.w3.org/2000/xmlns/';\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n  return objectAssign(\n    createLookup<[string, string]>(),\n    {\n      'xlink:actuate': ['actuate', xlinkNS],\n      'xlink:arcrole': ['arcrole', xlinkNS],\n      'xlink:href': ['href', xlinkNS],\n      'xlink:role': ['role', xlinkNS],\n      'xlink:show': ['show', xlinkNS],\n      'xlink:title': ['title', xlinkNS],\n      'xlink:type': ['type', xlinkNS],\n      'xml:lang': ['lang', xmlNS],\n      'xml:space': ['space', xmlNS],\n      'xmlns': ['xmlns', xmlnsNS],\n      'xmlns:xlink': ['xlink', xmlnsNS],\n    },\n  );\n})();\n\nconst elementPropertyAccessor = new PropertyAccessor();\nelementPropertyAccessor.type = (atNode | atLayout) as AccessorType;\n\nexport interface INodeObserverConfigBase {\n  /**\n   * Indicates the list of events can be used to observe a particular property\n   */\n  readonly events: string[];\n  /**\n   * Indicates whether this property is readonly, so observer wont attempt to assign value\n   * example: input.files\n   */\n  readonly readonly?: boolean;\n  /**\n   * A default value to assign to the corresponding property if the incoming value is null/undefined\n   */\n  readonly default?: unknown;\n}\n\nexport interface INodeObserver extends IObserver {\n  /**\n   * Instruct this node observer event observation behavior\n   */\n  useConfig(config: INodeObserverConfigBase): void;\n}\n\nexport type INodeObserverConstructor =\n  new (\n    el: INode,\n    key: PropertyKey,\n    config: INodeObserverConfig,\n    observerLocator: IObserverLocator,\n    locator: IServiceLocator,\n  ) => INodeObserver;\n\nexport interface INodeObserverConfig {\n  /**\n   * The observer constructor to use\n   */\n  readonly type?: INodeObserverConstructor;\n  /**\n   * Indicates the list of events can be used to observe a particular property\n   */\n  readonly events: string[];\n  /**\n   * Indicates whether this property is readonly, so observer wont attempt to assign value\n   * example: input.files\n   */\n  readonly readonly?: boolean;\n  /**\n   * A default value to assign to the corresponding property if the incoming value is null/undefined\n   */\n  readonly default?: unknown;\n}\n\nexport class NodeObserverLocator implements INodeObserverLocator {\n  public static register = /*@__PURE__*/ createImplementationRegister(INodeObserverLocator);\n\n  /**\n   * Indicates whether the node observer will be allowed to use dirty checking for a property it doesn't know how to observe\n   */\n  public allowDirtyCheck: boolean = true;\n\n  /** @internal */\n  private readonly _events: Record<string, Record<string, INodeObserverConfig>> = createLookup();\n  /** @internal */\n  private readonly _globalEvents: Record<string, INodeObserverConfig> = createLookup();\n  /** @internal */\n  private readonly _overrides: Record<string, Record<string, true>> = createLookup();\n  /** @internal */\n  private readonly _globalOverrides: Record<string, true> = createLookup();\n\n  /** @internal */\n  private readonly _locator = resolve(IServiceLocator);\n  /** @internal */\n  private readonly _platform = resolve(IPlatform);\n  /** @internal */\n  private readonly _dirtyChecker = resolve(IDirtyChecker);\n  /** @internal */\n  private readonly svg = resolve(ISVGAnalyzer);\n\n  public constructor() {\n    // todo: atm, platform is required to be resolved too eagerly for the `.handles()` check\n    // also a lot of tests assume default availability of observation\n    // those 2 assumptions make it not the right time to extract the following line into a\n    // default configuration for NodeObserverLocator yet\n    // but in the future, they should be, so apps that don't use check box/select, or implement a different\n    // observer don't have to pay the of the default implementation\n    const inputEvents = ['change', 'input'];\n    const inputEventsConfig: INodeObserverConfig = { events: inputEvents, default: '' };\n    this.useConfig({\n      INPUT: {\n        value: inputEventsConfig,\n        valueAsNumber: { events: inputEvents, default: 0 },\n        checked: { type: CheckedObserver, events: inputEvents } ,\n        files: { events: inputEvents, readonly: true },\n      },\n      SELECT: {\n        value: { type: SelectValueObserver, events: ['change'], default: '' },\n      },\n      TEXTAREA: {\n        value: inputEventsConfig,\n      },\n    });\n\n    const contentEventsConfig: INodeObserverConfig = { events: ['change', 'input', 'blur', 'keyup', 'paste'], default: '' };\n    const scrollEventsConfig: INodeObserverConfig = { events: ['scroll'], default: 0 };\n    this.useConfigGlobal({\n      scrollTop: scrollEventsConfig,\n      scrollLeft: scrollEventsConfig,\n      textContent: contentEventsConfig,\n      innerHTML: contentEventsConfig,\n    });\n\n    this.overrideAccessorGlobal('css', 'style', 'class');\n    this.overrideAccessor({\n      INPUT: ['value', 'checked', 'model'],\n      SELECT: ['value'],\n      TEXTAREA: ['value'],\n    });\n  }\n\n  // deepscan-disable-next-line\n  public handles(obj: unknown, _key: PropertyKey): boolean {\n    return obj instanceof this._platform.Node;\n  }\n\n  public useConfig(config: Record<string, Record<string, INodeObserverConfig>>): void;\n  public useConfig(nodeName: string, key: PropertyKey, events: INodeObserverConfig): void;\n  public useConfig(nodeNameOrConfig: string | Record<string, Record<string, INodeObserverConfig>>, key?: PropertyKey, eventsConfig?: INodeObserverConfig): void {\n    const lookup = this._events;\n    let existingMapping: Record<string, INodeObserverConfig>;\n    if (isString(nodeNameOrConfig)) {\n      existingMapping = lookup[nodeNameOrConfig] ??= createLookup();\n      if (existingMapping[key as string] == null) {\n        existingMapping[key as string] = eventsConfig!;\n      } else {\n        throwMappingExisted(nodeNameOrConfig, key!);\n      }\n    } else {\n      for (const nodeName in nodeNameOrConfig) {\n        existingMapping = lookup[nodeName] ??= createLookup();\n        const newMapping = nodeNameOrConfig[nodeName];\n        for (key in newMapping) {\n          if (existingMapping[key] == null) {\n            existingMapping[key] = newMapping[key];\n          } else {\n            throwMappingExisted(nodeName, key);\n          }\n        }\n      }\n    }\n  }\n\n  public useConfigGlobal(config: Record<string, INodeObserverConfig>): void;\n  public useConfigGlobal(key: PropertyKey, events: INodeObserverConfig): void;\n  public useConfigGlobal(configOrKey: PropertyKey | Record<string, INodeObserverConfig>, eventsConfig?: INodeObserverConfig): void {\n    const lookup = this._globalEvents;\n    if (typeof configOrKey === 'object') {\n      for (const key in configOrKey) {\n        if (lookup[key] == null) {\n          lookup[key] = configOrKey[key];\n        } else {\n          throwMappingExisted('*', key);\n        }\n      }\n    } else {\n      if (lookup[configOrKey as string] == null) {\n        lookup[configOrKey as string] = eventsConfig!;\n      } else {\n        throwMappingExisted('*', configOrKey);\n      }\n    }\n  }\n\n  // deepscan-disable-nextline\n  public getAccessor(obj: HTMLElement, key: PropertyKey, requestor: IObserverLocator): IAccessor | IObserver {\n    if (key in this._globalOverrides || (key in (this._overrides[obj.tagName] ?? emptyObject))) {\n      return this.getObserver(obj, key, requestor);\n    }\n    switch (key) {\n      // class / style / css attribute will be observed using .getObserver() per overrides\n      //\n      // TODO: there are (many) more situation where we want to default to DataAttributeAccessor\n      case 'src':\n      case 'href':\n      case 'role':\n      case 'minLength':\n      case 'maxLength':\n      case 'placeholder':\n      case 'size':\n      case 'pattern':\n      case 'title':\n      case 'popovertarget':\n      case 'popovertargetaction':\n        /* istanbul-ignore-next */\n        if (__DEV__) {\n          if ((key === 'popovertarget' || key === 'popovertargetaction') && obj.nodeName !== 'INPUT' && obj.nodeName !== 'BUTTON') {\n            // eslint-disable-next-line no-console\n            console.warn(`[aurelia] Popover API are only valid on <input> or <button>. Detected ${key} on <${obj.nodeName.toLowerCase()}>`);\n          }\n        }\n        // assigning null/undefined to size on input is an error\n        // though it may be fine on other elements.\n        // todo: make an effort to distinguish properties based on element name\n        // https://html.spec.whatwg.org/multipage/dom.html#wai-aria\n        return attrAccessor;\n      default: {\n        const nsProps = nsAttributes[key as string];\n        if (nsProps !== undefined) {\n          return AttributeNSAccessor.forNs(nsProps[1]);\n        }\n        if (isDataAttribute(obj, key, this.svg)) {\n          return attrAccessor;\n        }\n        return elementPropertyAccessor;\n      }\n    }\n  }\n\n  /**\n   * For a list of specific elements\n   * compose a list of properties, based on different tag name,\n   * indicating that an overser should be returned instead of an accessor in `.getAccessor()`\n   */\n  public overrideAccessor(overrides: Record<string, string[]>): void;\n  public overrideAccessor(tagName: string, key: PropertyKey): void;\n  public overrideAccessor(tagNameOrOverrides: string | Record<string, string[]>, key?: PropertyKey): void {\n    let existingTagOverride: Record<string, true> | undefined;\n    if (isString(tagNameOrOverrides)) {\n      existingTagOverride = this._overrides[tagNameOrOverrides] ??= createLookup();\n      existingTagOverride[key as string] = true;\n    } else {\n      for (const tagName in tagNameOrOverrides) {\n        for (const key of tagNameOrOverrides[tagName]) {\n          existingTagOverride =this._overrides[tagName] ??= createLookup();\n          existingTagOverride[key] = true;\n        }\n      }\n    }\n  }\n\n  /**\n   * For all elements:\n   * compose a list of properties,\n   * to indicate that an overser should be returned instead of an accessor in `.getAccessor()`\n   */\n  public overrideAccessorGlobal(...keys: string[]): void {\n    for (const key of keys) {\n      this._globalOverrides[key] = true;\n    }\n  }\n\n  public getNodeObserverConfig(el: HTMLElement, key: PropertyKey): INodeObserverConfig | undefined {\n    return this._events[el.tagName]?.[key as string] ?? this._globalEvents[key as string];\n  }\n\n  public getNodeObserver(el: HTMLElement, key: PropertyKey, requestor: IObserverLocator): INodeObserver | null {\n    const eventsConfig = this._events[el.tagName]?.[key as string] ?? this._globalEvents[key as string];\n    let observer: INodeObserver;\n    if (eventsConfig != null) {\n      observer = new (eventsConfig.type ?? ValueAttributeObserver)(el, key, eventsConfig, requestor, this._locator);\n      if (!observer.doNotCache) {\n        getObserverLookup(el)[key] = observer;\n      }\n      return observer;\n    }\n    return null;\n  }\n\n  public getObserver(el: HTMLElement, key: PropertyKey, requestor: IObserverLocator): IAccessor | IObserver {\n    switch (key) {\n      case 'class':\n        // todo: invalid accessor returned for a get observer call\n        //       for now it's a noop observer\n        return new ClassAttributeAccessor(el);\n      case 'css':\n      case 'style':\n        // todo: invalid accessor returned for a get observer call\n        //       for now it's a noop observer\n        return new StyleAttributeAccessor(el);\n    }\n    const nodeObserver = this.getNodeObserver(el, key, requestor);\n    if (nodeObserver != null) {\n      return nodeObserver;\n    }\n\n    const nsProps = nsAttributes[key as string];\n    if (nsProps !== undefined) {\n      // todo: invalid accessor returned for a get observer call\n      //       for now it's a noop observer\n      return AttributeNSAccessor.forNs(nsProps[1]);\n    }\n    if (isDataAttribute(el, key, this.svg)) {\n      // todo: invalid accessor returned for a get observer call\n      //       for now it's a noop observer\n      return attrAccessor;\n    }\n    if (key in el.constructor.prototype) {\n      if (this.allowDirtyCheck) {\n        return this._dirtyChecker.createProperty(el, key as string);\n      }\n      // consider:\n      // - maybe add a adapter API to handle unknown obj/key combo\n      throw createMappedError(ErrorNames.node_observer_strategy_not_found, key);\n    } else {\n      // todo: probably still needs to get the property descriptor via getOwnPropertyDescriptor\n      // but let's start with simplest scenario\n      return new SetterObserver(el as HTMLElement & IIndexable, key as string);\n    }\n  }\n}\n\nexport function getCollectionObserver(collection: unknown, observerLocator: IObserverLocator): ICollectionObserver<CollectionKind> | undefined {\n  if (collection instanceof Array) {\n    return observerLocator.getArrayObserver(collection);\n  }\n  if (collection instanceof Map) {\n    return observerLocator.getMapObserver(collection);\n  }\n  if (collection instanceof Set) {\n    return observerLocator.getSetObserver(collection);\n  }\n}\n\nfunction throwMappingExisted(nodeName: string, key: PropertyKey): never {\n  throw createMappedError(ErrorNames.node_observer_mapping_existed, nodeName, key);\n}\n", "import {\n  type CollectionKind,\n  SetterObserver,\n  subscriberCollection,\n  type AccessorType,\n  type ICollectionObserver,\n  type ISubscriberCollection,\n  type IObserverLocator,\n} from '@aurelia/runtime';\nimport { getCollectionObserver, INodeObserver, INodeObserverConfigBase } from './observer-locator';\nimport { atLayout, atNode, atObserver, hasOwnProperty } from '../utilities';\n\nimport type { INode } from '../dom';\nimport type { ValueAttributeObserver } from './value-attribute-observer';\nimport { mixinNodeObserverUseConfig } from './observation-utils';\nimport { isArray } from '@aurelia/kernel';\n\nexport interface IInputElement extends HTMLInputElement {\n  model?: unknown;\n  $observers?: {\n    model?: SetterObserver;\n    value?: ValueAttributeObserver;\n  };\n  matcher?: typeof defaultMatcher;\n}\n\nfunction defaultMatcher(a: unknown, b: unknown): boolean {\n  return a === b;\n}\n\nexport interface CheckedObserver extends\n  ISubscriberCollection { }\n\nexport class CheckedObserver implements INodeObserver {\n  static {\n    mixinNodeObserverUseConfig(CheckedObserver);\n    subscriberCollection(CheckedObserver, null!);\n  }\n\n  public type: AccessorType = (atNode | atObserver | atLayout) as AccessorType;\n\n  /** @internal */\n  private _value: unknown = void 0;\n\n  /** @internal */\n  private _oldValue: unknown = void 0;\n\n  /** @internal */\n  public readonly _el: IInputElement;\n\n  /** @internal */\n  private _collectionObserver?: ICollectionObserver<CollectionKind> = void 0;\n\n  /**\n   * There' situation when a checked observers is used together with `model.bind` on the checkbox\n   *\n   * Then this checked box also needs to observe the changes of tht model so that it will be able to referesh the value accordingly\n   *\n   * @internal\n   */\n  private _valueObserver?: ValueAttributeObserver | SetterObserver = void 0;\n\n  /** @internal */\n  private readonly oL: IObserverLocator;\n\n  /**\n   * Used by mixing defined methods subscribe/unsubscribe\n   *\n   * @internal\n   */\n  public _listened: boolean = false;\n\n  /** @internal */\n  public _config: INodeObserverConfigBase;\n\n  /**\n   * Comes from mixin\n   */\n  public useConfig!: (config: INodeObserverConfigBase) => void;\n\n  public constructor(\n    obj: INode,\n    // deepscan-disable-next-line\n    _key: PropertyKey,\n    config: INodeObserverConfigBase,\n    observerLocator: IObserverLocator,\n  ) {\n    this._el = obj as IInputElement;\n    this.oL = observerLocator;\n    this._config = config;\n  }\n\n  public getValue(): unknown {\n    return this._value;\n  }\n\n  public setValue(newValue: unknown): void {\n    const currentValue = this._value;\n    if (newValue === currentValue) {\n      return;\n    }\n    this._value = newValue;\n    this._oldValue = currentValue;\n    this._observe();\n    this._synchronizeElement();\n    this._flush();\n  }\n\n  public handleCollectionChange(): void {\n    this._synchronizeElement();\n  }\n\n  public handleChange(_newValue: unknown, _previousValue: unknown): void {\n    this._synchronizeElement();\n  }\n\n  /** @internal */\n  private _synchronizeElement(): void {\n    const currentValue = this._value;\n    const obj = this._el;\n    const elementValue = hasOwnProperty.call(obj, 'model') ? obj.model : obj.value;\n    const isRadio = obj.type === 'radio';\n    const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;\n\n    if (isRadio) {\n      obj.checked = !!matcher(currentValue, elementValue);\n    } else if (currentValue === true) {\n      obj.checked = true;\n    } else {\n      let hasMatch = false;\n      if (isArray(currentValue)) {\n        hasMatch = currentValue.findIndex(item => !!matcher(item, elementValue)) !== -1;\n      } else if (currentValue instanceof Set) {\n        for (const v of currentValue) {\n          if (matcher(v, elementValue)) {\n            hasMatch = true;\n            break;\n          }\n        }\n      } else if (currentValue instanceof Map) {\n        for (const pair of currentValue) {\n          const existingItem = pair[0];\n          const $isChecked = pair[1];\n          // a potential complain, when only `true` is supported\n          // but it's consistent with array\n          if (matcher(existingItem, elementValue) && $isChecked === true) {\n            hasMatch = true;\n            break;\n          }\n        }\n      }\n      obj.checked = hasMatch;\n    }\n  }\n\n  public handleEvent(): void {\n    let currentValue = this._oldValue = this._value;\n    const obj = this._el;\n    const elementValue = hasOwnProperty.call(obj, 'model') ? obj.model : obj.value;\n    const isChecked = obj.checked;\n    const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;\n\n    if (obj.type === 'checkbox') {\n      if (isArray(currentValue)) {\n        // Array binding steps on a change event:\n        // 1. find corresponding item INDEX in the Set based on current model/value and matcher\n        // 2. is the checkbox checked?\n        //    2.1. Yes: is the corresponding item in the Array (index === -1)?\n        //        2.1.1 No: push the current model/value to the Array\n        //    2.2. No: is the corresponding item in the Array (index !== -1)?\n        //        2.2.1: Yes: remove the corresponding item\n        // =================================================\n        const index = currentValue.findIndex(item => !!matcher(item, elementValue));\n\n        // if the checkbox is checkde, and there's no matching value in the existing array\n        // add the checkbox model/value to the array\n        if (isChecked && index === -1) {\n          currentValue.push(elementValue);\n        } else if (!isChecked && index !== -1) {\n          // if the checkbox is not checked, and found a matching item in the array\n          // based on the checkbox model/value\n          // remove the existing item\n          currentValue.splice(index, 1);\n        }\n        // when existing currentValue is an array,\n        // do not invoke callback as only the array obj has changed\n        return;\n      } else if (currentValue instanceof Set) {\n        // Set binding steps on a change event:\n        // 1. find corresponding item in the Set based on current model/value and matcher\n        // 2. is the checkbox checked?\n        //    2.1. Yes: is the corresponding item in the Set?\n        //        2.1.1 No: add the current model/value to the Set\n        //    2.2. No: is the corresponding item in the Set?\n        //        2.2.1: Yes: remove the corresponding item\n        // =================================================\n\n        // 1. find corresponding item\n        const unset = {};\n        let existingItem: unknown = unset;\n        for (const value of currentValue) {\n          if (matcher(value, elementValue) === true) {\n            existingItem = value;\n            break;\n          }\n        }\n        // 2.1. Checkbox is checked, is the corresponding item in the Set?\n        //\n        // if checkbox is checked and there's no value in the existing Set\n        // add the checkbox model/value to the Set\n        if (isChecked && existingItem === unset) {\n          // 2.1.1. add the current model/value to the Set\n          currentValue.add(elementValue);\n        } else if (!isChecked && existingItem !== unset) {\n          // 2.2.1 Checkbox is unchecked, corresponding is in the Set\n          //\n          // if checkbox is not checked, and found a matching item in the Set\n          // based on the checkbox model/value\n          // remove the existing item\n          currentValue.delete(existingItem);\n        }\n        // when existing value is a Set,\n        // do not invoke callback as only the Set has been mutated\n        return;\n      } else if (currentValue instanceof Map) {\n        // Map binding steps on a change event\n        // 1. find corresponding item in the Map based on current model/value and matcher\n        // 2. Set the value of the corresponding item in the Map based on checked state of the checkbox\n        // =================================================\n\n        // 1. find the corresponding item\n        let existingItem: unknown;\n        for (const pair of currentValue) {\n          const currItem = pair[0];\n          if (matcher(currItem, elementValue) === true) {\n            existingItem = currItem;\n            break;\n          }\n        }\n\n        // 2. set the value of the corresponding item in the map\n        // if checkbox is checked and there's no value in the existing Map\n        // add the checkbox model/value to the Map as key,\n        // and value will be checked state of the checkbox\n        currentValue.set(existingItem, isChecked);\n        // when existing value is a Map,\n        // do not invoke callback as only the Map has been mutated\n        return;\n      }\n      currentValue = isChecked;\n    } else if (isChecked) {\n      currentValue = elementValue;\n    } else {\n      // if it's a radio and it has been unchecked\n      // do nothing, as the radio that was checked will fire change event and it will be handle there\n      // a radio cannot be unchecked by user\n      return;\n    }\n    this._value = currentValue;\n    this._flush();\n  }\n\n  /**\n   * Used by mixing defined methods subscribe\n   *\n   * @internal\n   */\n  public _start() {\n    this._observe();\n  }\n\n  /**\n   * Used by mixing defined methods unsubscribe\n   *\n   * @internal\n   */\n  public _stop(): void {\n    this._value = this._oldValue = void 0;\n    this._collectionObserver?.unsubscribe(this);\n    this._valueObserver?.unsubscribe(this);\n    this._collectionObserver = this._valueObserver = void 0;\n  }\n\n  /** @internal */\n  private _flush(): void {\n    oV = this._oldValue;\n    this._oldValue = this._value;\n    this.subs.notify(this._value, oV);\n    oV = void 0;\n  }\n\n  /** @internal */\n  private _observe() {\n    const obj = this._el;\n\n    (this._valueObserver ??= obj.$observers?.model ?? obj.$observers?.value)?.subscribe(this);\n\n    this._collectionObserver?.unsubscribe(this);\n    this._collectionObserver = void 0;\n\n    if (obj.type === 'checkbox') {\n      (this._collectionObserver = getCollectionObserver(this._value, this.oL))?.subscribe(this);\n    }\n  }\n}\n\n// a reusable variable for `.flush()` methods of observers\n// so that there doesn't need to create an env record for every call\nlet oV: unknown = void 0;\n", "import { type Scope } from '@aurelia/runtime';\n\nimport { IBinding } from '../../binding/interfaces-bindings';\nimport { attrAccessor } from '../../observation/data-attribute-accessor';\n\nimport { PropertyBinding } from '../../binding/property-binding';\nimport { ErrorNames, createMappedError } from '../../errors';\nimport { type BindingBehaviorInstance, type BindingBehaviorStaticAuDefinition, behaviorTypeName } from '../binding-behavior';\n\nexport class AttrBindingBehavior implements BindingBehaviorInstance {\n  public static readonly $au: BindingBehaviorStaticAuDefinition = {\n    type: behaviorTypeName,\n    name: 'attr',\n  };\n\n  public bind(_scope: Scope, binding: IBinding): void {\n    if (!(binding instanceof PropertyBinding)) {\n      throw createMappedError(ErrorNames.attr_behavior_invalid_binding, binding);\n    }\n    binding.useTargetObserver(attrAccessor);\n  }\n}\n", "import { type Scope } from '@aurelia/runtime';\nimport { ListenerBinding } from '../../binding/listener-binding';\nimport { type BindingBehaviorInstance, BindingBehaviorStaticAuDefinition, behaviorTypeName } from '../binding-behavior';\n\nimport { ErrorNames, createMappedError } from '../../errors';\n\nexport class SelfBindingBehavior implements BindingBehaviorInstance {\n  public static readonly $au: BindingBehaviorStaticAuDefinition = {\n    type: behaviorTypeName,\n    name: 'self',\n  };\n\n  public bind(_scope: Scope, binding: ListenerBinding): void {\n    if (!('handleEvent' in binding)) {\n      throw createMappedError(ErrorNames.self_behavior_invalid_usage);\n    }\n\n    binding.self = true;\n  }\n\n  public unbind(_scope: Scope, binding: ListenerBinding): void {\n    binding.self = false;\n  }\n}\n", "import { resolve } from '@aurelia/kernel';\nimport { type Scope, INodeObserverLocator, IObserverLocator } from '@aurelia/runtime';\nimport { type IBinding, fromView } from '../../binding/interfaces-bindings';\nimport { NodeObserverLocator } from '../../observation/observer-locator';\nimport { behaviorTypeName, type BindingBehaviorInstance, type BindingBehaviorStaticAuDefinition } from '../binding-behavior';\n\nimport { PropertyBinding } from '../../binding/property-binding';\nimport { ErrorNames, createMappedError } from '../../errors';\n\nexport class UpdateTriggerBindingBehavior implements BindingBehaviorInstance {\n  public static readonly $au: BindingBehaviorStaticAuDefinition = {\n    type: behaviorTypeName,\n    name: 'updateTrigger',\n  };\n\n  /** @internal */ private readonly _observerLocator = resolve(IObserverLocator);\n  /** @internal */ private readonly _nodeObserverLocator = resolve(INodeObserverLocator) as NodeObserverLocator;\n\n  public bind(_scope: Scope, binding: IBinding, ...events: string[]): void {\n    if (!(this._nodeObserverLocator instanceof NodeObserverLocator)) {\n      throw createMappedError(ErrorNames.update_trigger_behavior_not_supported);\n    }\n    if (events.length === 0) {\n      throw createMappedError(ErrorNames.update_trigger_behavior_no_triggers);\n    }\n\n    if (!(binding instanceof PropertyBinding) || !(binding.mode & fromView)) {\n      throw createMappedError(ErrorNames.update_trigger_invalid_usage);\n    }\n\n    // ensure the binding's target observer has been set.\n    const targetConfig = this._nodeObserverLocator.getNodeObserverConfig(\n      binding.target as HTMLElement,\n      binding.targetProperty,\n    );\n    // todo(bigopon): potentially updateTrigger can be used to teach Aurelia adhoc listening capability\n    //                since event names are the only thing needed\n    if (targetConfig == null) {\n      throw createMappedError(ErrorNames.update_trigger_behavior_node_property_not_observable, binding);\n    }\n    const targetObserver = this._nodeObserverLocator.getNodeObserver(\n      binding.target as HTMLElement,\n      binding.targetProperty,\n      this._observerLocator,\n    )!; // the check on targetConfig ensures it's not null, save execessive check her\n\n    targetObserver.useConfig({ readonly: targetConfig.readonly, default: targetConfig.default, events });\n\n    binding.useTargetObserver(targetObserver);\n  }\n}\n", "/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nimport { onResolve, resolve } from '@aurelia/kernel';\nimport { IRenderLocation } from '../../dom';\nimport { IViewFactory } from '../../templating/view';\n\nimport type { ISyntheticView, ICustomAttributeController, ICustomAttributeViewModel, IHydratedController, IHydratedParentController, ControllerVisitor, IHydratableController } from '../../templating/controller';\nimport type { IInstruction } from '@aurelia/template-compiler';\nimport type { INode } from '../../dom';\nimport { ErrorNames, createMappedError } from '../../errors';\nimport { CustomAttributeStaticAuDefinition, attrTypeName } from '../custom-attribute';\n\nexport class If implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'if',\n    isTemplateController: true,\n    bindables: {\n      value: true,\n      cache: {\n        set: (v: unknown) => v === '' || !!v && v !== 'false',\n      }\n    }\n  };\n\n  public elseFactory?: IViewFactory = void 0;\n  public elseView?: ISyntheticView = void 0;\n  public ifView?: ISyntheticView = void 0;\n  public view?: ISyntheticView = void 0;\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n\n  public value: unknown = false;\n  /**\n   * `false` to always dispose the existing `view` whenever the value of if changes to false\n   */\n  public cache: boolean = true;\n  private pending: void | Promise<void> = void 0;\n  /** @internal */ private _wantsDeactivate: boolean = false;\n  /** @internal */ private _swapId: number = 0;\n  /** @internal */ private readonly _ifFactory = resolve(IViewFactory);\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n\n  public attaching(_initiator: IHydratedController, _parent: IHydratedController): void | Promise<void> {\n    return this._swap(this.value);\n  }\n\n  public detaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    this._wantsDeactivate = true;\n    return onResolve(this.pending, () => {\n      this._wantsDeactivate = false;\n      this.pending = void 0;\n      // Promise return values from user VM hooks are awaited by the initiator\n      void this.view?.deactivate(initiator, this.$controller);\n    });\n  }\n\n  public valueChanged(newValue: unknown, oldValue: unknown): void | Promise<void> {\n    if (!this.$controller.isActive) return;\n\n    newValue = !!newValue;\n    oldValue = !!oldValue;\n    if (newValue !== oldValue) return this._swap(newValue);\n  }\n\n  /** @internal */\n  private _swap(value: unknown): void | Promise<void> {\n    const currView = this.view;\n    const ctrl = this.$controller;\n    const swapId = this._swapId++;\n    /**\n     * returns true when\n     * 1. entering deactivation of the [if] itself\n     * 2. new swap has started since this change\n     */\n    const isCurrent = () => !this._wantsDeactivate && this._swapId === swapId + 1;\n    let view: ISyntheticView | undefined;\n    return onResolve(this.pending,\n      () => this.pending = onResolve(\n        currView?.deactivate(currView, ctrl),\n        () => {\n          if (!isCurrent()) {\n            return;\n          }\n          // falsy -> truthy\n          if (value) {\n            view = (this.view = this.ifView = this.cache && this.ifView != null\n              ? this.ifView\n              : this._ifFactory.create()\n            );\n          } else {\n            // truthy -> falsy\n            view = (this.view = this.elseView = this.cache && this.elseView != null\n              ? this.elseView\n              : this.elseFactory?.create()\n            );\n          }\n          // if the value is falsy\n          // and there's no [else], `view` will be null\n          if (view == null) {\n            return;\n          }\n          // todo: location should be based on either the [if]/[else] attribute\n          //       instead of always of the [if]\n          view.setLocation(this._location);\n          return onResolve(\n            view.activate(view, ctrl, ctrl.scope),\n            () => {\n              if (isCurrent()) {\n                this.pending = void 0;\n              }\n            }\n          );\n        }\n      )\n    );\n  }\n\n  public dispose(): void {\n    this.ifView?.dispose();\n    this.elseView?.dispose();\n    this.ifView\n      = this.elseView\n      = this.view\n      = void 0;\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    if (this.view?.accept(visitor) === true) {\n      return true;\n    }\n  }\n}\n\nexport class Else implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: 'custom-attribute',\n    name: 'else',\n    isTemplateController: true,\n  };\n\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n\n  public link(\n    controller: IHydratableController,\n    _childController: ICustomAttributeController,\n    _target: INode,\n    _instruction: IInstruction,\n  ): void {\n    const children = controller.children!;\n    const ifBehavior: If | ICustomAttributeController = children[children.length - 1] as If | ICustomAttributeController;\n    if (ifBehavior instanceof If) {\n      ifBehavior.elseFactory = this._factory;\n    } else if (ifBehavior.viewModel instanceof If) {\n      ifBehavior.viewModel.elseFactory = this._factory;\n    } else {\n      throw createMappedError(ErrorNames.else_without_if);\n    }\n  }\n}\n", "import {\n  areEqual,\n  isArray,\n  isPromise,\n  isMap,\n  isSet,\n  isNumber,\n  type IDisposable,\n  onResolve,\n  type IIndexable,\n  resolve,\n  all,\n  emptyArray,\n  IContainer,\n} from '@aurelia/kernel';\nimport {\n  BindingBehaviorExpression,\n  ForOfStatement,\n  type IsBindingBehavior,\n  ValueConverterExpression,\n} from '@aurelia/expression-parser';\nimport {\n  type Collection,\n  CollectionObserver,\n  getCollectionObserver,\n  type IndexMap,\n  createIndexMap,\n  astEvaluate,\n  astAssign,\n  Scope,\n  BindingContext,\n  type IOverrideContext,\n} from '@aurelia/runtime';\nimport { IExpressionParser } from '@aurelia/expression-parser';\nimport { IRenderLocation } from '../../dom';\nimport { IViewFactory } from '../../templating/view';\nimport { CustomAttributeStaticAuDefinition, attrTypeName } from '../custom-attribute';\nimport { IController } from '../../templating/controller';\nimport { rethrow, etIsProperty } from '../../utilities';\nimport { HydrateTemplateController, IInstruction, IteratorBindingInstruction } from '@aurelia/template-compiler';\n\nimport type { PropertyBinding } from '../../binding/property-binding';\nimport type { ISyntheticView, ICustomAttributeController, IHydratableController, ICustomAttributeViewModel, IHydratedController, IHydratedParentController, ControllerVisitor } from '../../templating/controller';\nimport { ErrorNames, createMappedError } from '../../errors';\nimport { createInterface, singletonRegistration } from '../../utilities-di';\n\ntype Items<C extends Collection = unknown[]> = C | undefined;\n\nfunction dispose(disposable: IDisposable): void {\n  disposable.dispose();\n}\n\nconst wrappedExprs = [\n  'BindingBehavior',\n  'ValueConverter',\n];\n\nexport class Repeat<C extends Collection = unknown[]> implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'repeat',\n    isTemplateController: true,\n    bindables: ['items'],\n  };\n\n  public views: ISyntheticView[] = [];\n  public forOf!: ForOfStatement;\n  public local!: string;\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n\n  public items: Items<C>;\n  public key: null | string | IsBindingBehavior = null;\n\n  /** @internal */ private _oldViews: ISyntheticView[] = [];\n  /** @internal */ private _scopes: Scope[] = [];\n  /** @internal */ private _oldScopes: Scope[] = [];\n  /** @internal */ private _scopeMap: Map<unknown, Scope | Scope[]> = new Map();\n  /** @internal */ private _observer?: CollectionObserver = void 0;\n  /** @internal */ private _innerItems: Items<C> | null;\n  /** @internal */ private _forOfBinding!: PropertyBinding;\n  /** @internal */ private _observingInnerItems: boolean = false;\n  /** @internal */ private _reevaluating: boolean = false;\n  /** @internal */ private _innerItemsExpression: IsBindingBehavior | null = null;\n  /** @internal */ private _normalizedItems?: unknown[] = void 0;\n  /** @internal */ private _hasDestructuredLocal: boolean = false;\n\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n  /** @internal */ private readonly _parent = resolve(IController) as IHydratableController;\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n  /** @internal */ private readonly _resolver = resolve(IRepeatableHandlerResolver);\n\n  public constructor() {\n    const instruction = resolve(IInstruction) as HydrateTemplateController;\n    const keyProp = (instruction.props[0] as IteratorBindingInstruction).props[0];\n    if (keyProp !== void 0) {\n      const { to, value, command } = keyProp;\n      if (to === 'key') {\n        if (command === null) {\n          this.key = value;\n        } else if (command === 'bind') {\n          this.key = resolve(IExpressionParser).parse(value, etIsProperty);\n        } else {\n          throw createMappedError(ErrorNames.repeat_invalid_key_binding_command, command);\n        }\n      } else {\n        throw createMappedError(ErrorNames.repeat_extraneous_binding, to);\n      }\n    }\n  }\n\n  public binding(\n    _initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    const bindings = this._parent.bindings as PropertyBinding[];\n    const ii = bindings.length;\n    let binding: PropertyBinding = (void 0)!;\n    let forOf!: ForOfStatement;\n    let i = 0;\n    for (; ii > i; ++i) {\n      binding = bindings[i];\n      if (binding.target === this && binding.targetProperty === 'items') {\n        forOf = this.forOf = binding.ast as ForOfStatement;\n        this._forOfBinding = binding;\n\n        let expression = forOf.iterable;\n        while (expression != null && wrappedExprs.includes(expression.$kind)) {\n          expression = (expression as ValueConverterExpression | BindingBehaviorExpression).expression;\n          this._observingInnerItems = true;\n        }\n        this._innerItemsExpression = expression;\n\n        break;\n      }\n    }\n\n    this._refreshCollectionObserver();\n    const dec = forOf.declaration;\n    if(!(this._hasDestructuredLocal = dec.$kind === 'ArrayDestructuring' || dec.$kind === 'ObjectDestructuring')) {\n      this.local = astEvaluate(dec, this.$controller.scope, binding, null) as string;\n    }\n  }\n\n  public attaching(\n    initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    this._normalizeToArray();\n    this._createScopes();\n\n    return this._activateAllViews(initiator, this._normalizedItems ?? emptyArray);\n  }\n\n  public detaching(\n    initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    this._refreshCollectionObserver();\n\n    return this._deactivateAllViews(initiator);\n  }\n\n  public unbinding(\n    _initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    this._scopeMap.clear();\n  }\n\n  // called by SetterObserver\n  public itemsChanged(): void {\n    if (!this.$controller.isActive) {\n      return;\n    }\n    this._refreshCollectionObserver();\n    this._normalizeToArray();\n    this._createScopes();\n    this._applyIndexMap(void 0);\n  }\n\n  public handleCollectionChange(collection: Collection, indexMap: IndexMap | undefined): void {\n    const $controller = this.$controller;\n    if (!$controller.isActive) {\n      return;\n    }\n    if (this._observingInnerItems) {\n      if (this._reevaluating) {\n        return;\n      }\n      this._reevaluating = true;\n      this.items = astEvaluate(this.forOf.iterable, $controller.scope, this._forOfBinding, null) as Items<C>;\n      this._reevaluating = false;\n      return;\n    }\n\n    this._normalizeToArray();\n    this._createScopes();\n    this._applyIndexMap(indexMap);\n  }\n\n  /** @internal */\n  private _applyIndexMap(indexMap: IndexMap | undefined): void {\n    const oldViews = this.views;\n    this._oldViews = oldViews.slice();\n    const oldLen = oldViews.length;\n    const key = this.key;\n    const hasKey = key !== null;\n\n    const oldScopes = this._oldScopes;\n    const newScopes = this._scopes;\n\n    if (hasKey || indexMap === void 0) {\n      const local = this.local;\n      const newItems = this._normalizedItems as IIndexable[];\n\n      const newLen = newItems.length;\n      const forOf = this.forOf;\n      const dec = forOf.declaration;\n      const binding = this._forOfBinding;\n      const hasDestructuredLocal = this._hasDestructuredLocal;\n      indexMap = createIndexMap(newLen);\n      let i = 0;\n\n      if (oldLen === 0) {\n        // Only add new views\n        for (; i < newLen; ++i) {\n          indexMap[i] = -2;\n        }\n      } else if (newLen === 0) {\n        // Only remove old views\n        for (i = 0; i < oldLen; ++i) {\n          indexMap.deletedIndices.push(i);\n          indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i], binding, local));\n        }\n      } else if (hasKey) {\n        const oldKeys = Array<unknown>(oldLen);\n\n        for (i = 0; i < oldLen; ++i) {\n          oldKeys[i] = getKeyValue(hasDestructuredLocal, key, dec, oldScopes[i], binding, local);\n        }\n\n        const newKeys = Array<unknown>(oldLen);\n\n        for (i = 0; i < newLen; ++i) {\n          newKeys[i] = getKeyValue(hasDestructuredLocal, key, dec, newScopes[i], binding, local);\n        }\n\n        for (i = 0; i < newLen; ++i) {\n          if (oldKeys.includes(newKeys[i])) {\n            indexMap[i] = oldKeys.indexOf(newKeys[i]);\n          } else {\n            indexMap[i] = -2;\n          }\n        }\n\n        for (i = 0; i < oldLen; ++i) {\n          if (!newKeys.includes(oldKeys[i])) {\n            indexMap.deletedIndices.push(i);\n            indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i], binding, local));\n          }\n        }\n      } else {\n        for (i = 0; i < newLen; ++i) {\n          if (oldScopes.includes(newScopes[i])) {\n            indexMap[i] = oldScopes.indexOf(newScopes[i]);\n          } else {\n            indexMap[i] = -2;\n          }\n        }\n\n        for (i = 0; i < oldLen; ++i) {\n          if (!newScopes.includes(oldScopes[i])) {\n            indexMap.deletedIndices.push(i);\n            indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i], binding, local));\n          }\n        }\n      }\n    }\n\n    // first detach+unbind+(remove from array) the deleted view indices\n    if (indexMap.deletedIndices.length > 0) {\n      const ret = onResolve(\n        this._deactivateAndRemoveViewsByKey(indexMap),\n        () => {\n          // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add a variety of `if` integration tests\n          return this._createAndActivateAndSortViewsByKey(indexMap);\n        },\n      );\n      if (isPromise(ret)) { ret.catch(rethrow); }\n    } else {\n      // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add integration tests\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._createAndActivateAndSortViewsByKey(indexMap);\n    }\n  }\n\n  // todo: subscribe to collection from inner expression\n  /** @internal */\n  private _refreshCollectionObserver(): void {\n    const scope = this.$controller.scope;\n\n    let innerItems = this._innerItems;\n    let observingInnerItems = this._observingInnerItems;\n    let newObserver: CollectionObserver | undefined;\n\n    if (observingInnerItems) {\n      innerItems = this._innerItems = astEvaluate(this._innerItemsExpression!, scope, this._forOfBinding, null) as Items<C> ?? null;\n      observingInnerItems = this._observingInnerItems = !areEqual(this.items, innerItems);\n    }\n\n    const oldObserver = this._observer;\n    if (this.$controller.isActive) {\n      const items = observingInnerItems ? innerItems : this.items;\n      newObserver = this._observer = this._resolver.resolve(items).getObserver?.(items);\n      if (oldObserver !== newObserver) {\n        oldObserver?.unsubscribe(this);\n        newObserver?.subscribe(this);\n      }\n    } else {\n      oldObserver?.unsubscribe(this);\n      this._observer = undefined;\n    }\n  }\n\n  /** @internal */\n  private _createScopes(): void {\n    const oldScopes = this._scopes;\n    this._oldScopes = oldScopes.slice();\n\n    const items = this._normalizedItems!;\n    const len = items.length;\n    const scopes = this._scopes = Array(items.length);\n\n    const oldScopeMap = this._scopeMap;\n    const newScopeMap = new Map<unknown, Scope | Scope[]>();\n    const parentScope = this.$controller.scope;\n    const binding = this._forOfBinding;\n    const forOf = this.forOf;\n    const local = this.local;\n    const hasDestructuredLocal = this._hasDestructuredLocal;\n\n    for (let i = 0; i < len; ++i) {\n      scopes[i] = getScope(oldScopeMap, newScopeMap, items[i], forOf, parentScope, binding, local, hasDestructuredLocal);\n    }\n\n    oldScopeMap.clear();\n    this._scopeMap = newScopeMap;\n  }\n\n  /** @internal */\n  private _normalizeToArray(): void {\n    const items = this.items;\n    if (isArray(items)) {\n      this._normalizedItems = items.slice(0);\n      return;\n    }\n    const normalizedItems: unknown[] = [];\n\n    this._resolver.resolve(items).iterate(items, (item, index) => {\n      normalizedItems[index] = item;\n    });\n    this._normalizedItems = normalizedItems;\n  }\n\n  /** @internal */\n  private _activateAllViews(\n    initiator: IHydratedController | null,\n    $items: unknown[],\n  ): void | Promise<void> {\n    let promises: Promise<void>[] | undefined = void 0;\n    let ret: void | Promise<void>;\n    let view: ISyntheticView;\n    let scope: Scope;\n\n    const { $controller, _factory, _location, _scopes } = this;\n    const newLen = $items.length;\n    const views = this.views = Array(newLen);\n\n    for (let i = 0; i < newLen; ++i) {\n      view = views[i] = _factory.create().setLocation(_location);\n      view.nodes.unlink();\n      scope = _scopes[i];\n\n      setContextualProperties(scope.overrideContext as RepeatOverrideContext, i, newLen);\n      ret = view.activate(initiator ?? view, $controller, scope);\n      if (isPromise(ret)) {\n        (promises ??= []).push(ret);\n      }\n    }\n\n    if (promises !== void 0) {\n      return promises.length === 1\n        ? promises[0]\n        : Promise.all(promises) as unknown as Promise<void>;\n    }\n  }\n\n  /** @internal */\n  private _deactivateAllViews(\n    initiator: IHydratedController | null,\n  ): void | Promise<void> {\n    let promises: Promise<void>[] | undefined = void 0;\n    let ret: void | Promise<void>;\n    let view: ISyntheticView;\n    let i = 0;\n\n    const { views, $controller } = this;\n    const ii = views.length;\n\n    for (; ii > i; ++i) {\n      view = views[i];\n      view.release();\n      ret = view.deactivate(initiator ?? view, $controller);\n      if (isPromise(ret)) {\n        (promises ?? (promises = [])).push(ret);\n      }\n    }\n\n    if (promises !== void 0) {\n      return (promises.length === 1\n        ? promises[0]\n        : Promise.all(promises)) as unknown as Promise<void>;\n    }\n  }\n\n  /** @internal */\n  private _deactivateAndRemoveViewsByKey(\n    indexMap: IndexMap,\n  ): void | Promise<void> {\n    let promises: Promise<void>[] | undefined = void 0;\n    let ret: void | Promise<void>;\n    let view: ISyntheticView;\n\n    const { $controller, views } = this;\n\n    const deleted = indexMap.deletedIndices.slice().sort(compareNumber);\n    const deletedLen = deleted.length;\n    let i = 0;\n    for (; deletedLen > i; ++i) {\n      view = views[deleted[i]];\n      view.release();\n      ret = view.deactivate(view, $controller);\n      if (isPromise(ret)) {\n        (promises ?? (promises = [])).push(ret);\n      }\n    }\n\n    i = 0;\n    for (; deletedLen > i; ++i) {\n      views.splice(deleted[i] - i, 1);\n    }\n\n    if (promises !== void 0) {\n      return promises.length === 1\n        ? promises[0]\n        : Promise.all(promises) as unknown as Promise<void>;\n    }\n  }\n\n  /** @internal */\n  private _createAndActivateAndSortViewsByKey(\n    indexMap: IndexMap,\n  ): void | Promise<void> {\n    let promises: Promise<void>[] | undefined = void 0;\n    let ret: void | Promise<void>;\n    let view: ISyntheticView;\n    let i = 0;\n\n    const { $controller, _factory, _location, views, _scopes, _oldViews } = this;\n    const newLen = indexMap.length;\n\n    for (; newLen > i; ++i) {\n      if (indexMap[i] === -2) {\n        view = _factory.create();\n        views.splice(i, 0, view);\n      }\n    }\n\n    if (views.length !== newLen) {\n      throw createMappedError(ErrorNames.repeat_mismatch_length, [views.length, newLen]);\n    }\n\n    let source = 0;\n    i = 0;\n    for (; i < indexMap.length; ++i) {\n      if ((source = indexMap[i]) !== -2) {\n        views[i] = _oldViews[source];\n      }\n    }\n\n    // this algorithm retrieves the indices of the longest increasing subsequence of items in the repeater\n    // the items on those indices are not moved; this minimizes the number of DOM operations that need to be performed\n    const seq = longestIncreasingSubsequence(indexMap);\n    const seqLen = seq.length;\n\n    let next: ISyntheticView;\n    let j = seqLen - 1;\n    i = newLen - 1;\n    for (; i >= 0; --i) {\n      view = views[i];\n      next = views[i + 1];\n\n      view.nodes.link(next?.nodes ?? _location);\n\n      if (indexMap[i] === -2) {\n        view.setLocation(_location);\n        setContextualProperties(_scopes[i].overrideContext as RepeatOverrideContext, i, newLen);\n        ret = view.activate(view, $controller, _scopes[i]);\n        if (isPromise(ret)) {\n          (promises ?? (promises = [])).push(ret);\n        }\n      } else if (j < 0 || seqLen === 1 || i !== seq[j]) {\n        setContextualProperties(view.scope.overrideContext as RepeatOverrideContext, i, newLen);\n        view.nodes.insertBefore(view.location!);\n      } else {\n        setContextualProperties(view.scope.overrideContext as RepeatOverrideContext, i, newLen);\n        --j;\n      }\n    }\n\n    if (promises !== void 0) {\n      return promises.length === 1\n        ? promises[0]\n        : Promise.all(promises) as unknown as Promise<void>;\n    }\n  }\n\n  public dispose(): void {\n    this.views.forEach(dispose);\n    this.views = (void 0)!;\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    const { views } = this;\n\n    if (views !== void 0) {\n      for (let i = 0, ii = views.length; i < ii; ++i) {\n        if (views[i].accept(visitor) === true) {\n          return true;\n        }\n      }\n    }\n  }\n}\n\nlet maxLen = 16;\nlet prevIndices = new Int32Array(maxLen);\nlet tailIndices = new Int32Array(maxLen);\n\n// Based on inferno's lis_algorithm @ https://github.com/infernojs/inferno/blob/master/packages/inferno/src/DOM/patching.ts#L732\n// with some tweaks to make it just a bit faster + account for IndexMap (and some names changes for readability)\n/** @internal */\nexport function longestIncreasingSubsequence(indexMap: IndexMap): Int32Array {\n  const len = indexMap.length;\n\n  if (len > maxLen) {\n    maxLen = len;\n    prevIndices = new Int32Array(len);\n    tailIndices = new Int32Array(len);\n  }\n\n  let cursor = 0;\n  let cur = 0;\n  let prev = 0;\n  let i = 0;\n  let j = 0;\n  let low = 0;\n  let high = 0;\n  let mid = 0;\n\n  for (; i < len; i++) {\n    cur = indexMap[i];\n    if (cur !== -2) {\n      j = prevIndices[cursor];\n\n      prev = indexMap[j];\n      if (prev !== -2 && prev < cur) {\n        tailIndices[i] = j;\n        prevIndices[++cursor] = i;\n        continue;\n      }\n\n      low = 0;\n      high = cursor;\n\n      while (low < high) {\n        mid = (low + high) >> 1;\n        prev = indexMap[prevIndices[mid]];\n        if (prev !== -2 && prev < cur) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n\n      prev = indexMap[prevIndices[low]];\n      if (cur < prev || prev === -2) {\n        if (low > 0) {\n          tailIndices[i] = prevIndices[low - 1];\n        }\n        prevIndices[low] = i;\n      }\n    }\n  }\n  i = ++cursor;\n  const result = new Int32Array(i);\n  cur = prevIndices[cursor - 1];\n\n  while (cursor-- > 0) {\n    result[cursor] = cur;\n    cur = tailIndices[cur];\n  }\n  while (i-- > 0) prevIndices[i] = 0;\n  return result;\n}\n\ninterface IRepeatOverrideContext extends IOverrideContext {\n  $index: number;\n  $odd: boolean;\n  $even: boolean;\n  $first: boolean;\n  $middle: boolean;\n  $last: boolean;\n  $length: number; // new in v2, there are a few requests, not sure if it should stay\n}\n\nclass RepeatOverrideContext implements IRepeatOverrideContext {\n  public get $odd(): boolean {\n    return !this.$even;\n  }\n  public get $even(): boolean {\n    return this.$index % 2 === 0;\n  }\n  public get $first(): boolean {\n    return this.$index === 0;\n  }\n  public get $middle(): boolean {\n    return !this.$first && !this.$last;\n  }\n  public get $last(): boolean {\n    return this.$index === this.$length - 1;\n  }\n\n  public constructor(\n    public readonly $index: number = 0,\n    public readonly $length: number = 1,\n  ) {}\n}\n\nconst setContextualProperties = (oc: IRepeatOverrideContext, index: number, length: number): void => {\n  oc.$index = index;\n  oc.$length = length;\n};\n\nexport const IRepeatableHandlerResolver = /*@__PURE__*/ createInterface<IRepeatableHandlerResolver>(\n  'IRepeatableHandlerResolver',\n  x => x.singleton(RepeatableHandlerResolver)\n);\n/**\n * An interface describings the capabilities of a repeatable handler.\n */\nexport interface IRepeatableHandlerResolver {\n  resolve(value: unknown): IRepeatableHandler;\n}\n\n/**\n * The default implementation of the IRepeatableHandlerResolver interface\n */\nclass RepeatableHandlerResolver implements IRepeatableHandlerResolver {\n  /** @internal */\n  private readonly _handlers = resolve(all(IRepeatableHandler));\n\n  public resolve(value: Repeatable): IRepeatableHandler {\n    if (_arrayHandler.handles(value)) {\n      return _arrayHandler;\n    }\n    if (_setHandler.handles(value)) {\n      return _setHandler;\n    }\n    if (_mapHandler.handles(value)) {\n      return _mapHandler;\n    }\n    if (_numberHandler.handles(value)) {\n      return _numberHandler;\n    }\n    if (_nullishHandler.handles(value)) {\n      return _nullishHandler;\n    }\n    const handler = this._handlers.find(x => x.handles(value));\n    if (handler !== void 0) {\n      return handler;\n    }\n    return _unknownHandler;\n  }\n}\n\n/**\n * A simple implementation for handling common array like values, such as:\n * - HTMLCollection\n * - NodeList\n * - FileList,\n * - etc...\n */\nexport class ArrayLikeHandler implements IRepeatableHandler<ArrayLike<unknown>> {\n  public static register(c: IContainer) {\n    c.register(singletonRegistration(IRepeatableHandler, this));\n  }\n\n  public handles(value: NonNullable<unknown>): boolean {\n    return 'length' in value && isNumber(value.length);\n  }\n\n  public iterate(items: ArrayLike<unknown>, func: (item: unknown, index: number, arr: ArrayLike<unknown>) => void): void {\n    for (let i = 0, ii = items.length; i < ii; ++i) {\n      func(items[i], i, items);\n    }\n  }\n\n}\n\n/**\n * An interface describing a repeatable value handler\n */\nexport const IRepeatableHandler = /*@__PURE__*/ createInterface<IRepeatableHandler>('IRepeatableHandler');\n\nexport interface IRepeatableHandler<TValue extends Repeatable = Repeatable> {\n  handles(value: unknown): boolean;\n  getObserver?(value: TValue): CollectionObserver | undefined;\n  iterate(value: TValue, func: (item: unknown, index: number, value: TValue) => void): void;\n  // getCount(items: TValue): number;\n}\n\nconst _arrayHandler: IRepeatableHandler<unknown[]> = {\n  handles: isArray,\n  getObserver: getCollectionObserver,\n  /* istanbul ignore next */\n  iterate(value, func): void {\n    const ii = value.length;\n    let i = 0;\n    for (; i < ii; ++i) {\n      func(value[i], i, value);\n    }\n  },\n  // getCount: items => items.length,\n};\n\nconst _setHandler: IRepeatableHandler<Set<unknown>> = {\n  handles: isSet,\n  getObserver: getCollectionObserver,\n  iterate(value, func): void {\n    let i = 0;\n    let key: unknown;\n    for (key of value.keys()) {\n      func(key, i++, value);\n    }\n  },\n  // getCount: s => s.size,\n};\n\nconst _mapHandler: IRepeatableHandler<Map<unknown, unknown>> = {\n  handles: isMap,\n  getObserver: getCollectionObserver,\n  iterate(value, func): void {\n    let i = 0;\n    let entry: [unknown, unknown] | undefined;\n    for (entry of value.entries()) {\n      func(entry, i++, value);\n    }\n  },\n  // getCount: s => s.size,\n};\n\nconst _numberHandler: IRepeatableHandler<number> = {\n  handles: isNumber,\n  iterate(value, func): void {\n    let i = 0;\n    for (; i < value; ++i) {\n      func(i, i, value);\n    }\n  },\n  // getCount: v => v,\n};\n\nconst _nullishHandler: IRepeatableHandler<null | undefined> = {\n  handles: v => v == null,\n  iterate() {/* do nothing */},\n  // getCount: () => 0,\n};\n\nconst _unknownHandler: IRepeatableHandler = {\n  handles(_value: unknown): boolean {\n    // Should only return as an explicit last fallback\n    return false;\n  },\n  iterate(value: Repeatable, _func: (item: unknown, index: number, value: Repeatable) => void): void {\n    throw createMappedError(ErrorNames.repeat_non_iterable, value);\n  },\n  // getCount: () => 0,\n};\n\ntype Repeatable = Collection | ArrayLike<unknown> | number | null | undefined;\n\nconst setItem = (\n  hasDestructuredLocal: boolean,\n  dec: ForOfStatement['declaration'],\n  scope: Scope,\n  binding: PropertyBinding,\n  local: string,\n  item: unknown,\n) => {\n  if (hasDestructuredLocal) {\n    astAssign(dec, scope, binding, item);\n  } else {\n    scope.bindingContext[local] = item;\n  }\n};\n\nconst getItem = (\n  hasDestructuredLocal: boolean,\n  dec: ForOfStatement['declaration'],\n  scope: Scope,\n  binding: PropertyBinding,\n  local: string,\n): unknown => {\n  return hasDestructuredLocal ? astEvaluate(dec, scope, binding, null) : scope.bindingContext[local];\n};\n\nconst getKeyValue = (\n  hasDestructuredLocal: boolean,\n  key: string | IsBindingBehavior,\n  dec: ForOfStatement['declaration'],\n  scope: Scope,\n  binding: PropertyBinding,\n  local: string,\n) => {\n  if (typeof key === 'string') {\n    const item = getItem(hasDestructuredLocal, dec, scope, binding, local);\n    return (item as IIndexable)[key];\n  }\n\n  return astEvaluate(key, scope, binding, null);\n};\n\nconst getScope = (\n  oldScopeMap: Map<unknown, Scope | Scope[]>,\n  newScopeMap: Map<unknown, Scope | Scope[]>,\n  item: unknown,\n  forOf: ForOfStatement,\n  parentScope: Scope,\n  binding: PropertyBinding,\n  local: string,\n  hasDestructuredLocal: boolean,\n) => {\n  // let scope = void 0 as Scope | Scope[] | undefined;\n  let scope = oldScopeMap.get(item);\n  if (scope === void 0) {\n    scope = createScope(item, forOf, parentScope, binding, local, hasDestructuredLocal);\n  } else if (scope instanceof Scope) {\n    oldScopeMap.delete(item);\n  } else if (scope.length === 1) {\n    scope = scope[0];\n    oldScopeMap.delete(item);\n  } else {\n    scope = scope.shift()!;\n  }\n\n  if (newScopeMap.has(item)) {\n    const entry = newScopeMap.get(item)!;\n    if (entry instanceof Scope) {\n      newScopeMap.set(item, [entry, scope]);\n    } else {\n      entry.push(scope);\n    }\n  } else {\n    newScopeMap.set(item, scope);\n  }\n  setItem(hasDestructuredLocal, forOf.declaration, scope, binding, local, item);\n  return scope;\n};\n\nconst createScope = (\n  item: unknown,\n  forOf: ForOfStatement,\n  parentScope: Scope,\n  binding: PropertyBinding,\n  local: string,\n  hasDestructuredLocal: boolean,\n) => {\n  if (hasDestructuredLocal) {\n    const scope = Scope.fromParent(parentScope, new BindingContext(), new RepeatOverrideContext());\n    astAssign(forOf.declaration, scope, binding, item);\n  }\n  return Scope.fromParent(parentScope, new BindingContext(local, item), new RepeatOverrideContext());\n};\n\nconst compareNumber = (a: number, b: number): number => a - b;\n", "import { resolve } from '@aurelia/kernel';\nimport { Scope } from '@aurelia/runtime';\nimport { IRenderLocation } from '../../dom';\nimport { IViewFactory } from '../../templating/view';\nimport { CustomAttributeStaticAuDefinition, attrTypeName } from '../custom-attribute';\nimport type { ICustomAttributeController, ICustomAttributeViewModel, IHydratedController, IHydratedParentController, ControllerVisitor } from '../../templating/controller';\n\nexport class With implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'with',\n    isTemplateController: true,\n    bindables: ['value'],\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n\n  public value?: object;\n\n  private view = resolve(IViewFactory).create().setLocation(resolve(IRenderLocation));\n\n  public valueChanged(\n    newValue: unknown,\n    _oldValue: unknown,\n  ): void {\n    const $controller = this.$controller;\n    const bindings = this.view.bindings;\n    let scope: Scope;\n    let i = 0, ii = 0;\n    if ($controller.isActive && bindings != null) {\n      scope = Scope.fromParent($controller.scope, newValue === void 0 ? {} : newValue as object);\n      for (ii = bindings.length; ii > i; ++i) {\n        bindings[i].bind(scope);\n      }\n    }\n  }\n\n  public attaching(\n    initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    const { $controller, value } = this;\n    const scope = Scope.fromParent($controller.scope, value === void 0 ? {} : value);\n    return this.view.activate(initiator, $controller, scope);\n  }\n\n  public detaching(\n    initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    return this.view.deactivate(initiator, this.$controller);\n  }\n\n  public dispose(): void {\n    this.view.dispose();\n    this.view = (void 0)!;\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    if (this.view?.accept(visitor) === true) {\n      return true;\n    }\n  }\n}\n", "import {\n  isArray,\n  ILogger,\n  onResolve,\n  onResolveAll,\n  resolve,\n  Writable,\n} from '@aurelia/kernel';\nimport {\n  type ICollectionObserver,\n  IObserverLocator,\n  type Scope,\n} from '@aurelia/runtime';\nimport type { IInstruction } from '@aurelia/template-compiler';\nimport { IRenderLocation } from '../../dom';\nimport { attrTypeName, CustomAttributeStaticAuDefinition, defineAttribute } from '../custom-attribute';\nimport { IViewFactory } from '../../templating/view';\nimport { oneTime } from '../../binding/interfaces-bindings';\n\nimport type { Controller, ICustomAttributeController, ICustomAttributeViewModel, IHydratedController, IHydratedParentController, IHydratableController, ISyntheticView, ControllerVisitor } from '../../templating/controller';\nimport type { INode } from '../../dom';\nimport { createMappedError, ErrorNames } from '../../errors';\nimport { PartialBindableDefinition } from '../../bindable';\n\nexport class Switch implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'switch',\n    isTemplateController: true,\n    bindables: ['value'],\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n  private view!: ISyntheticView;\n\n  public value: unknown;\n\n  /** @internal */\n  public readonly cases: Case[] = [];\n  /** @internal */\n  public defaultCase?: Case;\n  private activeCases: Case[] = [];\n  /**\n   * This is kept around here so that changes can be awaited from the tests.\n   * This needs to be removed after the scheduler is ready to handle/queue the floating promises.\n   */\n  public readonly promise: Promise<void> | void = void 0;\n\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n\n  public link(\n    _controller: IHydratableController,\n    _childController: ICustomAttributeController,\n    _target: INode,\n    _instruction: IInstruction,\n  ): void {\n    this.view = this._factory.create(this.$controller).setLocation(this._location);\n  }\n\n  public attaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    const view = this.view;\n    const $controller = this.$controller;\n\n    this.queue(() => view.activate(initiator, $controller, $controller.scope));\n    this.queue(() => this.swap(initiator, this.value));\n    return this.promise;\n  }\n\n  public detaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    this.queue(() => {\n      const view = this.view;\n      return view.deactivate(initiator, this.$controller);\n    });\n    return this.promise;\n  }\n\n  public dispose(): void {\n    this.view?.dispose();\n    this.view = (void 0)!;\n  }\n\n  public valueChanged(_newValue: boolean, _oldValue: boolean): void {\n    if (!this.$controller.isActive) { return; }\n    this.queue(() => this.swap(null, this.value));\n  }\n\n  public caseChanged($case: Case): void {\n    this.queue(() => this._handleCaseChange($case));\n  }\n\n  /** @internal */\n  private _handleCaseChange($case: Case): void | Promise<void> {\n    const isMatch = $case.isMatch(this.value);\n    const activeCases = this.activeCases;\n    const numActiveCases = activeCases.length;\n\n    // Early termination #1\n    if (!isMatch) {\n      /** The previous match started with this; thus clear. */\n      if (numActiveCases > 0 && activeCases[0].id === $case.id) {\n        return this._clearActiveCases(null);\n      }\n      /**\n       * There are 2 different scenarios here:\n       * 1. $case in activeCases: Indicates by-product of fallthrough. The starting case still satisfies. Return.\n       * 2. $case not in activeCases: It was previously not active, and currently also not a match. Return.\n       */\n      return;\n    }\n\n    // Early termination #2\n    if (numActiveCases > 0 && activeCases[0].id < $case.id) {\n      // Even if this case now a match, the previous case still wins by as that has lower ordinal.\n      return;\n    }\n\n    // compute the new active cases\n    const newActiveCases: Case[] = [];\n    let fallThrough = $case.fallThrough;\n    if (!fallThrough) {\n      newActiveCases.push($case);\n    } else {\n      const cases = this.cases;\n      const idx = cases.indexOf($case);\n      for (let i = idx, ii = cases.length; i < ii && fallThrough; i++) {\n        const c = cases[i];\n        newActiveCases.push(c);\n        fallThrough = c.fallThrough;\n      }\n    }\n\n    return onResolve(\n      this._clearActiveCases(null, newActiveCases),\n      () => {\n        this.activeCases = newActiveCases;\n        return this._activateCases(null);\n      }\n    );\n  }\n\n  private swap(initiator: IHydratedController | null, value: unknown): void | Promise<void> {\n    const newActiveCases: Case[] = [];\n\n    let fallThrough: boolean = false;\n    for (const $case of this.cases) {\n      if (fallThrough || $case.isMatch(value)) {\n        newActiveCases.push($case);\n        fallThrough = $case.fallThrough;\n      }\n      if (newActiveCases.length > 0 && !fallThrough) { break; }\n    }\n    const defaultCase = this.defaultCase;\n    if (newActiveCases.length === 0 && defaultCase !== void 0) {\n      newActiveCases.push(defaultCase);\n    }\n\n    return onResolve(\n      this.activeCases.length > 0\n        ? this._clearActiveCases(initiator, newActiveCases)\n        : void 0!,\n      () => {\n        this.activeCases = newActiveCases;\n        if (newActiveCases.length === 0) { return; }\n        return this._activateCases(initiator);\n      }\n    );\n  }\n\n  /** @internal */\n  private _activateCases(initiator: IHydratedController | null): void | Promise<void> {\n    const controller = this.$controller;\n    if (!controller.isActive) { return; }\n\n    const cases = this.activeCases;\n    const length = cases.length;\n    if (length === 0) { return; }\n\n    const scope = controller.scope;\n\n    // most common case\n    if (length === 1) {\n      return cases[0].activate(initiator, scope);\n    }\n\n    return onResolveAll(...cases.map(($case) => $case.activate(initiator, scope)));\n  }\n\n  /** @internal */\n  private _clearActiveCases(initiator: IHydratedController | null, newActiveCases: Case[] = []): void | Promise<void> {\n    const cases = this.activeCases;\n    const numCases = cases.length;\n\n    if (numCases === 0) { return; }\n\n    if (numCases === 1) {\n      const firstCase = cases[0];\n      if (!newActiveCases.includes(firstCase)) {\n        cases.length = 0;\n        return firstCase.deactivate(initiator);\n      }\n      return;\n    }\n\n    return onResolve(\n      onResolveAll(...cases.reduce((acc: (void | Promise<void>)[], $case) => {\n        if (!newActiveCases.includes($case)) {\n          acc.push($case.deactivate(initiator));\n        }\n        return acc;\n      }, [])),\n      () => {\n        cases.length = 0;\n      }\n    );\n  }\n\n  private queue(action: () => void | Promise<void>): void {\n    const previousPromise = this.promise;\n    let promise: void | Promise<void> = void 0;\n    promise = (this as Writable<Switch>).promise = onResolve(\n      onResolve(previousPromise, action),\n      () => {\n        if (this.promise === promise) {\n          (this as Writable<Switch>).promise = void 0;\n        }\n      }\n    );\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    if (this.$controller.accept(visitor) === true) {\n      return true;\n    }\n    if (this.activeCases.some(x => x.accept(visitor))) {\n      return true;\n    }\n  }\n}\n\nlet caseId = 0;\nconst bindables: (string | PartialBindableDefinition & { name: string })[] = [\n  'value',\n  {\n    name: 'fallThrough',\n    mode: oneTime,\n    set(v: unknown): boolean {\n      switch (v) {\n        case 'true': return true;\n        case 'false': return false;\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        default: return !!v;\n      }\n    }\n  }\n];\n\nexport class Case implements ICustomAttributeViewModel {\n  static {\n    defineAttribute({ name: 'case', bindables, isTemplateController: true }, Case);\n  }\n  /** @internal */ public readonly id: number = ++caseId;\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n\n  public value: unknown;\n  public fallThrough: boolean = false;\n\n  public view: ISyntheticView | undefined = void 0;\n  private $switch!: Switch;\n  /** @internal */ private _observer: ICollectionObserver<'array'> | undefined;\n\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n  /** @internal */ private readonly _locator = resolve(IObserverLocator);\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n  /** @internal */ private readonly _logger = resolve(ILogger).scopeTo(`${this.constructor.name}-#${this.id}`);\n\n  public link(\n    controller: IHydratableController,\n    _childController: ICustomAttributeController,\n    _target: INode,\n    _instruction: IInstruction,\n  ): void {\n    const switchController: IHydratedParentController = (controller as Controller).parent! as IHydratedParentController;\n    const $switch = switchController?.viewModel;\n    if ($switch instanceof Switch) {\n      this.$switch = $switch;\n      this.linkToSwitch($switch);\n    } else {\n      throw createMappedError(ErrorNames.switch_invalid_usage);\n    }\n  }\n\n  public detaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    return this.deactivate(initiator);\n  }\n\n  public isMatch(value: unknown): boolean {\n    this._logger.debug('isMatch()');\n    const $value = this.value;\n    if (isArray($value)) {\n      if (this._observer === void 0) {\n        this._observer = this._observeCollection($value);\n      }\n      return $value.includes(value);\n    }\n    return $value === value;\n  }\n\n  public valueChanged(newValue: unknown, _oldValue: unknown): void {\n    if (isArray(newValue)) {\n      this._observer?.unsubscribe(this);\n      this._observer = this._observeCollection(newValue);\n    } else if (this._observer !== void 0) {\n      this._observer.unsubscribe(this);\n    }\n    this.$switch.caseChanged(this);\n  }\n\n  public handleCollectionChange(): void {\n    this.$switch.caseChanged(this);\n  }\n\n  public activate(initiator: IHydratedController | null, scope: Scope): void | Promise<void> {\n    let view = this.view;\n    if (view === void 0) {\n      view = this.view = this._factory.create().setLocation(this._location);\n    }\n    if (view.isActive) { return; }\n    return view.activate(initiator ?? view, this.$controller, scope);\n  }\n\n  public deactivate(initiator: IHydratedController | null): void | Promise<void> {\n    const view = this.view;\n    if (view === void 0 || !view.isActive) { return; }\n    return view.deactivate(initiator ?? view, this.$controller);\n  }\n\n  public dispose(): void {\n    this._observer?.unsubscribe(this);\n    this.view?.dispose();\n    this.view = (void 0)!;\n  }\n\n  protected linkToSwitch(auSwitch: Switch): void {\n    auSwitch.cases.push(this);\n  }\n\n  /** @internal */\n  private _observeCollection($value: unknown[]) {\n    const observer = this._locator.getArrayObserver($value);\n    observer.subscribe(this);\n    return observer;\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    if (this.$controller.accept(visitor) === true) {\n      return true;\n    }\n    return this.view?.accept(visitor);\n  }\n}\n\nexport class DefaultCase extends Case {\n  static {\n    defineAttribute({ name: 'default-case', bindables, isTemplateController: true }, DefaultCase);\n  }\n\n  protected linkToSwitch($switch: Switch): void {\n    if ($switch.defaultCase !== void 0) {\n      throw createMappedError(ErrorNames.switch_no_multiple_default);\n    }\n    $switch.defaultCase = this;\n  }\n}\n", "import { Task, TaskAbortError } from '@aurelia/platform';\nimport { ILogger, onResolve, onResolveAll, resolve, isPromise, registrableMetadataKey } from '@aurelia/kernel';\nimport { Scope } from '@aurelia/runtime';\nimport { INode, IRenderLocation } from '../../dom';\nimport { IPlatform } from '../../platform';\nimport { fromView, toView } from '../../binding/interfaces-bindings';\nimport {\n  Controller,\n  ICustomAttributeController,\n  ICustomAttributeViewModel,\n  IHydratableController,\n  IHydratedController,\n  IHydratedParentController,\n  ISyntheticView\n} from '../../templating/controller';\nimport { IViewFactory } from '../../templating/view';\nimport { IInstruction, AttrSyntax, AttributePattern } from '@aurelia/template-compiler';\nimport { CustomAttributeStaticAuDefinition, attrTypeName } from '../custom-attribute';\nimport { safeString, tsRunning } from '../../utilities';\nimport { ErrorNames, createMappedError } from '../../errors';\n\nexport class PromiseTemplateController implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'promise',\n    isTemplateController: true,\n    bindables: ['value'],\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n  private view!: ISyntheticView;\n\n  public value!: Promise<unknown>;\n\n  public pending?: PendingTemplateController;\n  public fulfilled?: FulfilledTemplateController;\n  public rejected?: RejectedTemplateController;\n\n  private viewScope!: Scope;\n  private preSettledTask: Task<void | Promise<void>> | null = null;\n  private postSettledTask: Task<void | Promise<void>> | null = null;\n  private postSettlePromise!: Promise<void>;\n\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n  /** @internal */ private readonly _platform = resolve(IPlatform);\n  /** @internal */ private readonly logger = resolve(ILogger).scopeTo('promise.resolve');\n\n  public link(\n    _controller: IHydratableController,\n    _childController: ICustomAttributeController,\n    _target: INode,\n    _instruction: IInstruction,\n  ): void {\n    this.view = this._factory.create(this.$controller).setLocation(this._location);\n  }\n\n  public attaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    const view = this.view;\n    const $controller = this.$controller;\n\n    return onResolve(\n      view.activate(initiator, $controller, this.viewScope = Scope.fromParent($controller.scope, {})),\n      () => this.swap(initiator)\n    );\n  }\n\n  public valueChanged(_newValue: boolean, _oldValue: boolean): void {\n    if (!this.$controller.isActive) { return; }\n    this.swap(null);\n  }\n\n  private swap(initiator: IHydratedController | null): void {\n    const value = this.value;\n    if (!isPromise(value)) {\n      if (__DEV__) {\n        /* istanbul ignore next */\n        this.logger.warn(`The value '${safeString(value)}' is not a promise. No change will be done.`);\n      }\n      return;\n    }\n    const q = this._platform.domQueue;\n    const fulfilled = this.fulfilled;\n    const rejected = this.rejected;\n    const pending = this.pending;\n    const s = this.viewScope;\n\n    let preSettlePromise: Promise<void>;\n    const $swap = () => {\n      // Note that the whole thing is not wrapped in a q.queueTask intentionally.\n      // Because that would block the app till the actual promise is resolved, which is not the goal anyway.\n      void onResolveAll(\n        // At first deactivate the fulfilled and rejected views, as well as activate the pending view.\n        // The order of these 3 should not necessarily be sequential (i.e. order-irrelevant).\n        preSettlePromise = (this.preSettledTask = q.queueTask(() => {\n          return onResolveAll(\n            fulfilled?.deactivate(initiator),\n            rejected?.deactivate(initiator),\n            pending?.activate(initiator, s)\n          );\n        })).result.catch((err) => { if (!(err instanceof TaskAbortError)) throw err; }),\n        value\n          .then(\n            (data) => {\n              if (this.value !== value) {\n                return;\n              }\n              const fulfill = () => {\n                // Deactivation of pending view and the activation of the fulfilled view should not necessarily be sequential.\n                this.postSettlePromise = (this.postSettledTask = q.queueTask(() => onResolveAll(\n                  pending?.deactivate(initiator),\n                  rejected?.deactivate(initiator),\n                  fulfilled?.activate(initiator, s, data),\n                ))).result;\n              };\n              if (this.preSettledTask!.status === tsRunning) {\n                void preSettlePromise.then(fulfill);\n              } else {\n                this.preSettledTask!.cancel();\n                fulfill();\n              }\n            },\n            (err) => {\n              if (this.value !== value) {\n                return;\n              }\n              const reject = () => {\n                // Deactivation of pending view and the activation of the rejected view should also not necessarily be sequential.\n                this.postSettlePromise = (this.postSettledTask = q.queueTask(() => onResolveAll(\n                  pending?.deactivate(initiator),\n                  fulfilled?.deactivate(initiator),\n                  rejected?.activate(initiator, s, err),\n                ))).result;\n              };\n              if (this.preSettledTask!.status === tsRunning) {\n                void preSettlePromise.then(reject);\n              } else {\n                this.preSettledTask!.cancel();\n                reject();\n              }\n            },\n          ));\n    };\n\n    if (this.postSettledTask?.status === tsRunning) {\n      void this.postSettlePromise.then($swap);\n    } else {\n      this.postSettledTask?.cancel();\n      $swap();\n    }\n  }\n\n  public detaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    this.preSettledTask?.cancel();\n    this.postSettledTask?.cancel();\n    this.preSettledTask = this.postSettledTask = null;\n    return this.view.deactivate(initiator, this.$controller);\n  }\n\n  public dispose(): void {\n    this.view?.dispose();\n    this.view = (void 0)!;\n  }\n}\n\nexport class PendingTemplateController implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'pending',\n    isTemplateController: true,\n    bindables: {\n      value: { mode: toView }\n    }\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n\n  public value!: Promise<unknown>;\n\n  public view: ISyntheticView | undefined = void 0;\n\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n\n  public link(\n    controller: IHydratableController,\n    _childController: ICustomAttributeController,\n    _target: INode,\n    _instruction: IInstruction,\n  ): void {\n    getPromiseController(controller).pending = this;\n  }\n\n  public activate(initiator: IHydratedController | null, scope: Scope): void | Promise<void> {\n    let view = this.view;\n    if (view === void 0) {\n      view = this.view = this._factory.create().setLocation(this._location);\n    }\n    if (view.isActive) { return; }\n    return view.activate(view, this.$controller, scope);\n  }\n\n  public deactivate(_initiator: IHydratedController | null): void | Promise<void> {\n    const view = this.view;\n    if (view === void 0 || !view.isActive) { return; }\n    return view.deactivate(view, this.$controller);\n  }\n\n  public detaching(initiator: IHydratedController): void | Promise<void> {\n    return this.deactivate(initiator);\n  }\n\n  public dispose(): void {\n    this.view?.dispose();\n    this.view = (void 0)!;\n  }\n}\n\nexport class FulfilledTemplateController implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'then',\n    isTemplateController: true,\n    bindables: {\n      value: { mode: fromView }\n    }\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n\n  public value!: unknown;\n\n  public view: ISyntheticView | undefined = void 0;\n\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n\n  public link(\n    controller: IHydratableController,\n    _childController: ICustomAttributeController,\n    _target: INode,\n    _instruction: IInstruction,\n  ): void {\n    getPromiseController(controller).fulfilled = this;\n  }\n\n  public activate(initiator: IHydratedController | null, scope: Scope, resolvedValue: unknown): void | Promise<void> {\n    this.value = resolvedValue;\n    let view = this.view;\n    if (view === void 0) {\n      view = this.view = this._factory.create().setLocation(this._location);\n    }\n    if (view.isActive) { return; }\n    return view.activate(view, this.$controller, scope);\n  }\n\n  public deactivate(_initiator: IHydratedController | null): void | Promise<void> {\n    const view = this.view;\n    if (view === void 0 || !view.isActive) { return; }\n    return view.deactivate(view, this.$controller);\n  }\n\n  public detaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    return this.deactivate(initiator);\n  }\n\n  public dispose(): void {\n    this.view?.dispose();\n    this.view = (void 0)!;\n  }\n}\n\nexport class RejectedTemplateController implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'catch',\n    isTemplateController: true,\n    bindables: {\n      value: { mode: fromView }\n    }\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n\n  public value!: unknown;\n\n  public view: ISyntheticView | undefined = void 0;\n\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n\n  public link(\n    controller: IHydratableController,\n    _childController: ICustomAttributeController,\n    _target: INode,\n    _instruction: IInstruction,\n  ): void {\n    getPromiseController(controller).rejected = this;\n  }\n\n  public activate(initiator: IHydratedController | null, scope: Scope, error: unknown): void | Promise<void> {\n    this.value = error;\n    let view = this.view;\n    if (view === void 0) {\n      view = this.view = this._factory.create().setLocation(this._location);\n    }\n    if (view.isActive) { return; }\n    return view.activate(view, this.$controller, scope);\n  }\n\n  public deactivate(_initiator: IHydratedController | null): void | Promise<void> {\n    const view = this.view;\n    if (view === void 0 || !view.isActive) { return; }\n    return view.deactivate(view, this.$controller);\n  }\n\n  public detaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    return this.deactivate(initiator);\n  }\n\n  public dispose(): void {\n    this.view?.dispose();\n    this.view = (void 0)!;\n  }\n}\n\nfunction getPromiseController(controller: IHydratableController) {\n  const promiseController: IHydratedParentController = (controller as Controller).parent! as IHydratedParentController;\n  const $promise = promiseController?.viewModel;\n  if ($promise instanceof PromiseTemplateController) {\n    return $promise;\n  }\n  throw createMappedError(ErrorNames.promise_invalid_usage);\n}\n\nexport class PromiseAttributePattern {\n  public static [Symbol.metadata] = {\n    [registrableMetadataKey]: AttributePattern.create([{ pattern: 'promise.resolve', symbols: '' }], PromiseAttributePattern)\n  };\n  public 'promise.resolve'(name: string, value: string): AttrSyntax {\n    return new AttrSyntax(name, value, 'promise', 'bind');\n  }\n}\n\nexport class FulfilledAttributePattern {\n  public static [Symbol.metadata] = {\n    [registrableMetadataKey]: AttributePattern.create([{ pattern: 'then', symbols: '' }], FulfilledAttributePattern)\n  };\n  public 'then'(name: string, value: string): AttrSyntax {\n    return new AttrSyntax(name, value, 'then', 'from-view');\n  }\n}\n\nexport class RejectedAttributePattern {\n  public static [Symbol.metadata] = {\n    [registrableMetadataKey]: AttributePattern.create([{ pattern: 'catch', symbols: '' }], RejectedAttributePattern)\n  };\n  public 'catch'(name: string, value: string): AttrSyntax {\n    return new AttrSyntax(name, value, 'catch', 'from-view');\n  }\n}\n", "import { twoWay } from '../../binding/interfaces-bindings';\nimport { INode } from '../../dom';\nimport { IPlatform } from '../../platform';\nimport { attrTypeName, type CustomAttributeStaticAuDefinition } from '../custom-attribute';\nimport type { ICustomAttributeController, ICustomAttributeViewModel } from '../../templating/controller';\nimport { resolve } from '@aurelia/kernel';\n\n/**\n * Focus attribute for element focus binding\n */\nexport class Focus implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'focus',\n    bindables: {\n      value: { mode: twoWay },\n    }\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>;\n\n  public value: unknown;\n\n  /**\n   * Indicates whether `apply` should be called when `attached` callback is invoked\n   *\n   * @internal\n   */\n  private _needsApply: boolean = false;\n\n  /** @internal */\n  private readonly _element = resolve(INode) as INode<HTMLElement>;\n\n  /** @internal */\n  private readonly _platform = resolve(IPlatform);\n\n  public binding(): void {\n    this.valueChanged();\n  }\n\n  /**\n   * Invoked everytime the bound value changes.\n   *\n   * @param newValue - The new value.\n   */\n  public valueChanged(): void {\n    // In theory, we could/should react immediately\n    // but focus state of an element cannot be achieved\n    // while it's disconnected from the document\n    // thus, there neesd to be a check if it's currently connected or not\n    // before applying the value to the element\n    if (this.$controller.isActive) {\n      this._apply();\n    } else {\n      // If the element is not currently connect\n      // toggle the flag to add pending work for later\n      // in attached lifecycle\n      this._needsApply = true;\n    }\n  }\n\n  /**\n   * Invoked when the attribute is attached to the DOM.\n   */\n  public attached(): void {\n    if (this._needsApply) {\n      this._needsApply = false;\n      this._apply();\n    }\n    this._element.addEventListener('focus', this);\n    this._element.addEventListener('blur', this);\n  }\n\n  /**\n   * Invoked when the attribute is afterDetachChildren from the DOM.\n   */\n  public detaching(): void {\n    const el = this._element;\n    el.removeEventListener('focus', this);\n    el.removeEventListener('blur', this);\n  }\n\n  /**\n   * EventTarget interface handler for better memory usage\n   */\n  public handleEvent(e: FocusEvent): void {\n    // there are only two event listened to\n    // if the even is focus, it menans the element is focused\n    // only need to switch the value to true\n    if (e.type === 'focus') {\n      this.value = true;\n    } else if (!this._isElFocused) {\n      // else, it's blur event\n      // when a blur event happens, there are two situations\n      // 1. the element itself lost the focus\n      // 2. window lost the focus\n      // To handle both (1) and (2), only need to check if\n      // current active element is still the same element of this focus custom attribute\n      // If it's not, it's a blur event happened on Window because the browser tab lost focus\n      this.value = false;\n    }\n  }\n\n  /**\n   * Focus/blur based on current value\n   *\n   * @internal\n   */\n  private _apply(): void {\n    const el = this._element;\n    const isFocused = this._isElFocused;\n    const shouldFocus = this.value;\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (shouldFocus && !isFocused) {\n      el.focus();\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    } else if (!shouldFocus && isFocused) {\n      el.blur();\n    }\n  }\n\n  /** @internal */\n  private get _isElFocused(): boolean {\n    return this._element === this._platform.document.activeElement;\n  }\n}\n", "import { onResolve, resolve, isPromise, isString } from '@aurelia/kernel';\nimport { IRenderLocation, setEffectiveParentNode } from '../../dom';\nimport { IPlatform } from '../../platform';\nimport { IViewFactory } from '../../templating/view';\nimport { CustomAttributeStaticAuDefinition, attrTypeName } from '../custom-attribute';\nimport { rethrow } from '../../utilities';\nimport { createLocation, insertManyBefore } from '../../utilities-dom';\nimport type { ControllerVisitor, ICustomAttributeController, ICustomAttributeViewModel, IHydratedController, ISyntheticView } from '../../templating/controller';\nimport { ErrorNames, createMappedError } from '../../errors';\n\nexport type PortalTarget = string | Element | null | undefined;\ntype ResolvedTarget = Element;\n\nexport type PortalLifecycleCallback = (target: PortalTarget, view: ISyntheticView) => void | Promise<void>;\n\nexport class Portal implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition<keyof Pick<\n    Portal,\n    'target' | 'position' | 'renderContext' | 'strict' | 'deactivating' | 'deactivated' | 'activated' | 'activating' | 'callbackContext'\n  >> = {\n    type: attrTypeName,\n    name: 'portal',\n    isTemplateController: true,\n    bindables: [\n      { name: 'target', primary: true },\n      'position',\n      'activated',\n      'activating',\n      'callbackContext',\n      { name: 'renderContext', callback: 'targetChanged' },\n      'strict',\n      'deactivated',\n      'deactivating'\n    ],\n    // bindables: {\n    //   target: { primary: true },\n    //   position: true,\n    //   renderContext: { callback: 'targetChanged' },\n    //   activated: true,\n    //   activating: true,\n    //   callbackContext: true,\n    //   deactivated: true,\n    //   deactivating: true,\n    //   strict: true\n    // }\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>;\n\n  public target: PortalTarget;\n  public position: InsertPosition = 'beforeend';\n  public renderContext: PortalTarget;\n  public strict: boolean = false;\n  public deactivating?: PortalLifecycleCallback;\n  public activating?: PortalLifecycleCallback;\n  public deactivated?: PortalLifecycleCallback;\n  public activated?: PortalLifecycleCallback;\n  public callbackContext: unknown;\n\n  public view: ISyntheticView;\n\n  /** @internal */ private _resolvedTarget: ResolvedTarget;\n  /** @internal */ private readonly _platform: IPlatform;\n  /** @internal */ private readonly _targetLocation: IRenderLocation;\n\n  public constructor() {\n    const factory = resolve(IViewFactory);\n    const originalLoc = resolve(IRenderLocation);\n    const p = resolve(IPlatform);\n    this._platform = p;\n    // to make the shape of this object consistent.\n    // todo: is this necessary\n    this._resolvedTarget = p.document.createElement('div');\n\n    (this.view = factory.create()).setLocation(\n      this._targetLocation = createLocation(p)\n    );\n    setEffectiveParentNode(this.view.nodes, originalLoc as unknown as Node);\n  }\n\n  public attaching(\n    initiator: IHydratedController,\n  ): void | Promise<void> {\n    if (this.callbackContext == null) {\n      this.callbackContext = this.$controller.scope.bindingContext;\n    }\n    const newTarget = this._resolvedTarget = this._getTarget();\n    this._moveLocation(newTarget, this.position);\n\n    return this._activating(initiator, newTarget);\n  }\n\n  public detaching(\n    initiator: IHydratedController,\n  ): void | Promise<void> {\n    return this._deactivating(initiator, this._resolvedTarget);\n  }\n\n  public targetChanged(): void {\n    const { $controller } = this;\n    if (!$controller.isActive) {\n      return;\n    }\n\n    const newTarget = this._getTarget();\n\n    if (this._resolvedTarget === newTarget) {\n      return;\n    }\n    this._resolvedTarget = newTarget;\n\n    // TODO(fkleuver): fix and test possible race condition\n    const ret = onResolve(\n      this._deactivating(null, newTarget),\n      () => {\n        this._moveLocation(newTarget, this.position);\n        return this._activating(null, newTarget);\n      },\n    );\n    if (isPromise(ret)) { ret.catch(rethrow); }\n  }\n\n  public positionChanged(): void {\n    const { $controller, _resolvedTarget } = this;\n    if (!$controller.isActive) {\n      return;\n    }\n    // TODO(fkleuver): fix and test possible race condition\n    const ret = onResolve(\n      this._deactivating(null, _resolvedTarget),\n      () => {\n        this._moveLocation(_resolvedTarget, this.position);\n        return this._activating(null, _resolvedTarget);\n      },\n    );\n    if (isPromise(ret)) { ret.catch(rethrow); }\n  }\n\n  /** @internal */\n  private _activating(\n    initiator: IHydratedController | null,\n    target: ResolvedTarget,\n  ): void | Promise<void> {\n    const { activating, callbackContext, view } = this;\n\n    // view.setHost(target);\n\n    return onResolve(\n      activating?.call(callbackContext, target, view),\n      () => {\n        return this._activate(initiator, target);\n      },\n    );\n  }\n\n  /** @internal */\n  private _activate(\n    initiator: IHydratedController | null,\n    target: ResolvedTarget,\n  ): void | Promise<void> {\n    const { $controller, view } = this;\n\n    if (initiator === null) {\n      view.nodes.insertBefore(this._targetLocation);\n    } else {\n      // TODO(fkleuver): fix and test possible race condition\n      return onResolve(\n        view.activate(initiator ?? view, $controller, $controller.scope),\n        () => {\n          return this._activated(target);\n        },\n      );\n    }\n\n    return this._activated(target);\n  }\n\n  /** @internal */\n  private _activated(\n    target: ResolvedTarget,\n  ): void | Promise<void> {\n    const { activated, callbackContext, view } = this;\n\n    return activated?.call(callbackContext, target, view);\n  }\n\n  /** @internal */\n  private _deactivating(\n    initiator: IHydratedController | null,\n    target: ResolvedTarget,\n  ): void | Promise<void> {\n    const { deactivating, callbackContext, view } = this;\n\n    return onResolve(\n      deactivating?.call(callbackContext, target, view),\n      () => {\n        return this._deactivate(initiator, target);\n      },\n    );\n  }\n\n  /** @internal */\n  private _deactivate(\n    initiator: IHydratedController | null,\n    target: ResolvedTarget,\n  ): void | Promise<void> {\n    const { $controller, view } = this;\n\n    if (initiator === null) {\n      view.nodes.remove();\n    } else {\n      return onResolve(\n        view.deactivate(initiator, $controller),\n        () => {\n          return this._deactivated(target);\n        },\n      );\n    }\n\n    return this._deactivated(target);\n  }\n\n  /** @internal */\n  private _deactivated(\n    target: ResolvedTarget,\n  ): void | Promise<void> {\n    const { deactivated, callbackContext, view } = this;\n\n    return onResolve(\n      deactivated?.call(callbackContext, target, view),\n      () => this._removeLocation()\n    );\n  }\n\n  /** @internal */\n  private _getTarget(): ResolvedTarget {\n    const p = this._platform;\n    // with a $ in front to make it less confusing/error prone\n    const $document = p.document;\n    let target = this.target;\n    let context = this.renderContext;\n\n    if (target === '') {\n      if (this.strict) {\n        throw createMappedError(ErrorNames.portal_query_empty);\n      }\n      return $document.body;\n    }\n\n    if (isString(target)) {\n      let queryContext: ParentNode = $document;\n      if (isString(context)) {\n        context = $document.querySelector(context) as ResolvedTarget;\n      }\n      if (context instanceof p.Node) {\n        queryContext = context;\n      }\n      target = queryContext.querySelector(target) as ResolvedTarget;\n    }\n\n    if (target instanceof p.Node) {\n      return target;\n    }\n\n    if (target == null) {\n      if (this.strict) {\n        throw createMappedError(ErrorNames.portal_no_target);\n      }\n      return $document.body;\n    }\n\n    return target;\n  }\n\n  /** @internal */\n  private _removeLocation(): void {\n    this._targetLocation.remove();\n    this._targetLocation.$start!.remove();\n  }\n\n  /** @internal */\n  private _moveLocation(target: Element, position: InsertPosition) {\n    const end = this._targetLocation;\n    const start = end.$start!;\n    const parent = target.parentNode;\n    const nodes = [start, end];\n    switch (position) {\n      case 'beforeend':\n        insertManyBefore(target, null, nodes);\n        break;\n      case 'afterbegin':\n        insertManyBefore(target, target.firstChild, nodes);\n        break;\n      case 'beforebegin':\n        insertManyBefore(parent, target, nodes);\n        break;\n      case 'afterend':\n        insertManyBefore(parent, target.nextSibling, nodes);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw createMappedError(ErrorNames.portal_invalid_insert_position, position);\n    }\n  }\n\n  public dispose(): void {\n    this.view.dispose();\n    this.view = (void 0)!;\n    this.callbackContext = null;\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    if (this.view?.accept(visitor) === true) {\n      return true;\n    }\n  }\n}\n", "import { IContainer, InstanceProvider, Writable, emptyArray, onResolve, resolve } from '@aurelia/kernel';\nimport { Scope } from '@aurelia/runtime';\nimport { IInstruction, type HydrateElementInstruction } from '@aurelia/template-compiler';\nimport { IRenderLocation } from '../../dom';\nimport { CustomElementDefinition, CustomElementStaticAuDefinition, elementTypeName } from '../custom-element';\nimport { IHydrationContext } from '../../templating/controller';\nimport { IRendering } from '../../templating/rendering';\nimport { registerResolver } from '../../utilities-di';\nimport { createMutationObserver, isElement } from '../../utilities-dom';\n\nimport type { ControllerVisitor, ICustomElementController, ICustomElementViewModel, IHydratedController, IHydratedParentController, ISyntheticView } from '../../templating/controller';\nimport type { IViewFactory } from '../../templating/view';\nimport { type IAuSlot, type IAuSlotSubscriber, IAuSlotWatcher, defaultSlotName, auslotAttr } from '../../templating/controller.projection';\n\nlet emptyTemplate: CustomElementDefinition;\n\nexport class AuSlot implements ICustomElementViewModel, IAuSlot {\n  public static readonly $au: CustomElementStaticAuDefinition = {\n    type: elementTypeName,\n    name: 'au-slot',\n    template: null,\n    containerless: true,\n    processContent(el, p, data) {\n      data.name = el.getAttribute('name') ?? defaultSlotName;\n\n      let node: Node | null = el.firstChild;\n      let next: Node | null = null;\n      while (node !== null) {\n        next = node.nextSibling;\n        if (isElement(node) && node.hasAttribute(auslotAttr)) {\n          if (__DEV__) {\n            // eslint-disable-next-line no-console\n            console.warn(\n              `[DEV:aurelia] detected [au-slot] attribute on a child node`,\n              `of an <au-slot> element: \"<${node.nodeName} au-slot>\".`,\n              `This element will be ignored and removed`\n            );\n          }\n          el.removeChild(node);\n        }\n        node = next;\n      }\n    },\n    bindables: ['expose', 'slotchange'],\n  };\n\n  public readonly view: ISyntheticView;\n  /** @internal */\n  public readonly $controller!: ICustomElementController<this>; // This is set by the controller after this instance is constructed\n\n  /** @internal */ private readonly _location: IRenderLocation;\n  /** @internal */ private _parentScope: Scope | null = null;\n  /** @internal */ private _outerScope: Scope | null = null;\n  /** @internal */ private readonly _hasProjection: boolean;\n  /** @internal */ private readonly _hdrContext: IHydrationContext;\n  /** @internal */ private readonly _slotwatchers: readonly IAuSlotWatcher[];\n  /** @internal */ private readonly _hasSlotWatcher: boolean;\n  /** @internal */ private _attached: boolean = false;\n\n  /**\n   * The binding context that will be exposed to slotted content\n   */\n  public expose: object | null = null;\n\n  /**\n   * A callback that will be called when the content of this slot changed\n   */\n  public slotchange: ((name: string, nodes: readonly Node[]) => void) | null = null;\n\n  public constructor() {\n    const hdrContext = resolve(IHydrationContext);\n    const location = resolve(IRenderLocation);\n    const instruction = resolve(IInstruction) as HydrateElementInstruction<{ name: string }>;\n    const rendering = resolve(IRendering);\n    const slotName = this.name = instruction.data.name;\n    // when <au-slot> is empty, there's not even projections\n    // hence ?. operator is used\n    // for fallback, there's only default slot used\n    const fallback = instruction.projections?.[defaultSlotName];\n    const projection = hdrContext.instruction?.projections?.[slotName];\n    const contextContainer = hdrContext.controller.container;\n    let factory: IViewFactory;\n    let container: IContainer;\n\n    if (projection == null) {\n      container = contextContainer.createChild({ inheritParentResources: true });\n      factory = rendering.getViewFactory(fallback ?? (emptyTemplate ??= CustomElementDefinition.create({\n        name: 'au-slot-empty-template',\n        template: '',\n        needsCompile: false,\n      })), container);\n      this._hasProjection = false;\n    } else {\n      // projection could happen within a projection, example:\n      // --my-app--\n      // <s-1>\n      //   ---projection 1---\n      //   <s-2>\n      //     ---projection 2---\n      //     <s-3>\n      // for the template above, if <s-3> is injecting <S1>,\n      // we won't find the information in the hydration context hierarchy <MyApp>/<S3>\n      // as it's a flat wysiwyg structure based on the template html\n      //\n      // since we are constructing the projection (2) view based on the\n      // container of <my-app>, we need to pre-register all information stored\n      // in projection (1) into the container created for the projection (2) view\n      // =============================\n\n      // my-app template:\n      // my-app  --- hydration context\n      // <el>     --- owning element (this has this <au-slot> that uses ---projection)\n      //   <s-1>  --- projection\n      //\n      container = contextContainer.createChild();\n      // registering resources from the parent hydration context is necessary\n      // as that's where the projection is declared in the template\n      //\n      // if neccessary, we can do the same gymnastic of registering information related to\n      // a custom element registration like in renderer.ts from line 1088 to 1098\n      // so we don't accidentally get information related to owning element (host, controller, instruction etc...)\n      // although it may be more desirable to have owning element information available here\n      container.useResources(hdrContext.parent!.controller.container);\n      // doing this to shadow the owning element hydration context\n      // since we created a container out of the owning element container\n      // instead of the hydration context container\n      registerResolver(container, IHydrationContext, new InstanceProvider(void 0, hdrContext.parent));\n      factory = rendering.getViewFactory(projection, container);\n      this._hasProjection = true;\n      this._slotwatchers = contextContainer.getAll(IAuSlotWatcher, false)?.filter(w => w.slotName === '*' || w.slotName === slotName) ?? emptyArray;\n    }\n    this._hasSlotWatcher = (this._slotwatchers ??= emptyArray).length > 0;\n    this._hdrContext = hdrContext;\n    this.view = factory.create().setLocation(this._location = location);\n  }\n\n  // all the following properties (name, nodes, _subs, subscribe & unsubscribe) are relevant to the slot watcher feature\n  // so grouping them here for better readability\n\n  public readonly name: string;\n\n  public get nodes() {\n    const nodes = [];\n    const location = this._location;\n    let curr = location.$start!.nextSibling;\n    while (curr != null && curr !== location) {\n      if (curr.nodeType !== /* comment */8) {\n        nodes.push(curr);\n      }\n      curr = curr.nextSibling;\n    }\n    return nodes;\n  }\n  /** @internal */\n  private readonly _subs = new Set<IAuSlotSubscriber>();\n\n  public subscribe(subscriber: IAuSlotSubscriber): void {\n    this._subs.add(subscriber);\n  }\n\n  public unsubscribe(subscriber: IAuSlotSubscriber): void {\n    this._subs.delete(subscriber);\n  }\n\n  public binding(\n    _initiator: IHydratedController,\n    parent: IHydratedParentController,\n  ): void | Promise<void> {\n    this._parentScope = parent.scope;\n\n    // The following block finds the real host scope for the content of this <au-slot>\n    //\n    // if this <au-slot> was created by another au slot, the controller hierarchy will be like this:\n    // C(au-slot)#1 --> C(synthetic)#1 --> C(au-slot)#2 --> C(synthetic)#2\n    //\n    // C(synthetic)#2 is what will provide the content for C(au-slot)#1\n    // but C(au-slot)#1 is what will provide the $host value for the content of C(au-slot)#2\n    //\n    // example:\n    // <template as-custom-element=\"parent\">\n    //   <child>\n    //    <au-slot> #2\n    //   </child>\n    // ...\n    // <template as-custom-element=\"child\">\n    //  <au-slot> #1\n    //\n    // because of this structure, walk 2 level of controller at once to find the right parent scope for $host value\n    while (parent.vmKind === 'synthetic' && parent.parent?.viewModel instanceof AuSlot) {\n      parent = parent.parent.parent as IHydratedParentController;\n    }\n    const host = parent.scope.bindingContext;\n\n    let outerScope: Scope;\n    if (this._hasProjection) {\n      // if there is a projection,\n      // then the au-slot should connect the outer scope with the inner scope binding context\n      // via overlaying the outerscope with another scope that has\n      // - binding context & override context pointing to the outer scope binding & override context respectively\n      // - override context has the $host pointing to inner scope binding context\n      outerScope = this._hdrContext.controller.scope.parent!;\n      (this._outerScope = Scope.fromParent(outerScope, outerScope.bindingContext))\n        .overrideContext.$host = this.expose ?? host;\n    }\n  }\n\n  public attaching(\n    initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    return onResolve(this.view.activate(\n      initiator,\n      this.$controller,\n      this._hasProjection ? this._outerScope! : this._parentScope!,\n    ), () => {\n      if (this._hasSlotWatcher) {\n        this._slotwatchers.forEach(w => w.watch(this));\n        this._observe();\n        this._notifySlotChange();\n        this._attached = true;\n      }\n    });\n  }\n\n  public detaching(\n    initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    this._attached = false;\n    this._unobserve();\n    this._slotwatchers.forEach(w => w.unwatch(this));\n    return this.view.deactivate(initiator, this.$controller);\n  }\n\n  public exposeChanged(v: object): void {\n    if (this._hasProjection && this._outerScope != null) {\n      this._outerScope.overrideContext.$host = v;\n    }\n  }\n\n  public dispose(): void {\n    this.view.dispose();\n    (this as Writable<this>).view = (void 0)!;\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    if (this.view?.accept(visitor) === true) {\n      return true;\n    }\n  }\n\n  /** @internal */\n  private _observer: MutationObserver | null = null;\n  /** @internal */\n  private _observe(): void {\n    if (this._observer != null) {\n      return;\n    }\n    const location = this._location;\n    const parent = location.parentElement;\n    if (parent == null) {\n      return;\n    }\n    (this._observer = createMutationObserver(parent, records => {\n      if (isMutationWithinLocation(location, records)) {\n        this._notifySlotChange();\n      }\n    })).observe(parent, { childList: true });\n  }\n\n  /** @internal */\n  private _unobserve(): void {\n    this._observer?.disconnect();\n    this._observer = null;\n  }\n\n  /** @internal */\n  private _notifySlotChange() {\n    const nodes = this.nodes;\n    const subs = new Set(this._subs);\n    let sub: IAuSlotSubscriber;\n    if (this._attached) {\n      this.slotchange?.call(void 0, this.name, nodes);\n    }\n    for (sub of subs) {\n      sub.handleSlotChange(this, nodes);\n    }\n  }\n}\n\nconst comparePosition = (a: Node, b: Node) => a.compareDocumentPosition(b);\nconst isMutationWithinLocation = (location: IRenderLocation, records: MutationRecord[]) => {\n  for (const { addedNodes, removedNodes, nextSibling } of records) {\n    let i = 0;\n    // eslint-disable-next-line prefer-const\n    let ii = addedNodes.length;\n    let node: Node;\n    for (; i < ii; ++i) {\n      node = addedNodes[i];\n      if (comparePosition(location.$start!, node) === /* DOCUMENT_POSITION_FOLLOWING */4\n        && comparePosition(location, node) === /* DOCUMENT_POSITION_PRECEDING */2\n      ) {\n        return true;\n      }\n    }\n    if (removedNodes.length > 0) {\n      if (nextSibling != null && comparePosition(location.$start!, nextSibling) === /* DOCUMENT_POSITION_FOLLOWING */4\n        && comparePosition(location, nextSibling) === /* DOCUMENT_POSITION_PRECEDING */2\n      ) {\n        return true;\n      }\n    }\n  }\n};\n", "import { isFunction, isPromise, type Constructable, IContainer, InstanceProvider, type MaybePromise, emptyArray, onResolve, resolve, transient } from '@aurelia/kernel';\nimport { IExpressionParser } from '@aurelia/expression-parser';\nimport { IObserverLocator, Scope } from '@aurelia/runtime';\nimport { HydrateElementInstruction, IInstruction, ITemplateCompiler, AttrSyntax } from '@aurelia/template-compiler';\nimport { INode, IRenderLocation, convertToRenderLocation, registerHostNode } from '../../dom';\nimport { IPlatform } from '../../platform';\nimport { Controller, HydrationContext, IController, ICustomElementController, IHydratedController, IHydrationContext, ISyntheticView, vmkCe } from '../../templating/controller';\nimport { IRendering } from '../../templating/rendering';\nimport { registerResolver } from '../../utilities-di';\nimport { CustomElement, CustomElementDefinition, CustomElementStaticAuDefinition, elementTypeName } from '../custom-element';\nimport { ErrorNames, createMappedError } from '../../errors';\nimport { fromView } from '../../binding/interfaces-bindings';\nimport { SpreadBinding } from '../../binding/spread-binding';\n\n/**\n * An optional interface describing the dynamic composition activate convention.\n */\nexport interface IDynamicComponentActivate<T> {\n  /**\n   * Implement this hook if you want to perform custom logic just before the component is is composed.\n   * The returned value is not used.\n   */\n  activate?(model?: T): unknown;\n}\n\ntype ChangeSource = keyof Pick<AuCompose, 'template' | 'component' | 'model' | 'scopeBehavior' | 'composing' | 'composition' | 'tag'>;\n\n// Desired usage:\n// <au-component template.bind=\"Promise<string>\" component.bind=\"\" model.bind=\"\" />\n// <au-component template.bind=\"<string>\" model.bind=\"\" />\nexport class AuCompose {\n  /** @internal */\n  public static readonly $au: CustomElementStaticAuDefinition<keyof Pick<\n    AuCompose,\n    'template' | 'component' | 'model' | 'scopeBehavior' | 'composing' | 'composition' | 'tag'\n  >> = {\n    type: elementTypeName,\n    name: 'au-compose',\n    capture: true,\n    containerless: true,\n    bindables: [\n      'template',\n      'component',\n      'model',\n      { name: 'scopeBehavior', set: v => {\n        if (v === 'scoped' || v === 'auto') {\n          return v;\n        }\n        throw createMappedError(ErrorNames.au_compose_invalid_scope_behavior, v);\n      }},\n      { name: 'composing', mode: fromView},\n      { name: 'composition', mode: fromView },\n      'tag'\n    ]\n  };\n\n  /* determine what template used to compose the component */\n  public template?: string | Promise<string>;\n\n  /**\n   * Determine the component instance used to compose the component.\n   *\n   * - When a string is given as a value, it will be used as the name of the custom element to compose.\n   * If there is no locally or globally registered custom element with that name, an error will be thrown.\n   *\n   * - When an object is given as a value, the object will be used as the component instance.\n   * - When a constructor is given as a value, the constructor will be used to create the component instance.\n   * - When a null/undefined is given as a value, the component will be composed as a template-only composition with an empty component instance.\n   * - When a promise is given as a value, the promise will be awaited and the resolved value will be used as the value.\n   */\n  public component?: string | Constructable | object | Promise<string | Constructable | object>;\n\n  /* the model used to pass to activate lifecycle of the component */\n  public model?: unknown;\n\n  /**\n   * Control scoping behavior of the view created by the au-compose.\n   * This only affects template-only composition. Does not have effects on custom element composition.\n   *\n   * auto = inherit parent scope\n   * scoped = do not inherit parent scope\n   */\n  public scopeBehavior: 'auto' | 'scoped' = 'auto';\n\n  /** @internal */\n  private _composing?: Promise<void> | void;\n  public get composing(): Promise<void> | void {\n    return this._composing;\n  }\n\n  /** @internal */\n  private _composition: ICompositionController | undefined = void 0;\n  public get composition(): ICompositionController | undefined {\n    return this._composition;\n  }\n\n  /**\n   * The tag name of the element to be created for non custom element composition.\n   *\n   * `null`/`undefined` means containerless\n   */\n  public tag: string | null | undefined = null;\n\n  /** @internal */ public readonly $controller!: ICustomElementController<AuCompose>;\n  /** @internal */ private readonly _container = resolve(IContainer);\n  /** @internal */ private readonly parent = resolve(IController) as ISyntheticView | ICustomElementController;\n  /** @internal */ private readonly _host = resolve(INode) as HTMLElement;\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n  /** @internal */ private readonly _platform = resolve(IPlatform);\n  /** @internal */ private readonly _rendering = resolve(IRendering);\n  /** @internal */ private readonly _instruction = resolve(IInstruction) as HydrateElementInstruction;\n  /** @internal */ private readonly _contextFactory = resolve(transient(CompositionContextFactory, null!));\n  /** @internal */ private readonly _compiler = resolve(ITemplateCompiler);\n  /** @internal */ private readonly _hydrationContext = resolve(IHydrationContext);\n  /** @internal */ private readonly _exprParser = resolve(IExpressionParser);\n  /** @internal */ private readonly _observerLocator = resolve(IObserverLocator);\n\n  public attaching(initiator: IHydratedController, _parent: IHydratedController): void | Promise<void> {\n    return this._composing = onResolve(\n      this.queue(new ChangeInfo(this.template, this.component, this.model, void 0), initiator),\n      (context) => {\n        if (this._contextFactory._isCurrent(context)) {\n          this._composing = void 0;\n        }\n      }\n    );\n  }\n\n  public detaching(initiator: IHydratedController): void | Promise<void> {\n    const cmpstn = this._composition;\n    const pending = this._composing;\n    this._contextFactory.invalidate();\n    this._composition = this._composing = void 0;\n    return onResolve(pending, () => cmpstn?.deactivate(initiator));\n  }\n\n  /** @internal */\n  public propertyChanged(name: ChangeSource): void {\n    if (name === 'composing' || name === 'composition') return;\n    if (name === 'model' && this._composition != null) {\n      this._composition.update(this.model);\n      return;\n    }\n    // tag change does not affect existing custom element composition\n    if (name === 'tag' && this._composition?.controller.vmKind === vmkCe) {\n      if (__DEV__) {\n        console.warn('[DEV:aurelia] Changing tag name of a custom element composition is ignored.'); // eslint-disable-line\n      }\n      return;\n    }\n\n    this._composing = onResolve(this._composing, () =>\n      onResolve(\n        this.queue(new ChangeInfo(this.template, this.component, this.model, name), void 0),\n        (context) => {\n          if (this._contextFactory._isCurrent(context)) {\n            this._composing = void 0;\n          }\n        }\n      )\n    );\n  }\n\n  /** @internal */\n  private queue(change: ChangeInfo, initiator: IHydratedController | undefined): CompositionContext | Promise<CompositionContext> {\n    const factory = this._contextFactory;\n    const prevCompositionCtrl = this._composition;\n    // todo: handle consequitive changes that create multiple queues\n    return onResolve(\n      factory.create(change),\n      context => {\n        // Don't compose [stale] template/component\n        // by always ensuring that the composition context is the latest one\n        if (factory._isCurrent(context)) {\n          return onResolve(this.compose(context), (result) => {\n            // Don't activate [stale] controller\n            // by always ensuring that the composition context is the latest one\n            if (factory._isCurrent(context)) {\n              return onResolve(result.activate(initiator), () => {\n                // Don't conclude the [stale] composition\n                // by always ensuring that the composition context is the latest one\n                if (factory._isCurrent(context)) {\n                  // after activation, if the composition context is still the most recent one\n                  // then the job is done\n                  this._composition = result;\n                  return onResolve(prevCompositionCtrl?.deactivate(initiator), () => context);\n                } else {\n                  // the stale controller should be deactivated\n                  return onResolve(\n                    result.controller.deactivate(result.controller, this.$controller),\n                    // todo: do we need to deactivate?\n                    () => {\n                      result.controller.dispose();\n                      return context;\n                    }\n                  );\n                }\n              });\n            }\n\n            result.controller.dispose();\n            return context;\n          });\n        }\n\n        return context;\n      }\n    );\n  }\n\n  /** @internal */\n  private compose(context: CompositionContext): MaybePromise<ICompositionController> {\n    // todo: when both component and template are empty\n    //       should it throw or try it best to proceed?\n    //       current: proceed\n    const {\n      _template: template,\n      _component: component,\n      _model: model\n    } = context.change;\n    const {\n      _container: container,\n      $controller,\n      _location: loc,\n      _instruction\n    } = this;\n    const vmDef = this._getDefinition(this._hydrationContext.controller.container, component);\n    const childCtn: IContainer = container.createChild();\n\n    const compositionHost = this._platform.document.createElement(vmDef == null ? this.tag ?? 'div' : vmDef.name);\n\n    loc.parentNode!.insertBefore(compositionHost, loc);\n\n    let compositionLocation: IRenderLocation | null;\n    if (vmDef == null) {\n      compositionLocation = this.tag == null ? convertToRenderLocation(compositionHost) : null;\n    } else {\n      compositionLocation = vmDef.containerless ? convertToRenderLocation(compositionHost) : null;\n    }\n\n    const removeCompositionHost = () => {\n      compositionHost.remove();\n      if (compositionLocation != null) {\n        let curr = compositionLocation.$start!.nextSibling;\n        let next: ChildNode | null = null;\n        while (curr !== null && curr !== compositionLocation) {\n          next = curr.nextSibling;\n          curr.remove();\n          curr = next;\n        }\n        compositionLocation.$start?.remove();\n        compositionLocation.remove();\n      }\n    };\n\n    const comp = this._createComponentInstance(\n      childCtn,\n      typeof component === 'string' ? vmDef!.Type : component,\n      compositionHost,\n      compositionLocation\n    );\n    const compose: () => ICompositionController = () => {\n      const aucomposeCapturedAttrs = _instruction.captures! ?? emptyArray;\n      // custom element based composition\n      if (vmDef !== null) {\n        const capture = vmDef.capture;\n        const [capturedBindingAttrs, transferedToHostBindingAttrs] = aucomposeCapturedAttrs\n          .reduce((attrGroups: [AttrSyntax[], AttrSyntax[]], attr) => {\n            const shouldCapture = !(attr.target in vmDef.bindables)\n              && (capture === true\n                || isFunction(capture) && !!capture(attr.target));\n            attrGroups[shouldCapture ? 0 : 1].push(attr);\n            return attrGroups;\n          }, [[], []]);\n\n        const controller = Controller.$el(\n          childCtn,\n          comp,\n          compositionHost,\n          {\n            projections: _instruction.projections,\n            captures: capturedBindingAttrs\n          },\n          vmDef,\n          compositionLocation\n        );\n        // Theoretically these bindings aren't bindings of the composed custom element\n        // Though they are meant to be activated (bound)/ deactivated (unbound) together\n        // with the custom element controller, so it's practically ok to let the composed\n        // custom element manage these bindings\n        this._createSpreadBindings(compositionHost, vmDef, transferedToHostBindingAttrs).forEach(b => controller.addBinding(b));\n\n        return new CompositionController(\n          controller,\n          (attachInitiator) => controller.activate(attachInitiator ?? controller, $controller, $controller.scope.parent!),\n          // todo: call deactivate on the component component\n          (deactachInitiator) => onResolve(\n            controller.deactivate(deactachInitiator ?? controller, $controller),\n            removeCompositionHost\n          ),\n          // casting is technically incorrect\n          // but it's ignored in the caller anyway\n          (model) => comp.activate?.(model),\n          context,\n        );\n      } else {\n        const targetDef = CustomElementDefinition.create({\n          name: CustomElement.generateName(),\n          template: template,\n        });\n        const viewFactory = this._rendering.getViewFactory(targetDef, childCtn);\n        const controller = Controller.$view(\n          viewFactory,\n          $controller\n        );\n        const scope = this.scopeBehavior === 'auto'\n          ? Scope.fromParent(this.parent.scope, comp)\n          : Scope.create(comp);\n\n        controller.setHost(compositionHost);\n        if (compositionLocation == null) {\n          // only spread the bindings if there is an actual host\n          // otherwise we may accidentally do unnecessary work\n          this._createSpreadBindings(compositionHost, targetDef, aucomposeCapturedAttrs).forEach(b => controller.addBinding(b));\n        } else {\n          controller.setLocation(compositionLocation);\n        }\n\n        return new CompositionController(\n          controller,\n          (attachInitiator) => controller.activate(attachInitiator ?? controller, $controller, scope),\n          // todo: call deactivate on the component\n          // a difference with composing custom element is that we leave render location/host alone\n          // as they all share the same host/render location\n          (detachInitiator) => onResolve(\n            controller.deactivate(detachInitiator ?? controller, $controller),\n            removeCompositionHost\n          ),\n          // casting is technically incorrect\n          // but it's ignored in the caller anyway\n          (model) => comp.activate?.(model),\n          context,\n        );\n      }\n    };\n    if ('activate' in comp) {\n      // todo: try catch\n      // req:  ensure synchronosity of compositions that dont employ promise\n      return onResolve(comp.activate!(model), () => compose());\n    } else {\n      return compose();\n    }\n  }\n\n  /** @internal */\n  private _createComponentInstance(\n    container: IContainer,\n    comp: Constructable | object | undefined,\n    host: HTMLElement | IRenderLocation,\n    location: IRenderLocation | null,\n  ): IDynamicComponentActivate<unknown> {\n    if (comp == null) {\n      return new EmptyComponent();\n    }\n    if (typeof comp === 'object') {\n      return comp;\n    }\n\n    const p = this._platform;\n    registerHostNode(container, host, p);\n    registerResolver(\n      container,\n      IRenderLocation,\n      new InstanceProvider('IRenderLocation', location)\n    );\n\n    const instance = container.invoke(comp);\n    registerResolver(container, comp, new InstanceProvider('au-compose.component', instance));\n\n    return instance;\n  }\n\n  /** @internal */\n  private _getDefinition(container: IContainer, component?: string | object | Constructable) {\n    if (typeof component === 'string') {\n      const def = CustomElement.find(container, component);\n      if (def == null) {\n        throw createMappedError(ErrorNames.au_compose_component_name_not_found, component);\n      }\n      return def;\n    }\n\n    const Ctor = (isFunction(component)\n      ? component\n      : component?.constructor) as Constructable;\n    return CustomElement.isType(Ctor, void 0)\n      ? CustomElement.getDefinition(Ctor, null)\n      : null;\n  }\n\n  /** @internal */\n  private _createSpreadBindings(host: HTMLElement, def: CustomElementDefinition, capturedAttrs: AttrSyntax[]) {\n    const transferHydrationContext = new HydrationContext(\n      this.$controller,\n      { projections: null, captures: capturedAttrs },\n      this._hydrationContext.parent\n    );\n    return SpreadBinding.create(\n      transferHydrationContext,\n      host,\n      def,\n      this._rendering,\n      this._compiler,\n      this._platform,\n      this._exprParser,\n      this._observerLocator,\n    );\n  }\n}\n\nclass EmptyComponent { }\n\nexport interface ICompositionController {\n  readonly controller: IHydratedController;\n  readonly context: CompositionContext;\n  activate(initiator?: IHydratedController): void | Promise<void>;\n  // deactivation is done differently, compared to activation\n  // when the `<au-component/>` is deactivated, initiator will be an ancestor controller\n  //\n  // while when the value of the @bindables changes, initiator should be\n  // the controller wrapped in this composition controller\n  deactivate(detachInitator?: IHydratedController): void | Promise<void>;\n  update(model: unknown): unknown;\n}\n\nclass CompositionContextFactory {\n  private id = 0;\n\n  public _isCurrent(context: CompositionContext): boolean {\n    return context.id === this.id;\n  }\n\n  public create(changes: ChangeInfo): MaybePromise<CompositionContext> {\n    return onResolve(changes.load(), (loaded) => new CompositionContext(++this.id, loaded));\n  }\n\n  // simplify increasing the id will invalidate all previously created context\n  public invalidate(): void {\n    this.id++;\n  }\n}\n\nclass ChangeInfo {\n  public constructor(\n    public readonly _template: MaybePromise<string> | undefined,\n    public readonly _component: MaybePromise<string | Constructable | object> | undefined,\n    public readonly _model: unknown,\n    public readonly _src: ChangeSource | undefined,\n  ) { }\n\n  public load(): MaybePromise<LoadedChangeInfo> {\n    if (isPromise(this._template) || isPromise(this._component)) {\n      return Promise\n        .all([this._template, this._component])\n        .then(([template, component]) => {\n          return new LoadedChangeInfo(template, component, this._model, this._src);\n        });\n    } else {\n      return new LoadedChangeInfo(this._template, this._component, this._model, this._src);\n    }\n  }\n}\n\nclass LoadedChangeInfo {\n  public constructor(\n    public readonly _template: string | undefined,\n    public readonly _component: string | Constructable | object | undefined,\n    public readonly _model: unknown,\n    public readonly _src: ChangeSource | undefined,\n  ) { }\n}\n\nclass CompositionContext {\n  public constructor(\n    public readonly id: number,\n    public readonly change: LoadedChangeInfo,\n  ) { }\n}\n\nclass CompositionController implements ICompositionController {\n  private state: /* stopped */-1 | /* initial */0 | /* started */1 = 0;\n\n  public constructor(\n    public readonly controller: ISyntheticView | ICustomElementController,\n    private readonly start: (attachInitiator?: IHydratedController) => void | Promise<void>,\n    private readonly stop: (detachInitator?: IHydratedController) => void | Promise<void>,\n    public readonly update: (model: unknown) => unknown,\n    public readonly context: CompositionContext,\n  ) {\n\n  }\n\n  public activate(initiator?: IHydratedController) {\n    if (this.state !== 0) {\n      throw createMappedError(ErrorNames.au_compose_invalid_run, this);\n    }\n    this.state = 1;\n    return this.start(initiator);\n  }\n\n  public deactivate(detachInitator?: IHydratedController) {\n    switch (this.state) {\n      case 1:\n        this.state = -1;\n        return this.stop(detachInitator);\n      case -1:\n        throw createMappedError(ErrorNames.au_compose_duplicate_deactivate);\n      default:\n        this.state = -1;\n    }\n  }\n}\n", "import { resolve } from '@aurelia/kernel';\nimport { createInterface } from '../../utilities-di';\nimport { type ValueConverterInstance, type ValueConverterStaticAuDefinition, converterTypeName } from '../value-converter';\nimport { ErrorNames, createMappedError } from '../../errors';\n\nexport interface ISanitizer {\n  /**\n   * Sanitizes the provided input.\n   *\n   * @param input - The input to be sanitized.\n   */\n  sanitize(input: string): string;\n}\n\nexport const ISanitizer = /*@__PURE__*/createInterface<ISanitizer>('ISanitizer', x => x.singleton(class {\n  public sanitize(): string {\n    throw createMappedError(ErrorNames.method_not_implemented, 'sanitize');\n  }\n}));\n\n/**\n * Simple html sanitization converter to preserve whitelisted elements and attributes on a bound property containing html.\n */\nexport class SanitizeValueConverter implements ValueConverterInstance {\n  public static readonly $au: ValueConverterStaticAuDefinition = {\n    type: converterTypeName,\n    name: 'sanitize',\n  };\n\n  /** @internal */ private readonly _sanitizer = resolve(ISanitizer);\n\n  /**\n   * Process the provided markup that flows to the view.\n   *\n   * @param untrustedMarkup - The untrusted markup to be sanitized.\n   */\n  public toView(untrustedMarkup: string): string|null {\n    if (untrustedMarkup == null) {\n      return null;\n    }\n\n    return this._sanitizer.sanitize(untrustedMarkup);\n  }\n}\n", "import { INode } from '../../dom';\nimport { IPlatform } from '../../platform';\nimport { attrTypeName, type CustomAttributeStaticAuDefinition } from '../custom-attribute';\n\nimport type { ITask } from '@aurelia/platform';\n\nimport type { ICustomAttributeViewModel } from '../../templating/controller';\nimport { IInstruction, HydrateAttributeInstruction } from '@aurelia/template-compiler';\nimport { resolve } from '@aurelia/kernel';\n\nexport class Show implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'show',\n    bindables: ['value'],\n    aliases: ['hide']\n  };\n\n  public value: unknown;\n\n  private readonly el = resolve(INode) as INode<HTMLElement>;\n  private readonly p = resolve(IPlatform);\n\n  /** @internal */ private _isActive: boolean = false;\n  /** @internal */ private _task: ITask | null = null;\n\n  /** @internal */ private _isToggled: boolean;\n  /** @internal */ private readonly _base: boolean;\n\n  public constructor() {\n    const instr = resolve(IInstruction) as HydrateAttributeInstruction;\n    // if this is declared as a 'hide' attribute, then this.base will be false, inverting everything.\n    this._isToggled = this._base = instr.alias !== 'hide';\n  }\n\n  public binding(): void {\n    this._isActive = true;\n    this.update();\n  }\n\n  public detaching() {\n    this._isActive = false;\n    this._task?.cancel();\n    this._task = null;\n  }\n\n  public valueChanged(): void {\n    if (this._isActive && this._task === null) {\n      this._task = this.p.domQueue.queueTask(this.update);\n    }\n  }\n\n  private $val: string = '';\n  private $prio: string = '';\n  private readonly update = (): void => {\n    this._task = null;\n\n    // Only compare at the synchronous moment when we're about to update, because the value might have changed since the update was queued.\n    if (Boolean(this.value) !== this._isToggled) {\n      if (this._isToggled === this._base) {\n        this._isToggled = !this._base;\n        // Note: in v1 we used the 'au-hide' class, but in v2 it's so trivial to conditionally apply classes (e.g. 'hide.class=\"someCondition\"'),\n        // that it's probably better to avoid the CSS inject infra involvement and keep this CA as simple as possible.\n        // Instead, just store and restore the property values (with each mutation, to account for in-between updates), to cover the common cases, until there is convincing feedback to do otherwise.\n        this.$val = this.el.style.getPropertyValue('display');\n        this.$prio = this.el.style.getPropertyPriority('display');\n        this.el.style.setProperty('display', 'none', 'important');\n      } else {\n        this._isToggled = this._base;\n        this.el.style.setProperty('display', this.$val, this.$prio);\n        // If the style attribute is now empty, remove it.\n        if (this.el.getAttribute('style') === '') {\n          this.el.removeAttribute('style');\n        }\n      }\n    }\n  };\n}\n", "import { IContainer, noop } from '@aurelia/kernel';\nimport { ExpressionParser } from '@aurelia/expression-parser';\nimport { DirtyChecker, ICoercionConfiguration } from '@aurelia/runtime';\nimport {\n  AtPrefixedTriggerAttributePattern,\n  ColonPrefixedBindAttributePattern,\n  DotSeparatedAttributePattern,\n  RefAttributePattern,\n  EventAttributePattern,\n\n  DefaultBindingCommand,\n  ForBindingCommand,\n  FromViewBindingCommand,\n  OneTimeBindingCommand,\n  ToViewBindingCommand,\n  TwoWayBindingCommand,\n  AttrBindingCommand,\n  CaptureBindingCommand,\n  ClassBindingCommand,\n  RefBindingCommand,\n  StyleBindingCommand,\n  TriggerBindingCommand,\n  SpreadValueBindingCommand,\n} from '@aurelia/template-compiler';\nimport {\n  CustomAttributeRenderer,\n  CustomElementRenderer,\n  InterpolationBindingRenderer,\n  IteratorBindingRenderer,\n  LetElementRenderer,\n  PropertyBindingRenderer,\n  RefBindingRenderer,\n  SetPropertyRenderer,\n  TemplateControllerRenderer,\n  AttributeBindingRenderer,\n  ListenerBindingRenderer,\n  SetAttributeRenderer,\n  StylePropertyBindingRenderer,\n  TextBindingRenderer,\n  SetClassAttributeRenderer,\n  SetStyleAttributeRenderer,\n  SpreadRenderer,\n  SpreadValueRenderer,\n} from './renderer';\nimport {\n  FromViewBindingBehavior,\n  OneTimeBindingBehavior,\n  ToViewBindingBehavior,\n  TwoWayBindingBehavior,\n} from './resources/binding-behaviors/binding-mode';\nimport { DebounceBindingBehavior } from './resources/binding-behaviors/debounce';\nimport { SignalBindingBehavior } from './resources/binding-behaviors/signals';\nimport { ThrottleBindingBehavior } from './resources/binding-behaviors/throttle';\nimport { AttrBindingBehavior } from './resources/binding-behaviors/attr';\nimport { SelfBindingBehavior } from './resources/binding-behaviors/self';\nimport { UpdateTriggerBindingBehavior } from './resources/binding-behaviors/update-trigger';\nimport { Focus } from './resources/custom-attributes/focus';\nimport { Show } from './resources/custom-attributes/show';\nimport { Portal } from './resources/template-controllers/portal';\nimport { Else, If } from './resources/template-controllers/if';\nimport { Repeat } from './resources/template-controllers/repeat';\nimport { With } from './resources/template-controllers/with';\nimport { Switch, Case, DefaultCase } from './resources/template-controllers/switch';\nimport {\n  PromiseTemplateController,\n  PendingTemplateController,\n  FulfilledTemplateController,\n  RejectedTemplateController,\n  PromiseAttributePattern,\n  FulfilledAttributePattern,\n  RejectedAttributePattern,\n} from './resources/template-controllers/promise';\nimport { AuCompose } from './resources/custom-elements/au-compose';\nimport { AuSlot } from './resources/custom-elements/au-slot';\nimport { SanitizeValueConverter } from './resources/value-converters/sanitize';\nimport { NodeObserverLocator } from './observation/observer-locator';\nimport { instanceRegistration } from './utilities-di';\nimport { EventModifierRegistration } from './binding/listener-binding';\nimport { RuntimeTemplateCompilerImplementation } from './compiler/template-compiler';\n\n/**\n * Default HTML-specific (but environment-agnostic) implementations for the following interfaces:\n * - `ITemplateCompiler`\n * - `ITargetAccessorLocator`\n * - `ITargetObserverLocator`\n */\nexport const DefaultComponents = [\n  RuntimeTemplateCompilerImplementation,\n  DirtyChecker,\n  NodeObserverLocator,\n];\n\n/**\n * Default binding syntax for the following attribute name patterns:\n * - `ref`\n * - `target.command` (dot-separated)\n */\nexport const DefaultBindingSyntax = [\n  RefAttributePattern,\n  DotSeparatedAttributePattern,\n  EventAttributePattern,\n  EventModifierRegistration,\n];\n\n/**\n * Binding syntax for short-hand attribute name patterns:\n * - `@target` (short-hand for `target.trigger`)\n * - `:target` (short-hand for `target.bind`)\n */\nexport const ShortHandBindingSyntax = [\n  AtPrefixedTriggerAttributePattern,\n  ColonPrefixedBindAttributePattern,\n];\n\n/**\n * Default HTML-specific (but environment-agnostic) binding commands:\n * - Property observation: `.bind`, `.one-time`, `.from-view`, `.to-view`, `.two-way\n * - Collection observation: `.for`\n * - Event listeners: `.trigger`, `.capture`\n */\nexport const DefaultBindingLanguage = [\n  DefaultBindingCommand,\n  OneTimeBindingCommand,\n  FromViewBindingCommand,\n  ToViewBindingCommand,\n  TwoWayBindingCommand,\n  ForBindingCommand,\n  RefBindingCommand,\n  TriggerBindingCommand,\n  CaptureBindingCommand,\n  ClassBindingCommand,\n  StyleBindingCommand,\n  AttrBindingCommand,\n  SpreadValueBindingCommand,\n];\n\n/**\n * Default HTML-specific (but environment-agnostic) resources:\n * - Binding Behaviors: `oneTime`, `toView`, `fromView`, `twoWay`, `signal`, `debounce`, `throttle`, `attr`, `self`, `updateTrigger`\n * - Custom Elements: `au-compose`, `au-slot`\n * - Custom Attributes: `blur`, `focus`, `portal`\n * - Template controllers: `if`/`else`, `repeat`, `with`\n * - Value Converters: `sanitize`\n */\nexport const DefaultResources = [\n  DebounceBindingBehavior,\n  OneTimeBindingBehavior,\n  ToViewBindingBehavior,\n  FromViewBindingBehavior,\n  SignalBindingBehavior,\n  ThrottleBindingBehavior,\n  TwoWayBindingBehavior,\n  SanitizeValueConverter,\n  If,\n  Else,\n  Repeat,\n  With,\n  Switch,\n  Case,\n  DefaultCase,\n  PromiseTemplateController,\n  PendingTemplateController,\n  FulfilledTemplateController,\n  RejectedTemplateController,\n  PromiseAttributePattern,\n  FulfilledAttributePattern,\n  RejectedAttributePattern,\n  AttrBindingBehavior,\n  SelfBindingBehavior,\n  UpdateTriggerBindingBehavior,\n  AuCompose,\n  Portal,\n  Focus,\n  Show,\n  AuSlot,\n];\n\n/**\n * Default renderers for:\n * - PropertyBinding: `bind`, `one-time`, `to-view`, `from-view`, `two-way`\n * - IteratorBinding: `for`\n * - CallBinding: `call`\n * - RefBinding: `ref`\n * - InterpolationBinding: `${}`\n * - SetProperty\n * - `customElement` hydration\n * - `customAttribute` hydration\n * - `templateController` hydration\n * - `let` element hydration\n * - Listener Bindings: `trigger`, `capture`, `delegate`\n * - SetAttribute\n * - StyleProperty: `style`, `css`\n * - TextBinding: `${}`\n */\nexport const DefaultRenderers = [\n  PropertyBindingRenderer,\n  IteratorBindingRenderer,\n  RefBindingRenderer,\n  InterpolationBindingRenderer,\n  SetPropertyRenderer,\n  CustomElementRenderer,\n  CustomAttributeRenderer,\n  TemplateControllerRenderer,\n  LetElementRenderer,\n  ListenerBindingRenderer,\n  AttributeBindingRenderer,\n  SetAttributeRenderer,\n  SetClassAttributeRenderer,\n  SetStyleAttributeRenderer,\n  StylePropertyBindingRenderer,\n  TextBindingRenderer,\n  SpreadRenderer,\n  SpreadValueRenderer,\n];\n\nexport const StandardConfiguration = /*@__PURE__*/createConfiguration(noop);\n\nfunction createConfiguration(optionsProvider: ConfigurationOptionsProvider) {\n  return {\n    optionsProvider,\n    /**\n     * Apply this configuration to the provided container.\n     */\n    register(container: IContainer): IContainer {\n      const runtimeConfigurationOptions: IRuntimeHtmlConfigurationOptions = {\n        coercingOptions: {\n          enableCoercion: false,\n          coerceNullish: false\n        }\n      };\n\n      optionsProvider(runtimeConfigurationOptions);\n\n      /**\n       * Standard DI configuration containing html-specific (but environment-agnostic) registrations:\n       * - `RuntimeConfiguration` from `@aurelia/runtime`\n       * - `DefaultComponents`\n       * - `DefaultResources`\n       * - `DefaultRenderers`\n       */\n      return container.register(\n        instanceRegistration(ICoercionConfiguration, runtimeConfigurationOptions.coercingOptions),\n        ExpressionParser,\n        ...DefaultComponents,\n        ...DefaultResources,\n        ...DefaultBindingSyntax,\n        ...DefaultBindingLanguage,\n        ...DefaultRenderers,\n      );\n    },\n    customize(cb?: ConfigurationOptionsProvider) {\n      return createConfiguration(cb ?? optionsProvider);\n    },\n  };\n}\n\nexport type ConfigurationOptionsProvider = (options: IRuntimeHtmlConfigurationOptions) => void;\ninterface IRuntimeHtmlConfigurationOptions {\n  coercingOptions: ICoercionConfiguration;\n}\n", "import { emptyArray, isString, type IContainer, type IServiceLocator, Key, IIndexable } from '@aurelia/kernel';\nimport { subscriberCollection , type ISubscriberCollection } from '@aurelia/runtime';\nimport { findElementControllerFor } from '../resources/custom-element';\nimport { ILifecycleHooks, lifecycleHooks } from './lifecycle-hooks';\nimport { def, objectAssign, safeString } from '../utilities';\nimport { instanceRegistration } from '../utilities-di';\nimport { type ICustomElementViewModel, type ICustomElementController } from './controller';\nimport { createMutationObserver } from '../utilities-dom';\n\nimport { ErrorNames, createMappedError } from '../errors';\nimport { getAnnotationKeyFor } from '../utilities-metadata';\nimport { IBinding } from '../binding/interfaces-bindings';\n\n/**\n * An interface describing options to observe the children elements of a custom element host\n */\nexport type PartialChildrenDefinition<TQuery extends string = string> = {\n  query?: TQuery;\n  callback?: PropertyKey;\n  name?: PropertyKey;\n  filter?: (node: TQuery extends '$all' ? Node : HTMLElement, viewModel: ICustomElementViewModel | null) => boolean;\n  map?: (node: TQuery extends '$all' ? Node : HTMLElement, viewModel: ICustomElementViewModel | null) => unknown;\n};\n\n/**\n * Decorator: Specifies custom behavior for an array children property that synchronizes its items with child content nodes of the element.\n *\n * @param config - The overrides\n */\nexport function children<TThis, TValue, TQuery extends string>(config?: PartialChildrenDefinition<TQuery>): (target: undefined, context: ClassFieldDecoratorContext<TThis,TValue>) => void;\n/**\n * Decorator: Specifies an array property on a class that synchronizes its items with child content nodes of the element.\n *\n * @param selector - The CSS element selector for filtering children. Use `$all` to select everything including non element nodes.\n * If nothing is provided, it defaults to `*`, which means all elements\n */\nexport function children<TThis, TValue>(selector: string): (target: undefined, context: ClassFieldDecoratorContext<TThis,TValue>) => void;\n/**\n * Decorator: Decorator: Specifies an array property that synchronizes its items with child content nodes of the element.\n *\n * @param target - The class\n * @param prop - The property name\n */\nexport function children<TThis, TValue>(target: undefined, context: ClassFieldDecoratorContext<TThis,TValue>): void;\nexport function children<TThis, TValue, TQuery extends string>(configOrTarget?: PartialChildrenDefinition<TQuery> | string | undefined, context?: ClassFieldDecoratorContext<TThis,TValue>): void | ((target: undefined, context: ClassFieldDecoratorContext<TThis,TValue>) => void) {\n  if (!children.mixed) {\n    children.mixed = true;\n    subscriberCollection(ChildrenBinding, null!);\n    lifecycleHooks()(ChildrenLifecycleHooks, null!);\n  }\n  let config: PartialChildrenDefinition;\n\n  const dependenciesKey = getAnnotationKeyFor('dependencies');\n  function decorator(_target: undefined, context: ClassFieldDecoratorContext): void {\n    switch (context.kind) {\n      case 'field':\n        config.name = context.name;\n        break;\n    }\n\n    const dependencies = (context.metadata[dependenciesKey] ??= []) as Key[];\n    dependencies.push(new ChildrenLifecycleHooks(config as PartialChildrenDefinition & { name: PropertyKey } ?? {}));\n  }\n\n  if (arguments.length > 1) {\n    // Non invocation:\n    // - @children\n    config = {};\n    decorator(configOrTarget as undefined, context!);\n    return;\n  } else if (isString(configOrTarget)) {\n    // Direct call:\n    // - @children('div')(Foo)\n    config = {\n      query: configOrTarget,\n      // filter: (node: Node) => isElement(node) && node.matches(configOrTarget),\n      // map: el => el\n    };\n    return decorator;\n  }\n\n  // Invocation with or w/o opts:\n  // - @children()\n  // - @children({...opts})\n  config = configOrTarget === void 0 ? {} : configOrTarget;\n  return decorator;\n}\nchildren.mixed = false;\n\nexport interface ChildrenBinding extends ISubscriberCollection { }\n\n/**\n * A binding for observing & notifying the children of a custom element.\n */\nexport class ChildrenBinding implements IBinding {\n  /** @internal */\n  private readonly _callback: undefined | (() => void);\n  /** @internal */\n  private _children: unknown[] = (void 0)!;\n  /** @internal */\n  private readonly _observer: MutationObserver;\n  /** @internal */\n  private readonly _host: HTMLElement;\n  /** @internal */\n  private readonly _query: string;\n  /** @internal */\n  private readonly _filter?: (node: Node, viewModel: ICustomElementViewModel | null) => boolean;\n  /** @internal */\n  private readonly _map?: (node: Node, viewModel: ICustomElementViewModel | null) => unknown;\n\n  public isBound = false;\n  public readonly obj: ICustomElementViewModel;\n\n  public constructor(\n    host: HTMLElement,\n    obj: ICustomElementViewModel,\n    callback: undefined | (() => void),\n    query: string,\n    filter?: (node: Node, viewModel: ICustomElementViewModel | null) => boolean,\n    map?: (node: Node, viewModel: ICustomElementViewModel | null) => unknown,\n  ) {\n    this.obj = obj;\n    this._callback = callback;\n    this._query = query;\n    this._filter = filter;\n    this._map = map;\n    this._observer = createMutationObserver(this._host = host, () => {\n      this._onChildrenChanged();\n    });\n  }\n\n  public getValue(): unknown[] {\n    return this.isBound ? this._children : this._getNodes();\n  }\n\n  public setValue(_value: unknown): void { /* do nothing */ }\n\n  public bind(): void {\n    if (this.isBound) {\n      return;\n    }\n    this.isBound = true;\n    this._observer.observe(this._host, { childList: true });\n    this._children = this._getNodes();\n  }\n\n  public unbind(): void {\n    if (!this.isBound) {\n      return;\n    }\n    this.isBound = false;\n    // prevent memory leaks\n    this._observer.takeRecords();\n    this._observer.disconnect();\n    this._children = emptyArray;\n  }\n\n  /** @internal */\n  private _onChildrenChanged(): void {\n    this._children = this._getNodes();\n\n    this._callback?.call(this.obj);\n    this.subs.notify(this._children, undefined);\n  }\n\n  public get(): ReturnType<IServiceLocator['get']> {\n    throw createMappedError(ErrorNames.method_not_implemented, 'get');\n  }\n\n  /** @internal */\n  // freshly retrieve the children everytime\n  // in case this observer is not observing\n  private _getNodes() {\n    const query = this._query;\n    const filter = this._filter;\n    const map = this._map;\n    const nodes = query === '$all' ? this._host.childNodes : this._host.querySelectorAll(`:scope > ${query}`);\n    const ii = nodes.length;\n    const results: unknown[] = [];\n    const findControllerOptions = { optional: true };\n    let $controller: ICustomElementController | null;\n    let viewModel: ICustomElementViewModel | null;\n    let i = 0;\n    let node: Node;\n    while (ii > i) {\n      node = nodes[i];\n      $controller = findElementControllerFor(node, findControllerOptions);\n      viewModel = $controller?.viewModel ?? null;\n      if (filter == null ? true : filter(node, viewModel)) {\n        results.push(map == null ? viewModel ?? node : map(node, viewModel));\n      }\n      ++i;\n    }\n    return results;\n  }\n}\n\nclass ChildrenLifecycleHooks {\n  public constructor(\n    private readonly _def: PartialChildrenDefinition & { name: PropertyKey },\n  ) {}\n\n  public register(c: IContainer) {\n    instanceRegistration(ILifecycleHooks, this).register(c);\n  }\n\n  public hydrating(vm: IIndexable, controller: ICustomElementController) {\n    const $def = this._def;\n    const query = $def.query ?? '*';\n    const childrenObserver = new ChildrenBinding(\n      controller.host,\n      vm,\n      vm[$def.callback ?? `${safeString($def.name)}Changed`] as () => void,\n      query,\n      $def.filter as PartialChildrenDefinition<'$all'>['filter'],\n      $def.map as PartialChildrenDefinition<'$all'>['map'],\n    );\n    if (/[\\s>]/.test(query)) {\n      throw createMappedError(ErrorNames.children_invalid_query, query);\n    }\n    def(vm, $def.name, {\n      enumerable: true,\n      configurable: true,\n      get: objectAssign((/* ChildrenBinding */) => childrenObserver.getValue(), { getObserver: () => childrenObserver }),\n      set: (/* ChildrenBinding */) => {\n        if (__DEV__) {\n          // eslint-disable-next-line no-console\n          console.warn(`[DEV:aurelia] property ${safeString($def.name)} decorated with @children is readonly`);\n        }\n      },\n    });\n    controller.addBinding(childrenObserver);\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/ban-ts-comment */\nfunction testChildrenDecorator() {\n  class MyEl {\n    @children({\n      filter: (element) => element.getAttribute('hey') == null,\n      map: el => el.style\n    })\n    @children({\n      map: node => node.style\n    })\n    @children({\n      query: '$all',\n      // @ts-expect-error\n      map: node => node.style\n    })\n    public nodes: unknown[] = [];\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_dist", "_a", "nextChar", "lookup", "def", "_a", "_b", "_c", "_d", "factory", "inject", "key", "Resolver", "factory", "_b", "_a", "_c", "error", "factory", "_a", "isRegistry", "optional", "safeString", "createLookup", "createMappedError", "safeString", "getMessageByCode", "errorsMap", "_a", "createLookup", "id", "DAE", "DASE", "optional", "_optional", "createMappedError", "createLookup", "lookup", "IdParts", "CharScanners", "singletonRegistration", "etInterpolation", "etIsFunction", "etIsProperty", "createMappedError", "getMessageByCode", "errorsMap", "_a", "isSymbol", "def", "getMetadata", "defineMetadata", "containerless", "alias", "capture", "def", "singletonRegistration", "alias", "createMappedError", "getMetadata", "getDefinitionFromStaticAu", "_a", "defineMetadata", "info", "etIsProperty", "bindable", "etIsFunction", "_a", "children", "id", "_b", "createMappedError", "bindable", "bindingCommand", "etInterpolation", "etIsProperty", "capture", "_c", "_d", "_e", "bindables", "def", "singletonRegistration", "context", "createMappedError", "getMessageByCode", "errorsMap", "_a", "ekAccessThis", "ekAccessBoundary", "ekAccessGlobal", "ekAccessScope", "ekArrayLiteral", "ekObjectLiteral", "ekPrimitiveLiteral", "ekTemplate", "ekUnary", "ekCallScope", "ekCallMember", "ekCallFunction", "ekCallGlobal", "ekAccessMember", "ekAccessKeyed", "ekTaggedTemplate", "ekBinary", "ekConditional", "ekAssign", "ekArrowFunction", "ekValueConverter", "ekBindingBehavior", "ekArrayBindingPattern", "ekObjectBindingPattern", "ekBindingIdentifier", "ekForOfStatement", "ekInterpolation", "ekArrayDestructuring", "ekObjectDestructuring", "ekDestructuringAssignmentLeaf", "ekCustom", "astEvaluate", "safeString", "astAssign", "astBind", "_b", "_c", "astUnbind", "subscriberCollection", "createMappedError", "o", "_a", "getArrayObserver", "getSetObserver", "getMapObserver", "observeCollection", "connectableDecorator", "connectable", "coercer", "_b", "lookup", "observable", "context", "import_dist", "_a", "_b", "task", "resolve", "console", "info", "id", "notImplemented", "_a", "getMetadata", "defineMetadata", "annotation", "getAnnotationKeyFor", "safeString", "objectFreeze", "objectAssign", "etInterpolation", "etIsIterator", "etIsFunction", "etIsProperty", "tsPending", "tsRunning", "atObserver", "atNode", "atLayout", "createMappedError", "getMessageByCode", "errorsMap", "_a", "getBindingCommandHelp", "context", "bindables", "isArray", "def", "bindable", "coercer", "createInterface", "singletonRegistration", "aliasRegistration", "instanceRegistration", "resource", "alias", "bindingHandlerMap", "defaultDelay", "IPlatform", "$IPlatform", "containerLookup", "lookup", "target", "task", "dispose", "mixed", "queueTaskOptions", "_b", "capture", "insertManyBefore", "isElement", "defaultSlotName", "auslotAttr", "classes", "SetPropertyRenderer", "CustomElementRenderer", "containerless", "CustomAttributeRenderer", "TemplateControllerRenderer", "LetElementRenderer", "RefBindingRenderer", "InterpolationBindingRenderer", "PropertyBindingRenderer", "IteratorBindingRenderer", "TextBindingRenderer", "error", "ListenerBindingRenderer", "SetAttributeRenderer", "SetClassAttributeRenderer", "SetStyleAttributeRenderer", "StylePropertyBindingRenderer", "AttributeBindingRenderer", "SpreadRenderer", "SpreadValueRenderer", "factory", "all", "container", "wrap", "unwrap", "none", "createLocation", "resolve", "children", "processContent", "name", "generateElementName", "id", "cur", "createError", "info", "option", "oV", "key", "getCollectionObserver", "_c", "_d", "_e", "$index", "$length", "activating", "activated", "deactivating", "deactivated", "model"]
}
